<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>「93」ebpf之XDP</title>
    <url>/archives/110bb26b.html</url>
    <content><![CDATA[<p>一转眼就2023了,好多文章都在2022没有发出来,成为了Drafts…</p>
<p>最近在搞Linux(瞎搞)的iptables防火墙,有一次被tcp attack了,当时想着iptables怎么都够了,结果没有想到的是:<br>
CPU近乎满载(后模拟了下,是cpu软中断占用过高).</p>
<p>还有一次被dns udp投毒了恶心到了,</p>
<p>开门见山吧,cpu 软中断问题,是这次致命的,用替代的方案ebpf可以比较好的解决(不能完全避免).</p>
<span id="more"></span>
<h2 id="iptables分析"><a class="header-anchor" href="#iptables分析">¶</a>iptables分析</h2>
<h3 id="优势"><a class="header-anchor" href="#优势">¶</a>优势:</h3>
<ul>
<li>简洁</li>
<li>易用</li>
<li>规则可查</li>
<li>可随处google/baidu</li>
</ul>
<h3 id="短板"><a class="header-anchor" href="#短板">¶</a>短板</h3>
<p>(如果你是iptables的raw/bpf级别的用户,就别往下看了,你已经巅峰[疯]了).</p>
<ul>
<li>更新规则需要重新reload ALL,更新后加载成本太高过高(尤其是过w的规则).</li>
<li>匹配效率O(n),线性的.</li>
</ul>
<h2 id="ebpf-替代-iptables"><a class="header-anchor" href="#ebpf-替代-iptables">¶</a>ebpf 替代 iptables</h2>
<h3 id="介绍-不翻译-自己食用—-ebpf官网"><a class="header-anchor" href="#介绍-不翻译-自己食用—-ebpf官网">¶</a>介绍(不翻译,自己食用—&gt;<a href="https://ebpf.io/">ebpf官网</a>):</h3>
<blockquote>
<p>简单的说,code被JIT编译成字节码,通过挂载的方式,挂到内核指定区域.</p>
</blockquote>
<blockquote>
<p>结构图:<br>
<img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/2023-01-31-23-16-16-0e8276bf40a642b19e21f118389b0e3d-202301312316500-6bd787.png" alt=""></p>
</blockquote>
<h3 id="优势-v2"><a class="header-anchor" href="#优势-v2">¶</a>优势:</h3>
<ul>
<li>性能好</li>
<li>安全+方便</li>
<li>可编程/定制化</li>
<li>可追踪能力(probe).</li>
</ul>
<h3 id="前期卡点"><a class="header-anchor" href="#前期卡点">¶</a>前期卡点:</h3>
<ul>
<li>需要开发者有一定的编程能力</li>
<li>对内核需要一定了解(推荐两个著作)
<ul>
<li><a href="https://book.douban.com/subject/2287506/">深入理解LINUX内核(第三版)</a></li>
<li><a href="https://book.douban.com/subject/4843567/">深入Linux内核架构</a></li>
</ul>
</li>
</ul>
<h2 id="开发流程"><a class="header-anchor" href="#开发流程">¶</a>开发流程</h2>
<h3 id="开发语言"><a class="header-anchor" href="#开发语言">¶</a>开发语言:</h3>
<blockquote>
<p>支持ebpf的即可[rust/go/c/c++等], 这里用的是rust实现.</p>
</blockquote>
<h3 id="推荐库"><a class="header-anchor" href="#推荐库">¶</a>推荐库</h3>
<blockquote>
<p>随便哪一个皆可.</p>
</blockquote>
<ul>
<li><a href="https://github.com/aya-rs/aya">aya</a></li>
<li><a href="https://github.com/foniod/redbpf">readbpf</a></li>
</ul>
<h3 id="开发模版"><a class="header-anchor" href="#开发模版">¶</a>开发模版:</h3>
<p>按教程版来,一个简单的bpf程序没什么问题,开发过程就不讲了,完全看理解了(网络模型/linux内核/IO模型/三态).</p>
<blockquote>
<p>https://aya-rs.dev/book/</p>
</blockquote>
<h2 id="性能对比-终态"><a class="header-anchor" href="#性能对比-终态">¶</a>性能对比(终态)</h2>
<p>这次实现功能比较多:</p>
<ul>
<li>防ddos</li>
<li>防syn flood</li>
<li>禁用icmp</li>
<li>white ip</li>
<li>disable udp/tcp/arp等</li>
<li>开放指定端口</li>
<li>dns防投毒</li>
<li>mac地址可校验</li>
<li>指纹学习匹配,防sliding window attack(需要跑一段时间学习指纹)</li>
<li>等等(还在继续添加中)</li>
</ul>
<blockquote>
<p>这里通过: 1、开启iptables 2、开启ebpf 3、关闭所有防护(没意义,裸奔挨打的状态)<br>
主要比较前两种.</p>
</blockquote>
<h3 id="测试方法"><a class="header-anchor" href="#测试方法">¶</a>测试方法</h3>
<ul>
<li>开启iptables,关闭ebpf,两个服务器(A、B)对C服务器进行hping3模拟.</li>
<li>关闭iptables,开启ebpf,两个服务器(A、B)对C服务器进行hping3模拟.</li>
</ul>
<blockquote>
<p>主要观察cpu各个状态.</p>
</blockquote>
<h3 id="开启iptables-关闭ebpf"><a class="header-anchor" href="#开启iptables-关闭ebpf">¶</a>开启iptables,关闭ebpf</h3>
<blockquote>
<p>左上用mpstat显示的cpu和IO等信息.<br>
右上是iptables仅开放2022(ssh端口),其余所有都drop掉.<br>
右中是nload显示的实时带宽信息.</p>
</blockquote>
<ul>
<li>
<p>单个tcp模拟攻击:<br>
<img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/2023-02-01-00-37-16-23f522ecaf76a70ceeba2c81accd0b42-1-1-4f84e3.png" alt=""></p>
</li>
<li>
<p>两个tcp模拟攻击<br>
<img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/2023-02-01-00-38-09-98a9cabf5c0b54f9f1a307ffcf96a5cf-1-2-bff12b.png" alt=""></p>
</li>
</ul>
<blockquote>
<p>重要的两个信息:</p>
</blockquote>
<table>
<thead>
<tr>
<th>attack/percent</th>
<th>cpu 软中断</th>
<th>idle(闲置)</th>
<th>cpu占用</th>
</tr>
</thead>
<tbody>
<tr>
<td>单个</td>
<td>5.9%</td>
<td>78%</td>
<td>19%</td>
</tr>
<tr>
<td>两个</td>
<td>14%</td>
<td>68%</td>
<td>32%</td>
</tr>
</tbody>
</table>
<h3 id="关闭iptables-开启ebpf"><a class="header-anchor" href="#关闭iptables-开启ebpf">¶</a>关闭iptables,开启ebpf</h3>
<ul>
<li>
<p>单个tcp模拟攻击:<br>
<img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/2023-02-01-00-38-44-bbd5d271793613f99a812c98fe0c4a4f-2-1-e1561d.png" alt=""></p>
</li>
<li>
<p>两个tcp模拟攻击<br>
<img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/2023-02-01-00-38-49-9a2d13c91dc81f6d9ef3779c33f76811-2-2-b37c75.png" alt=""></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>模拟攻击个数/百分比</th>
<th>cpu 软中断</th>
<th>idle(闲置)</th>
<th>cpu占用</th>
</tr>
</thead>
<tbody>
<tr>
<td>单个</td>
<td>1.08%</td>
<td>87%</td>
<td>15%</td>
</tr>
<tr>
<td>两个</td>
<td>1.16%</td>
<td>88%</td>
<td>17%</td>
</tr>
</tbody>
</table>
<h3 id="结论"><a class="header-anchor" href="#结论">¶</a>结论</h3>
<p>可以看到随着模拟攻击server越来越多,被攻击的服务器cpu占用越来越高,中断占用也越来越高,</p>
<p>最后肯定会崩了.</p>
<p>当然ebpf还有很多用处,可以参考学习<a href="https://arthurchiao.art/blog/bpf-advanced-notes-2-zh/#2-bpf_map_type_percpu_array">bpf进阶笔记</a>和<a href="https://ebpf.io/applications">ebpf官网例子</a>.</p>
<p>路漫漫其修远兮,</p>
<h2 id="Reference"><a class="header-anchor" href="#Reference">¶</a>Reference</h2>
<ul>
<li><a href="https://www.kernel.org/doc/htmldocs/kernel-hacking/basics-softirqs.html">soft interrupt</a></li>
<li><a href="https://ebpf.io/">ebpf官方</a></li>
<li><a href="https://aya-rs.dev/book/aya/aya-tool/#portability-and-different-kernel-versions">aya-rust</a></li>
<li><a href="https://www.techempower.com/benchmarks/#section=data-r21">HTTP SERVER天梯排行榜</a></li>
<li><a href="https://wsgzao.github.io/post/mpstat/">mpstat使用</a></li>
<li><a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md">bcc手册</a></li>
<li><a href="https://juejin.cn/post/6993853593476399140">hping3</a></li>
<li><a href="https://www.litreily.top/2018/02/22/ddos-attack/">DDos 攻击</a></li>
<li><a href="https://www.iovisor.org/technology/xdp">iovisor: XDP</a></li>
<li><a href="https://www.cnblogs.com/poloyy/p/13435519.html">cpu软中断</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc1323">RFC: timestamps</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc1337.html">RFC: time_wait</a></li>
<li><a href="https://cshihong.github.io/2019/05/14/%E7%BD%91%E7%BB%9C%E5%B1%82-TCP-UDP-%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%8E%9F%E7%90%86/">tcp/udp攻防</a></li>
<li><a href="https://blog.cloudflare.com/zh-cn/how-to-drop-10-million-packets-zh-cn/">Cloudflare每秒丢1000w个包</a></li>
<li><a href="https://rexrock.github.io/post/af_xdp1/">博客: AF_XDP</a></li>
<li><a href="https://arthurchiao.art/blog/bpf-advanced-notes-2-zh/#2-bpf_map_type_percpu_array">博客: BPF进阶笔记</a></li>
<li><a href="https://github.com/DavadDi/bpf_study">Github: bpf学习</a></li>
<li><a href="https://github.com/shaneutt/ebpf-rust-udp-loadbalancer-demo">Github: lb-demo</a></li>
<li><a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/bpf.h?spm=a2c6h.12873639.article-detail.9.6f07275atwbfFQ&amp;file=bpf.h">Linux源码: bpf</a></li>
<li><a href="https://github.com/torvalds/linux/blob/22b8077d0fcec86c6ed0e0fce9f7e7e5a4c2d56a/samples/bpf/xdp_sample.bpf.h#L19">Linux源码: xdp_sample</a></li>
<li><a href="https://github.com/torvalds/linux/blob/22b8077d0fcec86c6ed0e0fce9f7e7e5a4c2d56a/include/uapi/linux/in.h#L37">Linux源码: uapi/linux/in.h</a></li>
</ul>
]]></content>
      <tags>
        <tag>源码</tag>
        <tag>linux</tag>
        <tag>ebpf</tag>
        <tag>XDP</tag>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>「64」Redis基本类型</title>
    <url>/archives/f7742c12.html</url>
    <content><![CDATA[<h2 id="基本类型"><a class="header-anchor" href="#基本类型">¶</a>基本类型</h2>
<ul>
<li>string</li>
<li>list</li>
<li>hash</li>
<li>set</li>
<li>zset</li>
</ul>
<blockquote>
<p>长话短说,这里只说重点部分,细节实现这里不累赘.</p>
</blockquote>
<span id="more"></span>
<h3 id="string"><a class="header-anchor" href="#string">¶</a>string</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/2022-11-15-20-12-49-7438724996b926ca9341f6161343380f-base_string-36ccb9.png" alt=""></p>
<h3 id="list"><a class="header-anchor" href="#list">¶</a>list</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/2022-11-15-20-12-54-8d3f285372cfa18ad57abee21ccf85b8-redis_base_list-ff378b.png" alt=""></p>
<h3 id="hash"><a class="header-anchor" href="#hash">¶</a>hash</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/2022-11-15-20-12-54-a2dce150f971ac9f6cd83e0e45f43021-redis_base_hash-9c5eb7.png" alt=""></p>
<h3 id="zset"><a class="header-anchor" href="#zset">¶</a>zset</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/2022-11-15-20-12-54-1a22c49d8afa7b6e2de6d5045b8df8b0-redis_base_zset-c97a1b.png" alt=""></p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian 升级kernel</title>
    <url>/archives/2ea02468.html</url>
    <content><![CDATA[<p>好久都没升级内核了，来试试升级下，尝下新特性。<br>
当前系统：Debian 11<br>
内核： 5.10<br>
目标内核： 5.18（当前最新的）</p>
<span id="more"></span>
<h2 id="修改源（国外机器跳过）"><a class="header-anchor" href="#修改源（国外机器跳过）">¶</a>修改源（国外机器跳过）</h2>
<blockquote>
<p>/etc/apt/source.list</p>
</blockquote>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/debian/">→ 清华源</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free</span><br><span class="line"> </span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free</span><br><span class="line"> </span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="更新源和软件"><a class="header-anchor" href="#更新源和软件">¶</a>更新源和软件</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade</span><br></pre></td></tr></table></figure>
<h2 id="安装内核"><a class="header-anchor" href="#安装内核">¶</a>安装内核</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt -t bullseye-backports install linux-image-amd64</span><br><span class="line">apt -t bullseye-backports install linux-headers-amd64</span><br><span class="line"></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
<h3 id="精准安装"><a class="header-anchor" href="#精准安装">¶</a>精准安装</h3>
<p>先找到想安装的版本，再重复【安装内核】过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-cache search linux-image </span><br></pre></td></tr></table></figure>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/clipboard_20220916_012249.png" alt=""></p>
<h2 id="效果图："><a class="header-anchor" href="#效果图：">¶</a>效果图：</h2>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/clipboard_20220916_012132.png" alt=""></p>
<h2 id="🔚"><a class="header-anchor" href="#🔚">¶</a>🔚</h2>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>debian</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title>「91」regex</title>
    <url>/archives/ff6a07f.html</url>
    <content><![CDATA[<h3 id="场景：vscode"><a class="header-anchor" href="#场景：vscode">¶</a>场景：vscode</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">搜索空白：</span><br><span class="line">^\s*(?=\r?$)\n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">删除某些字符所在的行：</span><br><span class="line">^.*(string1|string2|string3).*\n</span><br></pre></td></tr></table></figure>
<h3 id="Linux"><a class="header-anchor" href="#Linux">¶</a>Linux</h3>
<h4 id="删除文本中的空行"><a class="header-anchor" href="#删除文本中的空行">¶</a>删除文本中的空行</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep实现:</span><br><span class="line"></span><br><span class="line">grep -v &#x27;^\s*$&#x27; test.txt</span><br></pre></td></tr></table></figure>
<h3 id="awk"><a class="header-anchor" href="#awk">¶</a>awk</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、求和</span><br><span class="line"></span><br><span class="line">cat data|awk &#x27;&#123;sum+=$1&#125; END &#123;print &quot;Sum = &quot;, sum&#125;&#x27;</span><br><span class="line"></span><br><span class="line">2、求平均</span><br><span class="line"></span><br><span class="line">cat data|awk &#x27;&#123;sum+=$1&#125; END &#123;print &quot;Average = &quot;, sum/NR&#125;&#x27;</span><br><span class="line"></span><br><span class="line">3、求最大值</span><br><span class="line"></span><br><span class="line">cat data|awk &#x27;BEGIN &#123;max = 0&#125; &#123;if ($1&gt;max) max=$1 fi&#125; END &#123;print &quot;Max=&quot;, max&#125;&#x27;</span><br><span class="line"></span><br><span class="line">4、求最小值（min的初始值设置一个超大数即可）</span><br><span class="line"></span><br><span class="line">awk &#x27;BEGIN &#123;min = 1999999&#125; &#123;if ($1&lt;min) min=$1 fi&#125; END &#123;print &quot;Min=&quot;, min&#125;&#x27;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>「90」kubebuilder</title>
    <url>/archives/675841d.html</url>
    <content><![CDATA[<p>作为k8s 官方提供的扩展能力，介绍的就不多说了，看这里 <a href="https://book.kubebuilder.io/quick-start.html"> ☞ Kubebuilder Quick Start</a></p>
<p>开干吧：</p>
<span id="more"></span>
<h3 id="依赖"><a class="header-anchor" href="#依赖">¶</a>依赖</h3>
<h3 id="init-project初始化"><a class="header-anchor" href="#init-project初始化">¶</a>init project初始化</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mkdir project</span><br><span class="line"></span><br><span class="line">cd project</span><br><span class="line"></span><br><span class="line">kubebuilder init --domain imrcrab.com --repo github.com/crab21/k8s-op --skip-<span class="keyword">go</span>-version-check</span><br></pre></td></tr></table></figure>
<blockquote>
<p>完成后就可以看到这样的目录结构{可能后续版本变化，结构也会变化}：</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># tree -L 10</span></span><br><span class="line">.</span><br><span class="line">├── config</span><br><span class="line">│   ├── default</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   ├── manager<span class="emphasis">_auth_</span>proxy<span class="emphasis">_patch.yaml</span></span><br><span class="line"><span class="emphasis">│   │   └── manager_</span>config<span class="emphasis">_patch.yaml</span></span><br><span class="line"><span class="emphasis">│   ├── manager</span></span><br><span class="line"><span class="emphasis">│   │   ├── controller_</span>manager<span class="emphasis">_config.yaml</span></span><br><span class="line"><span class="emphasis">│   │   ├── kustomization.yaml</span></span><br><span class="line"><span class="emphasis">│   │   └── manager.yaml</span></span><br><span class="line"><span class="emphasis">│   ├── prometheus</span></span><br><span class="line"><span class="emphasis">│   │   ├── kustomization.yaml</span></span><br><span class="line"><span class="emphasis">│   │   └── monitor.yaml</span></span><br><span class="line"><span class="emphasis">│   └── rbac</span></span><br><span class="line"><span class="emphasis">│       ├── auth_</span>proxy<span class="emphasis">_client_</span>clusterrole.yaml</span><br><span class="line">│       ├── auth<span class="emphasis">_proxy_</span>role<span class="emphasis">_binding.yaml</span></span><br><span class="line"><span class="emphasis">│       ├── auth_</span>proxy<span class="emphasis">_role.yaml</span></span><br><span class="line"><span class="emphasis">│       ├── auth_</span>proxy<span class="emphasis">_service.yaml</span></span><br><span class="line"><span class="emphasis">│       ├── kustomization.yaml</span></span><br><span class="line"><span class="emphasis">│       ├── leader_</span>election<span class="emphasis">_role_</span>binding.yaml</span><br><span class="line">│       ├── leader<span class="emphasis">_election_</span>role.yaml</span><br><span class="line">│       ├── role<span class="emphasis">_binding.yaml</span></span><br><span class="line"><span class="emphasis">│       └── service_</span>account.yaml</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── hack</span><br><span class="line">│   └── boilerplate.go.txt</span><br><span class="line">├── main.go</span><br><span class="line">├── Makefile</span><br><span class="line">└── PROJECT</span><br><span class="line"></span><br><span class="line">6 directories, 24 files</span><br></pre></td></tr></table></figure>
<h3 id="create-API"><a class="header-anchor" href="#create-API">¶</a>create API</h3>
<blockquote>
<p>创建一个g: batch     v:v1    kind: CronJob的API</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">kubebuilder create api --group batch --version v1 --kind CronJob</span><br></pre></td></tr></table></figure>
<blockquote>
<p>完成后的目录结构{可能会随版本变化而变化}</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">─# tree -L 10</span><br><span class="line">.</span><br><span class="line">├── api</span><br><span class="line">│   └── v1</span><br><span class="line">│       ├── cronjob<span class="emphasis">_types.go</span></span><br><span class="line"><span class="emphasis">│       ├── groupversion_</span>info.go</span><br><span class="line">│       └── zz<span class="emphasis">_generated.deepcopy.go</span></span><br><span class="line"><span class="emphasis">├── bin</span></span><br><span class="line"><span class="emphasis">│   └── controller-gen</span></span><br><span class="line"><span class="emphasis">├── config</span></span><br><span class="line"><span class="emphasis">│   ├── crd</span></span><br><span class="line"><span class="emphasis">│   │   ├── kustomization.yaml</span></span><br><span class="line"><span class="emphasis">│   │   ├── kustomizeconfig.yaml</span></span><br><span class="line"><span class="emphasis">│   │   └── patches</span></span><br><span class="line"><span class="emphasis">│   │       ├── cainjection_</span>in<span class="emphasis">_cronjobs.yaml</span></span><br><span class="line"><span class="emphasis">│   │       └── webhook_</span>in<span class="emphasis">_cronjobs.yaml</span></span><br><span class="line"><span class="emphasis">│   ├── default</span></span><br><span class="line"><span class="emphasis">│   │   ├── kustomization.yaml</span></span><br><span class="line"><span class="emphasis">│   │   ├── manager_</span>auth<span class="emphasis">_proxy_</span>patch.yaml</span><br><span class="line">│   │   └── manager<span class="emphasis">_config_</span>patch.yaml</span><br><span class="line">│   ├── manager</span><br><span class="line">│   │   ├── controller<span class="emphasis">_manager_</span>config.yaml</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── manager.yaml</span><br><span class="line">│   ├── prometheus</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   └── monitor.yaml</span><br><span class="line">│   ├── rbac</span><br><span class="line">│   │   ├── auth<span class="emphasis">_proxy_</span>client<span class="emphasis">_clusterrole.yaml</span></span><br><span class="line"><span class="emphasis">│   │   ├── auth_</span>proxy<span class="emphasis">_role_</span>binding.yaml</span><br><span class="line">│   │   ├── auth<span class="emphasis">_proxy_</span>role.yaml</span><br><span class="line">│   │   ├── auth<span class="emphasis">_proxy_</span>service.yaml</span><br><span class="line">│   │   ├── cronjob<span class="emphasis">_editor_</span>role.yaml</span><br><span class="line">│   │   ├── cronjob<span class="emphasis">_viewer_</span>role.yaml</span><br><span class="line">│   │   ├── kustomization.yaml</span><br><span class="line">│   │   ├── leader<span class="emphasis">_election_</span>role<span class="emphasis">_binding.yaml</span></span><br><span class="line"><span class="emphasis">│   │   ├── leader_</span>election<span class="emphasis">_role.yaml</span></span><br><span class="line"><span class="emphasis">│   │   ├── role_</span>binding.yaml</span><br><span class="line">│   │   └── service<span class="emphasis">_account.yaml</span></span><br><span class="line"><span class="emphasis">│   └── samples</span></span><br><span class="line"><span class="emphasis">│       └── batch_</span>v1<span class="emphasis">_cronjob.yaml</span></span><br><span class="line"><span class="emphasis">├── controllers</span></span><br><span class="line"><span class="emphasis">│   ├── cronjob_</span>controller.go</span><br><span class="line">│   └── suite<span class="emphasis">_test.go</span></span><br><span class="line"><span class="emphasis">├── Dockerfile</span></span><br><span class="line"><span class="emphasis">├── go.mod</span></span><br><span class="line"><span class="emphasis">├── go.sum</span></span><br><span class="line"><span class="emphasis">├── hack</span></span><br><span class="line"><span class="emphasis">│   └── boilerplate.go.txt</span></span><br><span class="line"><span class="emphasis">├── main.go</span></span><br><span class="line"><span class="emphasis">├── Makefile</span></span><br><span class="line"><span class="emphasis">└── PROJECT</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">13 directories, 37 files</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>operator</tag>
        <tag>kubebuilder</tag>
      </tags>
  </entry>
  <entry>
    <title>「84」tcpdump &amp; wireshark</title>
    <url>/archives/a4b12394.html</url>
    <content><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/Tcpdump">☞ tcpdump：</a>命令行下的转包工具。</p>
<span id="more"></span>
<h3 id="官方定义"><a class="header-anchor" href="#官方定义">¶</a>官方定义</h3>
<p><a href="https://www.tcpdump.org/">→ tcpdump官网</a></p>
<h3 id="使用场景"><a class="header-anchor" href="#使用场景">¶</a>使用场景</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># -s 数据包的大小 port代表端口</span><br><span class="line">tcpdump  -s <span class="number">0</span> port <span class="number">443</span></span><br><span class="line"></span><br><span class="line">tcpdump -vvv -i eth0 </span><br></pre></td></tr></table></figure>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/clipboard_20220203_061422.png" alt=""><br>
<img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/clipboard_20220203_062657.png" alt=""><br>
…<br>
…<br>
…</p>
<ul>
<li>查看端口流量</li>
<li>抓取指定端口数据包，可用wireshark分析</li>
<li>icmp/tcp/udp等抓包分析</li>
<li>…</li>
</ul>
<h3 id="基本用法"><a class="header-anchor" href="#基本用法">¶</a>基本用法</h3>
<h4 id="help用法"><a class="header-anchor" href="#help用法">¶</a>help用法</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@VM-4-8-debian:~# tcpdump --help</span><br><span class="line">tcpdump version 4.99.0</span><br><span class="line">libpcap version 1.10.0 (with TPACKET_V3)</span><br><span class="line">OpenSSL 1.1.1k  25 Mar 2021</span><br><span class="line">Usage: tcpdump [-AbdDefhHIJKlLnNOpqStuUvxX#] [ -B size ] [ -c count ] [--count]</span><br><span class="line">		[ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]</span><br><span class="line">		[ -i interface ] [ --immediate-mode ] [ -j tstamptype ]</span><br><span class="line">		[ -M secret ] [ --number ] [ --print ] [ -Q in|out|inout ]</span><br><span class="line">		[ -r file ] [ -s snaplen ] [ -T type ] [ --version ]</span><br><span class="line">		[ -V file ] [ -w file ] [ -W filecount ] [ -y datalinktype ]</span><br><span class="line">		[ --time-stamp-precision precision ] [ --micro ] [ --nano ]</span><br><span class="line">		[ -z postrotate-command ] [ -Z user ] [ expression ]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这么多的用法，不可能一个个说，可以见名知意的就不解释了。</p>
</blockquote>
<p>这里有全部的命令行用法：</p>
<p><a href="https://packetlife.net/media/library/12/tcpdump.pdf">⚡️ tcpdump library</a></p>
<h4 id="常见使用"><a class="header-anchor" href="#常见使用">¶</a>常见使用</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -e 打印header</span><br><span class="line">tcpdump -e -i eth0  </span><br><span class="line"></span><br><span class="line"># tcp-ack类型的</span><br><span class="line">tcpdump -vv &#x27;tcp-ack!=0&#x27; </span><br></pre></td></tr></table></figure>
<h4 id="高阶用法"><a class="header-anchor" href="#高阶用法">¶</a>高阶用法</h4>
<p><a href="https://blog.wains.be/2007/2007-10-01-tcpdump-advanced-filters/">☞ tcpdump advanced</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">root@VM-4-8-debian:~# tcpdump -vv &#x27;tcp-ack!=0&#x27;</span><br><span class="line">tcpdump: listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">18:47:10.998761 IP (tos 0x10, ttl 64, id 23027, offset 0, flags [DF], proto TCP (6), length 164)</span><br><span class="line"></span><br><span class="line">    10.0.4.8.ssh &gt; 111.18.5.47.8452: Flags [P.], cksum 0x82df (incorrect -&gt; 0x3eec), seq 96990242:96990366, ack 1856675240, win 83, length 124</span><br><span class="line">18:47:11.032067 IP (tos 0x64, ttl 46, id 0, offset 0, flags [DF], proto TCP (6), length 40)</span><br><span class="line">    111.18.5.47.8452 &gt; 10.0.4.8.ssh: Flags [.], cksum 0x86f1 (correct), seq 1, ack 0, win 32579, length 0</span><br><span class="line">18:47:11.043267 IP (tos 0x1c, ttl 249, id 8009, offset 0, flags [none], proto TCP (6), length 40)</span><br><span class="line">    203.205.249.190.54339 &gt; 10.0.4.8.https: Flags [.], cksum 0xa0b6 (correct), seq 252872041, ack 855940619, win 65535, length 0</span><br><span class="line">18:47:11.043320 IP (tos 0x1c, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 40)</span><br><span class="line">    10.0.4.8.https &gt; 203.205.249.190.54339: Flags [R], cksum 0x353e (correct), seq 855940619, win 0, length 0</span><br><span class="line">18:47:11.053616 IP (tos 0x64, ttl 46, id 0, offset 0, flags [DF], proto TCP (6), length 40)</span><br><span class="line">    111.18.5.47.8452 &gt; 10.0.4.8.ssh: Flags [.], cksum 0x8676 (correct), seq 1, ack 124, win 32578, length 0</span><br><span class="line">18:47:11.081297 IP (tos 0x10, ttl 64, id 23028, offset 0, flags [DF], proto TCP (6), length 172)</span><br><span class="line">    10.0.4.8.ssh &gt; 111.18.5.47.8452: Flags [P.], cksum 0x82e7 (incorrect -&gt; 0x965f), seq 124:256, ack 1, win 83, length 132</span><br><span class="line">18:47:11.081595 IP (tos 0x0, ttl 64, id 12233, offset 0, flags [DF], proto UDP (17), length 70)</span><br><span class="line">    10.0.4.8.51812 &gt; 183.60.83.19.domain: [bad udp cksum 0x189b -&gt; 0xd360!] 24857+ PTR? 47.5.18.111.in-addr.arpa. (42)</span><br><span class="line">18:47:11.117741 IP (tos 0x1c, ttl 249, id 57452, offset 0, flags [none], proto TCP (6), length 40)</span><br><span class="line">    203.205.249.190.54340 &gt; 10.0.4.8.https: Flags [.], cksum 0xcd05 (correct), seq 1279984176, ack 855947195, win 65535, length 0</span><br><span class="line">18:47:11.117792 IP (tos 0x1c, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 40)</span><br><span class="line">    10.0.4.8.https &gt; 203.205.249.190.54340: Flags [R], cksum 0x1b8d (correct), seq 855947195, win 0, length 0</span><br><span class="line">18:47:11.138039 IP (tos 0x64, ttl 46, id 0, offset 0, flags [DF], proto TCP (6), length 40)</span><br><span class="line">    111.18.5.47.8452 &gt; 10.0.4.8.ssh: Flags [.], cksum 0x85f3 (correct), seq 1, ack 256, win 32577, length 0</span><br><span class="line">18:47:11.192735 IP (tos 0x1c, ttl 249, id 22872, offset 0, flags [none], proto TCP (6), length 40)</span><br><span class="line">    203.205.249.190.54341 &gt; 10.0.4.8.https: Flags [.], cksum 0x94a7 (correct), seq 1967847389, ack 855953771, win 65535, length 0</span><br><span class="line">18:47:11.192787 IP (tos 0x1c, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 40)</span><br><span class="line">    10.0.4.8.https &gt; 203.205.249.190.54341: Flags [R], cksum 0x01dc (correct), seq 855953771, win 0, length 0</span><br><span class="line">18:47:11.268178 IP (tos 0x1c, ttl 249, id 1432, offset 0, flags [none], proto TCP (6), length 40)</span><br><span class="line">    203.205.249.190.54342 &gt; 10.0.4.8.https: Flags [.], cksum 0x7592 (correct), seq 1082733059, ack 855960347, win 65535, length 0</span><br><span class="line">18:47:11.268235 IP (tos 0x1c, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 40)</span><br><span class="line">    10.0.4.8.https &gt; 203.205.249.190.54342: Flags [R], cksum 0xe82a (correct), seq 855960347, win 0, length 0</span><br><span class="line">18:47:11.342841 IP (tos 0x1c, ttl 249, id 3667, offset 0, flags [none], proto TCP (6), length 40)</span><br><span class="line">    203.205.249.190.54343 &gt; 10.0.4.8.https: Flags [.], cksum 0x39c7 (correct), seq 1302021899, ack 855966923, win 65535, length 0</span><br><span class="line">18:47:11.342894 IP (tos 0x1c, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 40)</span><br><span class="line">    10.0.4.8.https &gt; 203.205.249.190.54343: Flags [R], cksum 0xce79 (correct), seq 855966923, win 0, length 0</span><br><span class="line">18:47:11.416171 IP (tos 0x1c, ttl 249, id 17285, offset 0, flags [none], proto TCP (6), length 40)</span><br><span class="line">    203.205.249.190.54344 &gt; 10.0.4.8.https: Flags [.], cksum 0x9d47 (correct), seq 473889590, ack 855973499, win 65535, length 0</span><br><span class="line">18:47:11.416224 IP (tos 0x1c, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 40)</span><br><span class="line">    10.0.4.8.https &gt; 203.205.249.190.54344: Flags [R], cksum 0xb4c8 (correct), seq 855973499, win 0, length 0</span><br><span class="line">18:47:12.184512 IP (tos 0x60, ttl 247, id 56471, offset 0, flags [none], proto TCP (6), length 40)</span><br><span class="line">    203.205.159.40.42283 &gt; 10.0.4.8.https: Flags [.], cksum 0x9787 (correct), seq 2042582601, ack 1236197041, win 65535, length 0</span><br><span class="line">18:47:12.184583 IP (tos 0x60, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 40)</span><br><span class="line">    10.0.4.8.https &gt; 203.205.159.40.42283: Flags [R], cksum 0x679c (correct), seq 1236197041, win 0, length 0</span><br><span class="line">18:47:12.400485 IP (tos 0x0, ttl 64, id 37593, offset 0, flags [DF], proto TCP (6), length 108)</span><br><span class="line">^C    10.0.4.8.ssh &gt; 157.245.69.244.56074: Flags [P.], cksum 0xf24f (incorrect -&gt; 0x79f5), seq 397565160:397565228, ack 201251358, win 84, length 68</span><br><span class="line"></span><br><span class="line">21 packets captured</span><br><span class="line">1061 packets received by filter</span><br><span class="line">961 packets dropped by kernel</span><br></pre></td></tr></table></figure>
<h5 id="用法来源："><a class="header-anchor" href="#用法来源：">¶</a>用法来源：</h5>
<blockquote>
<p>按照tcp中划分的字节位来划分</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/clipboard_20220203_065122.png" alt=""></p>
<h4 id="导出wireshark包："><a class="header-anchor" href="#导出wireshark包：">¶</a>导出wireshark包：</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 -w test.cap/test.pcap</span><br></pre></td></tr></table></figure>
<p>导出后可以直接用wireshark打开，查看具体情况：</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/clipboard_20220203_065536.png" alt=""></p>
<h3 id="Reference"><a class="header-anchor" href="#Reference">¶</a>Reference</h3>
<ul>
<li><a href="https://www.tcpdump.org/index.html#documentation">→ tcpdump official</a></li>
<li><a href="https://wizardzines.com/zines/tcpdump/">→ tcpdump learn</a></li>
<li><a href="https://blog.wains.be/2007/2007-10-01-tcpdump-advanced-filters/">→ tcpdump cheat sheet</a></li>
<li><a href="https://blog.wains.be/2007/2007-10-01-tcpdump-advanced-filters/">→ tcpdump advanced filters</a></li>
</ul>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>网络</tag>
        <tag>抓包</tag>
        <tag>tcpdump</tag>
      </tags>
  </entry>
  <entry>
    <title>「83」mysql小记</title>
    <url>/archives/b09eedc6.html</url>
    <content><![CDATA[<p>MySQL常见的问题：</p>
<ul>
<li>
<p>select</p>
<ul>
<li>group by、order by、having 、 join等执行顺序</li>
<li>关于_rowid隐藏列</li>
<li>group by用法</li>
</ul>
</li>
<li>
<p>MMVC</p>
<ul>
<li>解决的问题</li>
</ul>
</li>
<li>
<p>误区</p>
<ul>
<li>group by和having</li>
</ul>
</li>
<li>
<p>索引不命中情况</p>
</li>
<li>
<p>效率问题</p>
<ul>
<li>in后面接大量数据效率低问题</li>
</ul>
</li>
<li>
<p>…</p>
</li>
</ul>
<span id="more"></span>
<h3 id="select-问题"><a class="header-anchor" href="#select-问题">¶</a>select 问题</h3>
<h4 id="group-by、order-by、having-、-join等执行顺序"><a class="header-anchor" href="#group-by、order-by、having-、-join等执行顺序">¶</a>group by、order by、having 、 join等执行顺序</h4>
<blockquote>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/select.html">摘抄自MySQL ☞ 13.2.10 SELECT Statement</a></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    [<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span> <span class="operator">|</span> DISTINCTROW ]</span><br><span class="line">    [HIGH_PRIORITY]</span><br><span class="line">    [STRAIGHT_JOIN]</span><br><span class="line">    [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]</span><br><span class="line">    [SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]</span><br><span class="line">    select_expr [, select_expr] ...</span><br><span class="line">    [into_option]</span><br><span class="line">    [<span class="keyword">FROM</span> table_references</span><br><span class="line">      [<span class="keyword">PARTITION</span> partition_list]]</span><br><span class="line">    [<span class="keyword">WHERE</span> where_condition]</span><br><span class="line">    [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &#123;col_name <span class="operator">|</span> expr <span class="operator">|</span> position&#125;, ... [<span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>]]</span><br><span class="line">    [<span class="keyword">HAVING</span> where_condition]</span><br><span class="line">    [<span class="keyword">WINDOW</span> window_name <span class="keyword">AS</span> (window_spec)</span><br><span class="line">        [, window_name <span class="keyword">AS</span> (window_spec)] ...]</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> &#123;col_name <span class="operator">|</span> expr <span class="operator">|</span> position&#125;</span><br><span class="line">      [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>], ... [<span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>]]</span><br><span class="line">    [LIMIT &#123;[<span class="keyword">offset</span>,] row_count <span class="operator">|</span> row_count <span class="keyword">OFFSET</span> <span class="keyword">offset</span>&#125;]</span><br><span class="line">    [into_option]</span><br><span class="line">    [<span class="keyword">FOR</span> &#123;<span class="keyword">UPDATE</span> <span class="operator">|</span> SHARE&#125;</span><br><span class="line">        [<span class="keyword">OF</span> tbl_name [, tbl_name] ...]</span><br><span class="line">        [NOWAIT <span class="operator">|</span> <span class="keyword">SKIP</span> LOCKED]</span><br><span class="line">      <span class="operator">|</span> LOCK <span class="keyword">IN</span> SHARE MODE]</span><br><span class="line">    [into_option]</span><br><span class="line"></span><br><span class="line">into_option: &#123;</span><br><span class="line">    <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;file_name&#x27;</span></span><br><span class="line">        [<span class="type">CHARACTER</span> <span class="keyword">SET</span> charset_name]</span><br><span class="line">        export_options</span><br><span class="line">  <span class="operator">|</span> <span class="keyword">INTO</span> DUMPFILE <span class="string">&#x27;file_name&#x27;</span></span><br><span class="line">  <span class="operator">|</span> <span class="keyword">INTO</span> var_name [, var_name] ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个看看自然明白：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 先连接from后的数据源(若有join，则先执行on后条件，再连接数据源)。</span><br><span class="line">2. 执行where条件</span><br><span class="line">3. 执行group by</span><br><span class="line">4. 执行having</span><br><span class="line">5. 执行order by</span><br></pre></td></tr></table></figure>
<h4 id="关于-rowid隐藏列"><a class="header-anchor" href="#关于-rowid隐藏列">¶</a>关于_rowid隐藏列</h4>
<p>同样的，先看<a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html">☞官方资料</a></p>
<blockquote>
<p>不过有一点需要注意：</p>
</blockquote>
<blockquote>
<p>If a table has a PRIMARY KEY or UNIQUE NOT NULL index that consists of a single column that has an integer type, you can use _rowid to refer to the indexed column in SELECT statements, as described in <a href="https://dev.mysql.com/doc/refman/8.0/en/create-index.html#create-index-unique">Unique Indexes</a>.</p>
</blockquote>
<h4 id="group-by用法"><a class="header-anchor" href="#group-by用法">¶</a>group by用法</h4>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-handling.html">官方资料: ☞ GROUP BY</a></p>
<p>注意点：</p>
<blockquote>
<p>Before 5.7.5, MySQL does not detect functional dependency and ONLY_FULL_GROUP_BY is not enabled by default. For a description of pre-5.7.5 behavior, see the MySQL <a href="https://dev.mysql.com/doc/refman/5.6/en/sql-mode.html">5.6 Reference Manual</a>.</p>
</blockquote>
<h3 id="MMVC问题"><a class="header-anchor" href="#MMVC问题">¶</a>MMVC问题</h3>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html">☞官方资料</a></p>
<p>这里不做过多解释了，就是个逻辑+锁的实现。</p>
<h3 id="使用误区"><a class="header-anchor" href="#使用误区">¶</a>使用误区</h3>
<h4 id="group-by和having"><a class="header-anchor" href="#group-by和having">¶</a>group by和having</h4>
<p>group by 和having的顺序小问题：</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/clipboard_20220129_060235.png" alt=""></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,_rowid <span class="keyword">from</span> test.table_name <span class="keyword">having</span>  id<span class="operator">&gt;</span><span class="number">2</span> <span class="keyword">group</span> <span class="keyword">by</span>  id; ❎</span><br><span class="line"><span class="keyword">select</span> id,name,_rowid <span class="keyword">from</span> test.table_name  <span class="keyword">group</span> <span class="keyword">by</span>  id <span class="keyword">where</span>  id<span class="operator">&gt;</span><span class="number">2</span>; √</span><br><span class="line"><span class="keyword">select</span> id,name,_rowid <span class="keyword">from</span> test.table_name <span class="keyword">where</span>  id<span class="operator">&gt;</span><span class="number">2</span> <span class="keyword">group</span> <span class="keyword">by</span>  id;  √</span><br></pre></td></tr></table></figure>
<h3 id="索引不命中情况"><a class="header-anchor" href="#索引不命中情况">¶</a>索引不命中情况</h3>
<h3 id="效率问题"><a class="header-anchor" href="#效率问题">¶</a>效率问题</h3>
<h4 id="IN-和-Exists"><a class="header-anchor" href="#IN-和-Exists">¶</a>IN 和 Exists</h4>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in">IN</a><br>
<a href="https://dev.mysql.com/doc/refman/8.0/en/exists-and-not-exists-subqueries.html">EXISTS</a></p>
<p>看完总结下：<br>
in：需要遍历后面的数据<br>
exists: 需要查询数据库</p>
<p>select * from A where id in(select id from B)<br>
select * from A where exists (select 1 from B where A.id=B.id);</p>
<p>B表数据大，推荐用exists。</p>
<h3 id="工具使用"><a class="header-anchor" href="#工具使用">¶</a>工具使用</h3>
<h3 id="Reference"><a class="header-anchor" href="#Reference">¶</a>Reference</h3>
<ul>
<li><a href="https://segmentfault.com/a/1190000037557620">☛ MMVC</a></li>
<li><a href="https://www.51cto.com/article/680143.html">☛ MySQL隐藏列</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-handling.html">☛ 12.20.3 MySQL Handling of GROUP BY</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/exists-and-not-exists-subqueries.html">☛ 13.2.11.6 Subqueries with EXISTS or NOT EXISTS</a></li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>小记</tag>
      </tags>
  </entry>
  <entry>
    <title>「82」openwrt 折腾记</title>
    <url>/archives/977b6995.html</url>
    <content><![CDATA[<p>最近买了个switch，因某些需求用到软路由，so…来折腾下。</p>
<span id="more"></span>
<h3 id="openwrt-地址"><a class="header-anchor" href="#openwrt-地址">¶</a>openwrt 地址</h3>
<p><a href="https://drive.google.com/drive/folders/1dqNUrMf9n7i3y1aSh68U5Yf44WQ3KCuh">👉🏿 esir GDQ版本 :</a></p>
<p>具体选择见下图：</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/1161636220122_.pic_hd.jpg" alt=""></p>
<h3 id="配置问题："><a class="header-anchor" href="#配置问题：">¶</a>配置问题：</h3>
<p>我这里采用docker跑的程序，so…需要镜像<br>
客户端：imrcrab/naive-client:v0.1.95<br>
服务端：imrcrab/naive-server:v0.2</p>
<blockquote>
<p>具体的可以在hub.docker.com里面搜索。</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20211107_065042.png" alt=""></p>
<h4 id="服务端："><a class="header-anchor" href="#服务端：">¶</a>服务端：</h4>
<blockquote>
<p>这里不多说，具体看教程：<a href="https://hub.docker.com/r/imrcrab/naive-server">Naive server搭建</a></p>
</blockquote>
<h4 id="客户端："><a class="header-anchor" href="#客户端：">¶</a>客户端：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">两步：</span><br><span class="line"><span class="number">1</span>、创建网络</span><br><span class="line"><span class="number">2</span>、docker run.....</span><br></pre></td></tr></table></figure>
<h5 id="网络创建方式："><a class="header-anchor" href="#网络创建方式：">¶</a>网络创建方式：</h5>
<blockquote>
<p>三步完成：</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20211107_065902.png" alt=""></p>
<h5 id="具体命令"><a class="header-anchor" href="#具体命令">¶</a>具体命令</h5>
<p>openwrt装好后，直接跑docker命令即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">docker run -itd --restart=always --network=gogo -m <span class="number">300</span>m --kernel-memory <span class="number">310</span>m --name naive95-client -p <span class="number">10899</span>:<span class="number">10800</span> -v /etc/localtime:/etc/localtime  imrcrab/naive-client:v0<span class="number">.1</span><span class="number">.95</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这里有一点很重要:</span><br><span class="line"><span class="code">    --network参数: 代表需要桥接的网络,我这里采用的是上一步自建的gogo</span></span><br></pre></td></tr></table></figure>
<h4 id="openwrt连接"><a class="header-anchor" href="#openwrt连接">¶</a>openwrt连接</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">找一个可以sock5 proxy的软件，填上上面的proxy port: <span class="number">10800</span>。</span><br><span class="line"></span><br><span class="line">确认好即可。</span><br></pre></td></tr></table></figure>
<h3 id="目前网络图："><a class="header-anchor" href="#目前网络图：">¶</a>目前网络图：</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20211107_070906.png" alt=""></p>
<h3 id="致谢"><a class="header-anchor" href="#致谢">¶</a>致谢</h3>
<ul>
<li><a href="https://github.com/coolsnowwolf/lede">LEDE</a></li>
<li><a href="https://github.com/esirplayground/AutoBuild-OpenWrt">esirplayground</a></li>
<li><a href="https://github.com/klzgrad/naiveproxy">Naive</a></li>
</ul>
]]></content>
      <tags>
        <tag>openwrt</tag>
        <tag>软路由</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>「62」redis rehash过程</title>
    <url>/archives/f733f408.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<blockquote>
<p>之前有提到过<a href="https://blog.imrcrab.com/archives/68b4ef49.html#more">👉🏿 redis 中hash的介绍</a>,如果不了解可以先看看 热热身。</p>
</blockquote>
<h3 id="rehash"><a class="header-anchor" href="#rehash">¶</a>rehash</h3>
<h4 id="时机："><a class="header-anchor" href="#时机：">¶</a>时机：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、定时任务。</span><br><span class="line"><span class="number">2</span>、对dict的find/<span class="built_in">delete</span>/add等操作时触发。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210817_115402.png" alt=""></p>
<h4 id="源码分析："><a class="header-anchor" href="#源码分析：">¶</a>源码分析：</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table, however</span></span><br><span class="line"><span class="comment"> * since part of the hash table may be composed of empty spaces, it is not</span></span><br><span class="line"><span class="comment"> * guaranteed that this function will rehash even a single bucket, since it</span></span><br><span class="line"><span class="comment"> * will visit at max N*10 empty buckets in total, otherwise the amount of</span></span><br><span class="line"><span class="comment"> * work it does would be unbound and the function may block for a long time. */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最大可以接受的空bucket数量</span></span><br><span class="line">    <span class="type">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">dictIsRehashing</span>(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ht第一个位置放的未rehash「没有转移前」的数据，第二个位置放的rehash后的数据。</span></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht_used[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">         <span class="comment">// rehashidx的值不能超过最大值，发生溢出</span></span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">DICTHT_SIZE</span>(d-&gt;ht_size_exp[<span class="number">0</span>]) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht_table[<span class="number">0</span>][d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 跳过空bucket</span></span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出数组的rehashidx下标对应的值，</span></span><br><span class="line">        de = d-&gt;ht_table[<span class="number">0</span>][d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="type">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            <span class="comment">// 计算hash值</span></span><br><span class="line">            h = <span class="built_in">dictHashKey</span>(d, de-&gt;key) &amp; <span class="built_in">DICTHT_SIZE_MASK</span>(d-&gt;ht_size_exp[<span class="number">1</span>]);</span><br><span class="line">            de-&gt;next = d-&gt;ht_table[<span class="number">1</span>][h];</span><br><span class="line">            d-&gt;ht_table[<span class="number">1</span>][h] = de;</span><br><span class="line">            d-&gt;ht_used[<span class="number">0</span>]--;</span><br><span class="line">            d-&gt;ht_used[<span class="number">1</span>]++;</span><br><span class="line">            <span class="comment">// de指向下一个</span></span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把ht【0】置空</span></span><br><span class="line">        d-&gt;ht_table[<span class="number">0</span>][d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht_used[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// chek ht,并释放，ht第一个元素为空，则把 ht[0] = ht[1],这个时候ht[1]为空，ht[0]为整体rehash后的值</span></span><br><span class="line">        <span class="built_in">zfree</span>(d-&gt;ht_table[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">/* Copy the new ht onto the old one */</span></span><br><span class="line">        d-&gt;ht_table[<span class="number">0</span>] = d-&gt;ht_table[<span class="number">1</span>];</span><br><span class="line">        d-&gt;ht_used[<span class="number">0</span>] = d-&gt;ht_used[<span class="number">1</span>];</span><br><span class="line">        d-&gt;ht_size_exp[<span class="number">0</span>] = d-&gt;ht_size_exp[<span class="number">1</span>];</span><br><span class="line">        _dictReset(d, <span class="number">1</span>);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="doing…"><a class="header-anchor" href="#doing…">¶</a>doing…</h3>
]]></content>
      <tags>
        <tag>Hash</tag>
        <tag>Redis</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis断电恢复</title>
    <url>/archives/e9e58399.html</url>
    <content><![CDATA[<p>继<a href="https://blog.imrcrab.com/archives/44b34745.html">→ 30篇 RDB数据保存</a>的问题，接着说断电恢复问题,<br>
先看下主要研究的模块：</p>
<span id="more"></span>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/redis-%E6%96%AD%E7%94%B5%E6%81%A2%E5%A4%8D-1.png" alt=""></p>
<p>跟着源代码，看下大概流程吧：</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/redis%E6%96%AD%E7%94%B5%E6%81%A2%E5%A4%8D-2.png" alt=""></p>
<h2 id="待更"><a class="header-anchor" href="#待更">¶</a>待更</h2>
]]></content>
      <tags>
        <tag>Redis</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>「61」redis hash解读</title>
    <url>/archives/68b4ef49.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p>hash在日常开发中上镜频率还是比较高，例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、java中的Hashmap...</span><br><span class="line">2、Go中的Map...</span><br><span class="line">3、分布式的节点分布...</span><br><span class="line">3、Redis中的hash</span><br></pre></td></tr></table></figure>
<h3 id="好奇点"><a class="header-anchor" href="#好奇点">¶</a>好奇点</h3>
<ul>
<li>Redis的hash结构到底是怎么存的呢？</li>
<li>Redis hash如果做到高效的？</li>
<li>Rehash操作，do what?</li>
<li>“XX” vs ht「hashtable」?Why?</li>
</ul>
<span id="more"></span>
<blockquote>
<p>一个个来看吧：</p>
</blockquote>
<h3 id="hash结构："><a class="header-anchor" href="#hash结构：">¶</a>hash结构：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictht</span> &#123;</span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dict</span> &#123;</span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">int16_t</span> pauserehash; <span class="comment">/* If &gt;0 rehashing is paused (&lt;0 indicates coding error) */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用一张图来描述</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210817_094456.png" alt=""></p>
<h3 id="redis的hash为何高效？"><a class="header-anchor" href="#redis的hash为何高效？">¶</a>redis的hash为何高效？</h3>
<blockquote>
<p>讲道理，不是最高效的，但是适合大众场景。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hset hello w <span class="number">1</span></span><br><span class="line">hset hello wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这2条命令在redis中的存储方式决定了是否高效。</p>
<p>其实Redis提供了<a href="https://github.com/redis/redis/blob/6.2/src/server.h#L701">👉🏻两种存hash编码</a>的结构：</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210817_095231.png" alt=""></p>
<h4 id="类型转换关键点"><a class="header-anchor" href="#类型转换关键点">¶</a>类型转换关键点</h4>
<ul>
<li>hash_max_ziplist_value <a href="https://github.com/redis/redis/blob/6.2/src/t_hash.c#L47">👉🏿 源码判断</a></li>
<li>hash_max_ziplist_entries <a href="https://github.com/redis/redis/blob/6.2/src/t_hash.c#L235">👉🏿 源码判断</a></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">满足以下条件之一的，会将hash的类型从ziplist转换为hashtable。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、当hset的value大小超过设置的「hash_max_ziplist_value」，默认<span class="number">512</span>字节. </span><br><span class="line"><span class="number">2</span>、当key的个数超过指定个数：「hash_max_ziplist_entries」，默认<span class="number">64</span>个.</span><br></pre></td></tr></table></figure>
<h3 id="rehash"><a class="header-anchor" href="#rehash">¶</a>rehash</h3>
<ul>
<li>产生原因：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">负载因子不在一个合理的范围内，简单的说：</span><br><span class="line"><span class="number">1</span>、产生hash冲突</span><br><span class="line"><span class="number">2</span>、单个table节点过长或者分布不均衡。</span><br></pre></td></tr></table></figure>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210817_104655.png" alt=""></p>
<ul>
<li>触发的时机</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、定时任务。</span><br><span class="line"><span class="number">2</span>、对dict的find/<span class="built_in">delete</span>/add等操作时触发。</span><br></pre></td></tr></table></figure>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210817_115402.png" alt=""></p>
<blockquote>
<p>具体rehash过程，后续会讲到。</p>
</blockquote>
<h3 id="ZIPLIST-VS-HASHTABLE"><a class="header-anchor" href="#ZIPLIST-VS-HASHTABLE">¶</a>ZIPLIST VS HASHTABLE</h3>
<p>todo 数据采集中…</p>
<p>理论上分析：</p>
<p>ZIPLIST:   get操作是 O(N)+1<br>
HASHTABLE: get操作是 O(1)</p>
]]></content>
      <tags>
        <tag>Hash</tag>
        <tag>Redis</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>「60」wireshark usage</title>
    <url>/archives/8afe733.html</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="👉🏿wireshark介绍"><a class="header-anchor" href="#👉🏿wireshark介绍">¶</a><a href="https://baike.baidu.com/item/Wireshark/10876564">👉🏿wireshark介绍</a></h2>
<h2 id="Modules"><a class="header-anchor" href="#Modules">¶</a>Modules</h2>
<h3 id="👉👉HTTP"><a class="header-anchor" href="#👉👉HTTP">¶</a><a href="https://www.wireshark.org/docs/dfref/h/http.html">👉👉HTTP</a></h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http.request.method==GET</span><br><span class="line">http.request.method==POST</span><br><span class="line">http.response</span><br><span class="line">http.response.code</span><br><span class="line">http.request.uri</span><br><span class="line">http.request.full_uri</span><br></pre></td></tr></table></figure>
<h3 id="👉👉IP"><a class="header-anchor" href="#👉👉IP">¶</a><a href="https://www.wireshark.org/docs/dfref/i/ip.html">👉👉IP</a></h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip.addr</span><br><span class="line">ip.host</span><br><span class="line">ip.proto</span><br><span class="line">ip.version</span><br><span class="line">ip.ttl</span><br></pre></td></tr></table></figure>
<h3 id="👉👉TCP"><a class="header-anchor" href="#👉👉TCP">¶</a><a href="https://www.wireshark.org/docs/dfref/t/tcp.html">👉👉TCP</a></h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp.dstport</span><br><span class="line">tcp.port</span><br><span class="line">tcp.stream</span><br><span class="line">tls.alert_message</span><br><span class="line">tls.compress_certificate.algorithm</span><br></pre></td></tr></table></figure>
<h3 id="👉👉TLS"><a class="header-anchor" href="#👉👉TLS">¶</a><a href="https://www.wireshark.org/docs/dfref/t/tls.html">👉👉TLS</a></h3>
<ul>
<li>
<p><a href="https://datatracker.ietf.org/doc/html/rfc5246#appendix-A.3">👉🏻👉🏻tls.alert_message</a></p>
</li>
<li>
<p><a href="https://datatracker.ietf.org/doc/html/rfc5246#section-7.4.1.4.1">👉🏻👉🏻tls.compress_certificate.algorithm</a></p>
</li>
<li>
<p><a href="https://tlsfingerprint.io/top/versions">👉🏿👉🏿tls.handshake.version</a></p>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210720_052921.png" alt=""></p>
<h3 id="👉👉JSON"><a class="header-anchor" href="#👉👉JSON">¶</a><a href="https://www.wireshark.org/docs/dfref/j/json.html">👉👉JSON</a></h3>
<blockquote>
<p>当Content-Type: application/json  时候可以查询相应的key或者value</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">json.key contains &quot;xxxx&quot;</span><br><span class="line">json.value.string contains &quot;xxxxxxxxxxxxxx&quot;</span><br></pre></td></tr></table></figure>
<h2 id="Scenes"><a class="header-anchor" href="#Scenes">¶</a>Scenes</h2>
<h3 id="抓取GET-POST请求"><a class="header-anchor" href="#抓取GET-POST请求">¶</a>抓取GET/POST请求</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get:</span><br><span class="line">tcpdump -s 0 -A -vv &#x27;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420&#x27;</span><br><span class="line"></span><br><span class="line">Post:</span><br><span class="line">tcpdump -s 0 -A -vv &#x27;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x504f5354&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="HTTP请求提取"><a class="header-anchor" href="#HTTP请求提取">¶</a>HTTP请求提取</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、Host/Get/Post提取：</span><br><span class="line">tcpdump -s 0 -v -n -l | grep -E &quot;POST /|GET /|Host:&quot;</span><br><span class="line"></span><br><span class="line">2、Cookie提取</span><br><span class="line">tcpdump -nn -A -s0 -l | grep -E &#x27;Set-Cookie|Host:|Cookie:&#x27;</span><br><span class="line"></span><br><span class="line">3、User-Agent提取</span><br><span class="line">tcpdump -nn -A -s1500 -l | grep &quot;User-Agent:&quot;</span><br></pre></td></tr></table></figure>
<h3 id="pcap文件分割"><a class="header-anchor" href="#pcap文件分割">¶</a>pcap文件分割</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump  -w /tmp/capture-%H.pcap -G 3600 -C 100</span><br></pre></td></tr></table></figure>
<h2 id="抓取k8s-kubernetes-pod-数据包"><a class="header-anchor" href="#抓取k8s-kubernetes-pod-数据包">¶</a>抓取k8s/kubernetes pod 数据包</h2>
<blockquote>
<p>./sniff ns-xxx pod-name-xxxxxxxxxxxx -n -s0</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">set -euxo pipefail</span><br><span class="line"></span><br><span class="line">NAMESPACE=$&#123;1&#125;; shift</span><br><span class="line">POD=$&#123;1&#125;; shift</span><br><span class="line"></span><br><span class="line">eval &quot;$(kubectl get pod \</span><br><span class="line">    --namespace &quot;$&#123;NAMESPACE&#125;&quot; \</span><br><span class="line">    &quot;$&#123;POD&#125;&quot; \</span><br><span class="line">    --output=jsonpath=&quot;&#123;.status.containerStatuses[0].containerID&#125;&#123;\&quot;\\000\&quot;&#125;&#123;.status.hostIP&#125;&quot; \</span><br><span class="line">    | xargs -0 bash -c &#x27;printf &quot;$&#123;@&#125;&quot;&#x27; -- &#x27;CONTAINER_ID=%q\nHOST_IP=%q&#x27;)&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [[ $&#123;CONTAINER_ID&#125; == &#x27;docker://&#x27;* ]]; then</span><br><span class="line">    CONTAINER_ENGINE=docker</span><br><span class="line">    CONTAINER_ID=$&#123;CONTAINER_ID#&#x27;docker://&#x27;&#125;</span><br><span class="line">elif [[ $&#123;CONTAINER_ID&#125; == &#x27;containerd://&#x27;* ]]; then</span><br><span class="line">    CONTAINER_ENGINE=containerd</span><br><span class="line">    CONTAINER_ID=$&#123;CONTAINER_ID#&#x27;containerd://&#x27;&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ -z $(ip address | sed -n &quot;s/inet $&#123;HOST_IP&#125;\//found/p&quot;) ]]; then</span><br><span class="line">    SHELL_COMMAND=&#x27;eval ssh &quot;$&#123;HOST_IP&#125;&quot; bash -euxo pipefail -&#x27;</span><br><span class="line">else</span><br><span class="line">    SHELL_COMMAND=&#x27;source /dev/stdin&#x27;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;SHELL_COMMAND&#125; &lt;&lt;<span class="string">EOF</span></span></span><br><span class="line">PATH=\$&#123;PATH&#125;:/usr/local/bin</span><br><span class="line"></span><br><span class="line">if [[ $&#123;CONTAINER_ENGINE@Q&#125; == docker ]]; then</span><br><span class="line">    PID=\$(docker inspect --format &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; $&#123;CONTAINER_ID@Q&#125;)</span><br><span class="line">elif [[ $&#123;CONTAINER_ENGINE@Q&#125; == containerd ]]; then</span><br><span class="line">    PID=\$(crictl inspect --output go-template --template &#x27;&#123;&#123;.info.pid&#125;&#125;&#x27; $&#123;CONTAINER_ID@Q&#125;)</span><br><span class="line">fi</span><br><span class="line">IF_NO=\$(&lt;&quot;/proc/\$&#123;PID&#125;/root/sys/class/net/eth0/iflink&quot;)</span><br><span class="line">IF=\$(ip link | sed -n &quot;s/^\$&#123;IF_NO&#125;: \([^@]\+\).*$/\1/p&quot;)</span><br><span class="line"></span><br><span class="line">tcpdump -i &quot;\$&#123;IF&#125;&quot; $&#123;@@Q&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">设置 Bash 的一些选项，包括 -e（如果命令返回非零状态，则立即退出）、-u（如果尝试使用未定义的变量，则退出）、-x（在执行命令之前打印每个命令）和 -o pipefail（如果管道中的任何命令失败，则退出）。</span><br><span class="line"></span><br><span class="line">从脚本的第一个参数中获取 Kubernetes 命名空间，并从第二个参数中获取 Pod 的名称。</span><br><span class="line"></span><br><span class="line">使用 kubectl 命令获取 Pod 的容器 ID 和主机 IP 地址，并将它们存储在变量 CONTAINER_ID 和 HOST_IP 中。</span><br><span class="line"></span><br><span class="line">根据容器 ID 的前缀确定容器运行时（Docker 还是 containerd）。</span><br><span class="line"></span><br><span class="line">检查主机 IP 地址是否在当前主机上，并设置一个 SHELL_COMMAND 变量，该变量包含一个 ssh 命令，该命令将连接到主机 IP 地址并在远程主机上运行 Bash shell。</span><br><span class="line"></span><br><span class="line">在 HEREDOC 中运行 Bash 命令，该命令使用 tcpdump 命令捕获网络流量。该命令首先获取容器的 PID，然后使用该 PID 获取容器的网络接口名称。最后，它使用 tcpdump 命令捕获指定接口的网络流量。</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">bash -euxo pipefail - 是一个命令，它启动一个新的 Bash shell 并设置一些选项。具体来说，它设置了以下选项：</span><br><span class="line"></span><br><span class="line">-e：如果任何命令返回非零状态，则立即退出 shell。</span><br><span class="line">-u：如果尝试使用未定义的变量，则退出 shell。</span><br><span class="line">-x：在执行命令之前打印每个命令。</span><br><span class="line">-o pipefail：如果管道中的任何命令失败，则退出 shell。</span><br><span class="line">这些选项可以帮助在脚本中捕获错误并提高调试能力。- 表示从标准输入读取命令，这意味着在这个例子中，$&#123;SHELL_COMMAND&#125; 变量中的命令将作为标准输入传递给新的 Bash shell。</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">$&#123;CONTAINER_ID@Q&#125; 是 Bash shell 中的一种参数扩展语法，用于将变量 CONTAINER_ID 的值转义为适合在双引号中使用的格式。在这种情况下，@Q 表示将变量值转义为单引号括起来的字符串，这样可以确保变量值中的任何特殊字符都不会被解释为 shell 元字符。例如，如果 CONTAINER_ID 的值为 docker://my-container，$&#123;CONTAINER_ID@Q&#125; 将返回 &#x27;docker://my-container&#x27;。这样可以确保在使用变量值时不会出现意外的行为。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="“TCP-segment-of-reassembled-PDU”"><a class="header-anchor" href="#“TCP-segment-of-reassembled-PDU”">¶</a>“TCP segment of reassembled PDU”</h2>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210720_040500.png" alt=""></p>
<blockquote>
<p>关于这个网上有很多种解释，可以自行百度参考<a href="https://www.google.com.hk/search?newwindow=1&amp;lei=oHX2YOmaPMiFr7wPj76ViAg&amp;q=tcp%20segment%20of%20a%20reassembled%20pdu%E5%8E%9F%E5%9B%A0&amp;ved=2ahUKEwjp6v7iivHxAhXIwosBHQ9fBYEQsKwBKAF6BAgwEAI&amp;biw=2560&amp;bih=1253">👉🏿👉🏿👉🏿TCP segment of reassembled PDU</a></p>
</blockquote>
<blockquote>
<p>关于这个问题，抓包看看，ack是一样的，当前的next sequence number是下一个的sequence number.<br>
<img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210720_041222.png" alt=""></p>
</blockquote>
<h2 id="文档搜索"><a class="header-anchor" href="#文档搜索">¶</a>文档搜索</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.wireshark.org/docs/dfref/i/ip.html</span><br><span class="line"></span><br><span class="line">https://www.wireshark.org/docs/dfref/首字母/模块名称.html</span><br></pre></td></tr></table></figure>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/2023/2023-03-21-22-24-33-ba663d3325437c7db78b614a272736a1-202303212224542-bfcff9.png" alt=""></p>
<h2 id="Reference"><a class="header-anchor" href="#Reference">¶</a>Reference</h2>
<ul>
<li>
<p><a href="https://www.wireshark.org/">☞ wireshark官网</a></p>
</li>
<li>
<p><a href="https://datatracker.ietf.org/doc/html/rfc5246#section-7.3">→→datatracker</a></p>
</li>
<li>
<p><a href="https://techcommunity.microsoft.com/t5/iis-support-blog/ssl-tls-alert-protocol-and-the-alert-codes/ba-p/377132">→→micrsoft</a></p>
</li>
<li>
<p><a href="https://tlsfingerprint.io/top/versions">→→tls finger print</a></p>
</li>
<li>
<p><a href="https://tlsfingerprint.io/top/versions">→→tls version</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers">→→List of IP protocol numbers</a></p>
</li>
<li>
<p><a href="https://www.wireshark.org/docs/dfref/t/tls.html">👉🏻 module: tls</a></p>
</li>
<li>
<p><a href="https://www.wireshark.org/docs/dfref/i/ip.html">👉🏻 module: IP</a></p>
</li>
<li>
<p><a href="https://www.wireshark.org/docs/dfref/h/http.html">👉🏻 module: HTTP</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/v1vvwv/p/Wireshark-filtering-rules.html">☛ wireshak过滤规则</a></p>
</li>
<li>
<p><a href="https://www.jianshu.com/p/d4d7ad6cc95f">☛ wireshark基本用法及过滤规则</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>「57」算法(二) → 链表</title>
    <url>/archives/afe7994b.html</url>
    <content><![CDATA[<ul>
<li>反转单向链表
<ul>
<li>反转单向链表的[N,M]</li>
</ul>
</li>
<li>删除链表重复元素</li>
<li>合并两个有序链表</li>
<li>旋转链表</li>
<li>排序链表</li>
<li>两数相加<br>
…</li>
</ul>
<span id="more"></span>
<h3 id="反转单向链表"><a class="header-anchor" href="#反转单向链表">¶</a>反转单向链表</h3>
<h4 id="要求"><a class="header-anchor" href="#要求">¶</a>要求</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</span><br><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="思路分析："><a class="header-anchor" href="#思路分析：">¶</a>思路分析：</h4>
<h5 id="变量暂存替换法"><a class="header-anchor" href="#变量暂存替换法">¶</a>变量暂存替换法</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210528_031731.png" alt=""></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReserveList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> || head.next == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> head</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> pre *ListNode</span><br><span class="line">	<span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 简化版：</span></span><br><span class="line">        <span class="comment">// head, head.next, pre = head.next, pre, head</span></span><br><span class="line">		nextNode := head.next</span><br><span class="line">		head.next = pre</span><br><span class="line">		pre = head</span><br><span class="line">		head = nextNode</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="双头指针法"><a class="header-anchor" href="#双头指针法">¶</a>双头指针法</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210528_031843.png" alt=""></p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210528_031913.png" alt=""></p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210528_031933.png" alt=""></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReserveList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> || head.next == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> head</span><br><span class="line">	&#125;</span><br><span class="line">	cur := head</span><br><span class="line">	<span class="keyword">for</span> head.next != <span class="literal">nil</span> &#123;</span><br><span class="line">		tmp := head.next.next</span><br><span class="line">		head.next.next = cur</span><br><span class="line">		cur = head.next</span><br><span class="line">		head.next = tmp</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转单向链表前N个"><a class="header-anchor" href="#反转单向链表前N个">¶</a>反转单向链表前N个</h3>
<h4 id="要求："><a class="header-anchor" href="#要求：">¶</a>要求：</h4>
<h4 id="思路："><a class="header-anchor" href="#思路：">¶</a>思路：</h4>
<h4 id="coding"><a class="header-anchor" href="#coding">¶</a>coding:</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nochange *ListNode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReserveListN</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">		nochange = head.next</span><br><span class="line">		<span class="keyword">return</span> head</span><br><span class="line">	&#125;</span><br><span class="line">	last := ReserveListN(head.next, n<span class="number">-1</span>)</span><br><span class="line">	head.next.next = head</span><br><span class="line">	head.next = nochange</span><br><span class="line">	<span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转单向链表N-M之间的"><a class="header-anchor" href="#反转单向链表N-M之间的">¶</a>反转单向链表N~M之间的</h3>
<h4 id="要求：-v2"><a class="header-anchor" href="#要求：-v2">¶</a>要求：</h4>
<h4 id="思路：-v2"><a class="header-anchor" href="#思路：-v2">¶</a>思路：</h4>
<h4 id="coding-v2"><a class="header-anchor" href="#coding-v2">¶</a>coding:</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//翻转[N,M]范围内的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReserveListNM</span><span class="params">(head *ListNode, n, m <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ReserveListN(head, m)</span><br><span class="line">	&#125;</span><br><span class="line">	head.next = ReserveListNM(head.next, n<span class="number">-1</span>, m<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="待更新…"><a class="header-anchor" href="#待更新…">¶</a>待更新…</h3>
]]></content>
  </entry>
  <entry>
    <title>「56」List Stack Tree</title>
    <url>/archives/b0be3190.html</url>
    <content><![CDATA[<p>算法篇👉🏻[二]</p>
<h3 id="LinkedList"><a class="header-anchor" href="#LinkedList">¶</a>LinkedList</h3>
<h4 id="定义："><a class="header-anchor" href="#定义：">¶</a>定义：</h4>
<p>是链表的一种，其特点是链表的连接方向是单向的，对链表的访问要从头开始，依次往下。</p>
<h4 id="相关题目"><a class="header-anchor" href="#相关题目">¶</a>相关题目</h4>
<ul>
<li>反转单向链表
<ul>
<li>反转单向链表的[N,M]</li>
</ul>
</li>
<li>删除链表重复元素</li>
<li>合并两个有序链表</li>
<li>旋转链表</li>
<li>排序链表</li>
<li>两数相加</li>
</ul>
<h3 id="待续…"><a class="header-anchor" href="#待续…">¶</a>待续…</h3>
]]></content>
      <tags>
        <tag>Day</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>「55」Go 1.18 pre</title>
    <url>/archives/517e6fa6.html</url>
    <content><![CDATA[<p>最近看到1.18已经提上日程了，虽然很遥远，<br>
但还是需要关注下改善点和新特性。</p>
<span id="more"></span>
<h3 id="改善点："><a class="header-anchor" href="#改善点：">¶</a>改善点：</h3>
<h4 id="👉🏻-runtime-helloworld-net-http-asks-700MB-VSS-on-mips32"><a class="header-anchor" href="#👉🏻-runtime-helloworld-net-http-asks-700MB-VSS-on-mips32">¶</a><a href="https://github.com/golang/go/issues/43699">👉🏻 runtime: helloworld net/http asks 700MB VSS on mips32</a></h4>
<h5 id="简述："><a class="header-anchor" href="#简述：">¶</a>简述：</h5>
<blockquote>
<p>一个helloworld net程序跑起来后 VSS 占用过高问题</p>
</blockquote>
<h5 id="Depends-on"><a class="header-anchor" href="#Depends-on">¶</a>Depends on:</h5>
<p><a href="https://github.com/golang/go/issues/44167">proposal: runtime: GC pacer redesign</a></p>
<h4 id="👉🏻-runtime-10ms-26ms-latency-from-GC-in-go1-14rc1-possibly-due-to-‘GC-idle-’-work"><a class="header-anchor" href="#👉🏻-runtime-10ms-26ms-latency-from-GC-in-go1-14rc1-possibly-due-to-‘GC-idle-’-work">¶</a><a href="https://github.com/golang/go/issues/37116">👉🏻 runtime: 10ms-26ms latency from GC in go1.14rc1, possibly due to ‘GC (idle)’ work</a></h4>
<h5 id="简述：-v2"><a class="header-anchor" href="#简述：-v2">¶</a>简述：</h5>
<blockquote>
<p>gc idle空闲时间过长问题</p>
</blockquote>
<h5 id="解决办法："><a class="header-anchor" href="#解决办法：">¶</a>解决办法：</h5>
<p><a href="https://github.com/golang/go/issues/44163">👉🏿 runtime: remove idle GC workers</a><br>
<a href="https://github.com/golang/go/issues/44167">👉🏿 proposal: runtime: GC pacer redesign </a></p>
<h3 id="proposal"><a class="header-anchor" href="#proposal">¶</a>proposal</h3>
<h4 id="👉🏻-GC-Redesign"><a class="header-anchor" href="#👉🏻-GC-Redesign">¶</a><a href="https://github.com/golang/proposal/blob/329650d4723a558c2b76b81b4995fc5c267e6bc1/design/44167-gc-pacer-redesign.md">👉🏻 GC Redesign</a></h4>
<h4 id="👉-runtime-pprof-NewCPUProfile-cpuProfile-Start-to-allow-profile-configuration"><a class="header-anchor" href="#👉-runtime-pprof-NewCPUProfile-cpuProfile-Start-to-allow-profile-configuration">¶</a><a href="https://github.com/golang/go/issues/42502">👉 runtime/pprof: NewCPUProfile + cpuProfile.Start to allow profile configuration</a></h4>
<h3 id="Deprecated"><a class="header-anchor" href="#Deprecated">¶</a>Deprecated</h3>
<h4 id="👉🏿-runtime-deprecate-SetCPUProfileRate-and-replace-body-with-panic"><a class="header-anchor" href="#👉🏿-runtime-deprecate-SetCPUProfileRate-and-replace-body-with-panic">¶</a><a href="https://github.com/golang/go/issues/40094">👉🏿 runtime: deprecate SetCPUProfileRate and replace body with panic</a></h4>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go源码</tag>
        <tag>Day</tag>
        <tag>v1.18</tag>
      </tags>
  </entry>
  <entry>
    <title>「54」GoSched函数</title>
    <url>/archives/10a41c81.html</url>
    <content><![CDATA[<p>GoSched 干嘛的？ 看看官方说明：</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210526_051405.png" alt=""></p>
<blockquote>
<p>两点：</p>
</blockquote>
<ul>
<li>让出processor</li>
<li>可以自动恢复g，执行中的任务</li>
</ul>
<span id="more"></span>
<h3 id="👉🏻-goschedImpl"><a class="header-anchor" href="#👉🏻-goschedImpl">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/proc.go#L2746">👉🏻 goschedImpl</a></h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedImpl</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取g状态</span></span><br><span class="line">	status := readgstatus(gp)</span><br><span class="line">	<span class="keyword">if</span> status&amp;^_Gscan != _Grunning &#123;</span><br><span class="line">        <span class="comment">// 非运行中就throw</span></span><br><span class="line">		dumpgstatus(gp)</span><br><span class="line">		throw(<span class="string">&quot;bad g status&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//改变G状态</span></span><br><span class="line">	casgstatus(gp, _Grunning, _Grunnable)</span><br><span class="line">    <span class="comment">//重置M和G的状态</span></span><br><span class="line">	dropg()</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 将G重新放回队列中</span></span><br><span class="line">	globrunqput(gp)</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常调度</span></span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个个看看，GMP到底如果配合调度的?</p>
</blockquote>
<h4 id="👉🏿-readgstatus"><a class="header-anchor" href="#👉🏿-readgstatus">¶</a>👉🏿 readgstatus</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// All reads and writes of g&#x27;s status go through readgstatus, casgstatus</span></span><br><span class="line"><span class="comment">// castogscanstatus, casfrom_Gscanstatus.</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readgstatus</span><span class="params">(gp *g)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> atomic.Load(&amp;gp.atomicstatus)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>atomicstatus变量的作用：</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210526_052742.png" alt=""></p>
<h4 id="👉🏿-casgstatus"><a class="header-anchor" href="#👉🏿-casgstatus">¶</a>👉🏿 casgstatus</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If asked to move to or from a Gscanstatus this will throw. Use the castogscanstatus</span></span><br><span class="line"><span class="comment">// and casfrom_Gscanstatus instead.</span></span><br><span class="line"><span class="comment">// casgstatus will loop if the g-&gt;atomicstatus is in a Gscan status until the routine that</span></span><br><span class="line"><span class="comment">// put it in the Gscan state is finished.</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">casgstatus</span><span class="params">(gp *g, oldval, newval <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (oldval&amp;_Gscan != <span class="number">0</span>) || (newval&amp;_Gscan != <span class="number">0</span>) || oldval == newval &#123;</span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;runtime: casgstatus: oldval=&quot;</span>, hex(oldval), <span class="string">&quot; newval=&quot;</span>, hex(newval), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">			throw(<span class="string">&quot;casgstatus: bad incoming values&quot;</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// See https://golang.org/cl/21503 for justification of the yield delay.</span></span><br><span class="line">	<span class="keyword">const</span> yieldDelay = <span class="number">5</span> * <span class="number">1000</span></span><br><span class="line">	<span class="keyword">var</span> nextYield <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// loop if gp-&gt;atomicstatus is in a scan state giving</span></span><br><span class="line">	<span class="comment">// GC time to finish and change the state to oldval.</span></span><br><span class="line">	<span class="comment">// 等待GC完成后变成_Grunning，然后再改变值，变为_Grunnable</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; !atomic.Cas(&amp;gp.atomicstatus, oldval, newval); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> oldval == _Gwaiting &amp;&amp; gp.atomicstatus == _Grunnable &#123;</span><br><span class="line">			throw(<span class="string">&quot;casgstatus: waiting for Gwaiting but is Grunnable&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">			nextYield = nanotime() + yieldDelay</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> nanotime() &lt; nextYield &#123;</span><br><span class="line">			<span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">10</span> &amp;&amp; gp.atomicstatus != oldval; x++ &#123;</span><br><span class="line">				procyield(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			osyield()</span><br><span class="line">			nextYield = nanotime() + yieldDelay/<span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="👉🏿-dropg"><a class="header-anchor" href="#👉🏿-dropg">¶</a>👉🏿 dropg</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dropg removes the association between m and the current goroutine m-&gt;curg (gp for short).</span></span><br><span class="line"><span class="comment">// Typically a caller sets gp&#x27;s status away from Grunning and then</span></span><br><span class="line"><span class="comment">// immediately calls dropg to finish the job. The caller is also responsible</span></span><br><span class="line"><span class="comment">// for arranging that gp will be restarted using ready at an</span></span><br><span class="line"><span class="comment">// appropriate time. After calling dropg and arranging for gp to be</span></span><br><span class="line"><span class="comment">// readied later, the caller can do other work but eventually should</span></span><br><span class="line"><span class="comment">// call schedule to restart the scheduling of goroutines on this m.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dropg</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解绑M</span></span><br><span class="line">	setMNoWB(&amp;_g_.m.curg.m, <span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// 解绑G</span></span><br><span class="line">	setGNoWB(&amp;_g_.m.curg, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="👉🏿-globrunqput"><a class="header-anchor" href="#👉🏿-globrunqput">¶</a>👉🏿 globrunqput</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Put gp on the global runnable queue.</span></span><br><span class="line"><span class="comment">// Sched must be locked.</span></span><br><span class="line"><span class="comment">// May run during STW, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">globrunqput</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	<span class="comment">//将G放回全局队列中</span></span><br><span class="line">	sched.runq.pushBack(gp)</span><br><span class="line">	sched.runqsize++</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="👉🏿-schedule"><a class="header-anchor" href="#👉🏿-schedule">¶</a>👉🏿 schedule</h4>
<h5 id="作用："><a class="header-anchor" href="#作用：">¶</a>作用：</h5>
<blockquote>
<p>find a runnable goroutine and execute it.</p>
</blockquote>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go源码</tag>
        <tag>Day</tag>
      </tags>
  </entry>
  <entry>
    <title>「53」dfs bfs 01背包</title>
    <url>/archives/517092f1.html</url>
    <content><![CDATA[<p>算法篇👉🏻[一]</p>
<span id="more"></span>
<h3 id="DFS问题"><a class="header-anchor" href="#DFS问题">¶</a>DFS问题</h3>
<h4 id="无重复数组总和问题👉🏿-39"><a class="header-anchor" href="#无重复数组总和问题👉🏿-39">¶</a>无重复数组总和问题<a href="https://leetcode-cn.com/problems/combination-sum/">👉🏿#39</a></h4>
<h5 id="👉🏿问题描述：-39"><a class="header-anchor" href="#👉🏿问题描述：-39">¶</a><a href="https://leetcode-cn.com/problems/combination-sum/">👉🏿问题描述：#39</a></h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line"></span><br><span class="line">candidates 中的数字可以无限制重复被选取。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">所有数字（包括 target）都是正整数。</span><br><span class="line">解集不能包含重复的组合。 </span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span>,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], target = <span class="number">8</span>,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h5 id="解决思路"><a class="header-anchor" href="#解决思路">¶</a>解决思路</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210520_113008.png" alt=""></p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210520_113224.png" alt=""></p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210520_113257.png" alt=""></p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210520_113320.png" alt=""></p>
<h5 id="coding："><a class="header-anchor" href="#coding：">¶</a>coding：</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">	combineDFS(n, <span class="number">16</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res [][]<span class="type">int</span> = <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combineDFS</span><span class="params">(num []<span class="type">int</span>, target <span class="type">int</span>)</span></span> (result [][]<span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(num) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dfs(target, <span class="number">0</span>, []<span class="type">int</span>&#123;&#125;, num)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(target <span class="type">int</span>, index <span class="type">int</span>, pre []<span class="type">int</span>, num []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">		pp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(pre))</span><br><span class="line">		<span class="built_in">copy</span>(pp, pre)</span><br><span class="line">		res = <span class="built_in">append</span>(res, pp)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := index; i &lt; <span class="built_in">len</span>(num); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> num[i] &gt; target &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pre = <span class="built_in">append</span>(pre, num[i])</span><br><span class="line">    <span class="comment">// i+1 则跳过重复的元素使用的情况</span></span><br><span class="line">		<span class="comment">//dfs(target-num[i], i+1, pre, num)</span></span><br><span class="line">		dfs(target-num[i], i, pre, num)</span><br><span class="line">		pre = pre[:<span class="built_in">len</span>(pre)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="待续…"><a class="header-anchor" href="#待续…">¶</a>待续…</h3>
]]></content>
      <tags>
        <tag>Day</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>「52」Mysql Top N问题</title>
    <url>/archives/2dfee217.html</url>
    <content><![CDATA[<h3 id="问题是这样的："><a class="header-anchor" href="#问题是这样的：">¶</a>问题是这样的：</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210519_125155.png" alt=""></p>
<blockquote>
<p>求不同的age分组，按照createTime正序「从小到大」排序的前N个。</p>
</blockquote>
<span id="more"></span>
<h3 id="解决办法："><a class="header-anchor" href="#解决办法：">¶</a>解决办法：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">        t1.*</span><br><span class="line">    FROM</span><br><span class="line">    table_a t1</span><br><span class="line">    where (SELECT count(*) + <span class="number">1</span> FROM table_a t2 WHERE t2.age = t1.age AND t2.create_time &gt; t1.create_time ) &lt;=<span class="number">1</span> order by create_time desc</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="结果："><a class="header-anchor" href="#结果：">¶</a>结果：</h4>
<blockquote>
<p>按照age分组，createTime正序排序的Top 2数据</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210519_125510.png" alt=""></p>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>Day</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>「51」getg()函数实现源码</title>
    <url>/archives/82f0ffe7.html</url>
    <content><![CDATA[<p>在学习<a href="https://blog.imrcrab.com/archives/a90dcb34.html#call-schedinit%E5%87%BD%E6%95%B0">👉🏾schedinit()函数</a>过程中发现有这个么函数：</p>
<blockquote>
<p>getg()</p>
</blockquote>
<p>多处都有使用的情况，但是问题来了，到底是如何实现的，如何获取的G呢？</p>
<span id="more"></span>
<h3 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h3>
<p>源码中的定义：<a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/stubs.go#L18">🙌🏽  func getg() *g</a></p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210513_113610.png" alt=""></p>
<h3 id="使用："><a class="header-anchor" href="#使用：">¶</a>使用：</h3>
<p>从上面的结果来看，主要from TLS or 编译器:</p>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/cmd/compile/internal/amd64/ssa.go#L895">👉🏾1.14呈现：</a></p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210513_114619.png" alt=""></p>
<blockquote>
<p>根据是否使用TLS分两种：</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210513_115015.png" alt=""></p>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>GPM</tag>
        <tag>Go源码</tag>
        <tag>Day</tag>
      </tags>
  </entry>
  <entry>
    <title>「50」Map GC问题</title>
    <url>/archives/af25fb6c.html</url>
    <content><![CDATA[<p>问题的起因:<a href="https://blog.imrcrab.com/archives/2de36dd7.html">「29」map delete Mem不释放问题</a></p>
<p>那么问题来:</p>
<ul>
<li>map内存释放的时机呢？</li>
<li>释放如果map过大，释放内存过程中会不会有GC StopWorld问题?</li>
</ul>
<span id="more"></span>
<h3 id="代码部分："><a class="header-anchor" href="#代码部分：">¶</a>代码部分：</h3>
<h4 id="map的value不包含pointer："><a class="header-anchor" href="#map的value不包含pointer：">¶</a>map的value不包含pointer：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime/trace&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	now:=time.Now().Unix()</span><br><span class="line">	fmt.Println(now)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">		mmp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">		<span class="keyword">for</span> ia := <span class="number">0</span>; ia &lt; <span class="number">100000</span>; ia++ &#123;</span><br><span class="line">			v := ia</span><br><span class="line">			mmp[strconv.Itoa(ia)] = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(time.Now().Unix()-now)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	trace.Start(os.Stderr)</span><br><span class="line">	<span class="keyword">defer</span> trace.Stop()</span><br><span class="line">	AddMap()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="map的value包含pointer："><a class="header-anchor" href="#map的value包含pointer：">¶</a>map的value包含pointer：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime/trace&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	now:=time.Now().Unix()</span><br><span class="line">	fmt.Println(now)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">		mmp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*<span class="type">int</span>)</span><br><span class="line">		<span class="keyword">for</span> ia := <span class="number">0</span>; ia &lt; <span class="number">100000</span>; ia++ &#123;</span><br><span class="line">			v := ia</span><br><span class="line">			mmp[strconv.Itoa(ia)] = &amp;v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(time.Now().Unix()-now)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	trace.Start(os.Stderr)</span><br><span class="line">	<span class="keyword">defer</span> trace.Stop()</span><br><span class="line">	AddMap()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="trace结果："><a class="header-anchor" href="#trace结果：">¶</a>trace结果：</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210512_113756.png" alt=""></p>
<h3 id="初步方案："><a class="header-anchor" href="#初步方案：">¶</a>初步方案：</h3>
<h3 id="Slice替代Map方案："><a class="header-anchor" href="#Slice替代Map方案：">¶</a>Slice替代Map方案：</h3>
<h3 id="Test"><a class="header-anchor" href="#Test">¶</a>Test</h3>
<h3 id="benchmark"><a class="header-anchor" href="#benchmark">¶</a>benchmark</h3>
<h3 id="待更新"><a class="header-anchor" href="#待更新">¶</a>待更新</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go源码</tag>
        <tag>Day</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>「48」GMP main之G&amp;M创建</title>
    <url>/archives/a90dcb34.html</url>
    <content><![CDATA[<p>前面说了GPM的main函数启动<a href="https://blog.imrcrab.com/archives/66b6223a.html#more">「47」GPM main启动</a>，这次看下这个启动过程中如何创建第一个M和G的操作。</p>
<p>在main函数汇编的入口地方call这么几个函数：</p>
<ul>
<li>args 参数设定</li>
<li>osinit os系统初始化</li>
<li>schedinit 调度初始化</li>
</ul>
<span id="more"></span>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210506_105845.png" alt=""></p>
<h3 id="call-osinit函数"><a class="header-anchor" href="#call-osinit函数">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/os_plan9.go#L291">call osinit函数</a></h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210506_105719.png" alt=""></p>
<blockquote>
<p>getpid()获取当前的proc的id号，赋值给当前g-&gt;m.procid</p>
</blockquote>
<h3 id="call-schedinit函数"><a class="header-anchor" href="#call-schedinit函数">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/proc.go#L532">call schedinit函数</a></h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// The bootstrap sequence is:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	call osinit</span></span><br><span class="line"><span class="comment">//	call schedinit</span></span><br><span class="line"><span class="comment">//	make &amp; queue new G</span></span><br><span class="line"><span class="comment">//	call runtime·mstart</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The new G calls runtime·main.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一大堆lock的初始化</span></span><br><span class="line">	lockInit(&amp;sched.lock, lockRankSched)</span><br><span class="line">	lockInit(&amp;sched.sysmonlock, lockRankSysmon)</span><br><span class="line">	lockInit(&amp;sched.deferlock, lockRankDefer)</span><br><span class="line">	lockInit(&amp;sched.sudoglock, lockRankSudog)</span><br><span class="line">	lockInit(&amp;deadlock, lockRankDeadlock)</span><br><span class="line">	lockInit(&amp;paniclk, lockRankPanic)</span><br><span class="line">	lockInit(&amp;allglock, lockRankAllg)</span><br><span class="line">	lockInit(&amp;allpLock, lockRankAllp)</span><br><span class="line">	lockInit(&amp;reflectOffs.lock, lockRankReflectOffs)</span><br><span class="line">	lockInit(&amp;finlock, lockRankFin)</span><br><span class="line">	lockInit(&amp;trace.bufLock, lockRankTraceBuf)</span><br><span class="line">	lockInit(&amp;trace.stringsLock, lockRankTraceStrings)</span><br><span class="line">	lockInit(&amp;trace.lock, lockRankTrace)</span><br><span class="line">	lockInit(&amp;cpuprof.lock, lockRankCpuprof)</span><br><span class="line">	lockInit(&amp;trace.stackTab.lock, lockRankTraceStackTab)</span><br><span class="line">	<span class="comment">// Enforce that this lock is always a leaf lock.</span></span><br><span class="line">	<span class="comment">// All of this lock&#x27;s critical sections should be</span></span><br><span class="line">	<span class="comment">// extremely short.</span></span><br><span class="line">	lockInit(&amp;memstats.heapStats.noPLock, lockRankLeafRank)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// raceinit must be the first call to race detector.</span></span><br><span class="line">	<span class="comment">// In particular, it must be done before mallocinit below calls racemapshadow.</span></span><br><span class="line">    <span class="comment">// 获取当前的g</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		_g_.racectx, raceprocctx0 = raceinit()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大的m为1w个</span></span><br><span class="line">	sched.maxmcount = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The world starts stopped.</span></span><br><span class="line">	worldStopped()</span><br><span class="line"></span><br><span class="line">	moduledataverify()</span><br><span class="line">    <span class="comment">// stack初始化</span></span><br><span class="line">	stackinit()</span><br><span class="line">    <span class="comment">// 内存分配器初始化</span></span><br><span class="line">	mallocinit()</span><br><span class="line">    <span class="comment">// 随机数初始化</span></span><br><span class="line">	fastrandinit() <span class="comment">// must run before mcommoninit</span></span><br><span class="line">    <span class="comment">// id预分配</span></span><br><span class="line">	mcommoninit(_g_.m, <span class="number">-1</span>)</span><br><span class="line">	cpuinit()       <span class="comment">// must run before alginit</span></span><br><span class="line">    <span class="comment">// 内存堆齐初始化</span></span><br><span class="line">	alginit()       <span class="comment">// maps must not be used before this call</span></span><br><span class="line">	modulesinit()   <span class="comment">// provides activeModules</span></span><br><span class="line">	typelinksinit() <span class="comment">// uses maps, activeModules</span></span><br><span class="line">	itabsinit()     <span class="comment">// uses activeModules</span></span><br><span class="line"></span><br><span class="line">	sigsave(&amp;_g_.m.sigmask)</span><br><span class="line">	initSigmask = _g_.m.sigmask</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> offset := unsafe.Offsetof(sched.timeToRun); offset%<span class="number">8</span> != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(offset)</span><br><span class="line">		throw(<span class="string">&quot;sched.timeToRun not aligned to 8 bytes&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	goargs()</span><br><span class="line">	goenvs()</span><br><span class="line">	parsedebugvars()</span><br><span class="line">	gcinit()</span><br><span class="line"></span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	sched.lastpoll = <span class="type">uint64</span>(nanotime())</span><br><span class="line">	procs := ncpu</span><br><span class="line">	<span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">&quot;GOMAXPROCS&quot;</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		procs = n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;unknown runnable goroutine during bootstrap&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// World is effectively started now, as P&#x27;s can run.</span></span><br><span class="line">	worldStarted()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// For cgocheck &gt; 1, we turn on the write barrier at all times</span></span><br><span class="line">	<span class="comment">// and check all pointer writes. We can&#x27;t do this until after</span></span><br><span class="line">	<span class="comment">// procresize because the write barrier needs a P.</span></span><br><span class="line">	<span class="keyword">if</span> debug.cgocheck &gt; <span class="number">1</span> &#123;</span><br><span class="line">		writeBarrier.cgo = <span class="literal">true</span></span><br><span class="line">		writeBarrier.enabled = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">			p.wbBuf.reset()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> buildVersion == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// Condition should never trigger. This code just serves</span></span><br><span class="line">		<span class="comment">// to ensure runtime·buildVersion is kept in the resulting binary.</span></span><br><span class="line">		buildVersion = <span class="string">&quot;unknown&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(modinfo) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="comment">// Condition should never trigger. This code just serves</span></span><br><span class="line">		<span class="comment">// to ensure runtime·modinfo is kept in the resulting binary.</span></span><br><span class="line">		modinfo = <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="大体流程"><a class="header-anchor" href="#大体流程">¶</a>大体流程</h4>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1、lockinit</span><br><span class="line">2、g:=getg()</span><br><span class="line">3、maxmcount = 10000</span><br><span class="line">4、stackinit</span><br><span class="line">5、mallocinit「内存分配器初始化」</span><br><span class="line">6、随机数</span><br><span class="line">7、mcommon公公部分init</span><br><span class="line">8、cpu和byte等初始化。</span><br><span class="line">9、goenv初始化</span><br><span class="line">10、gcinit()</span><br><span class="line">11、GOMAXPROCS设置</span><br><span class="line">12、cgo等初始化</span><br></pre></td></tr></table></figure>
<h4 id="函数分析"><a class="header-anchor" href="#函数分析">¶</a>函数分析</h4>
<h5 id="schedinit"><a class="header-anchor" href="#schedinit">¶</a>schedinit</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210515_102713.png" alt=""></p>
<h5 id="worldstop"><a class="header-anchor" href="#worldstop">¶</a>worldstop</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210515_102811.png" alt=""></p>
<h5 id="stackinit"><a class="header-anchor" href="#stackinit">¶</a>stackinit</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210515_102849.png" alt=""></p>
<h5 id="sigsave"><a class="header-anchor" href="#sigsave">¶</a>sigsave</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210515_102930.png" alt=""></p>
<h3 id="关于gomaxprocs最大值"><a class="header-anchor" href="#关于gomaxprocs最大值">¶</a>关于gomaxprocs最大值</h3>
<h4 id="Go-1-8及以前"><a class="header-anchor" href="#Go-1-8及以前">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.8/src/runtime/runtime2.go#L533">Go 1.8及以前</a></h4>
<blockquote>
<p>最大为256</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/ico/clipboard_20210507_102912.png" alt=""></p>
<h4 id="Go-1-9中"><a class="header-anchor" href="#Go-1-9中">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.9/src/runtime/runtime2.go#L523">Go 1.9中</a></h4>
<blockquote>
<p>最大为1024</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210506_115200.png" alt=""></p>
<h4 id="Go-1-9以后「1-14为例」"><a class="header-anchor" href="#Go-1-9以后「1-14为例」">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/runtime2.go#L1018">Go 1.9以后「1.14为例」</a></h4>
<blockquote>
<p>最大为int32的最大值：<br>
<img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210507_121640.png" alt=""></p>
</blockquote>
<h4 id="坑点："><a class="header-anchor" href="#坑点：">¶</a>坑点：</h4>
<p>Go 1.14以后看似最大是int32最大值，但是有一个新问题，真的可以设置到最大值吗？实验一把：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="type">int32</span>(^<span class="type">uint32</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果报错：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fatal <span class="type">error</span>: slice bounds out of <span class="keyword">range</span></span><br><span class="line">fatal <span class="type">error</span>: unexpected signal during runtime execution</span><br><span class="line"><span class="built_in">panic</span> during <span class="built_in">panic</span></span><br><span class="line">[signal SIGSEGV: segmentation violation code=<span class="number">0x1</span> addr=<span class="number">0x4</span> pc=<span class="number">0x104098b</span>]</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">....</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<blockquote>
<p>🤔🤔🤔🤔🤔数组越界了？</p>
</blockquote>
<blockquote>
<p>又反复看了看源码，问题找出来了：</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210507_122730.png" alt=""></p>
<h5 id="问题的关键"><a class="header-anchor" href="#问题的关键">¶</a>问题的关键</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">maskWords := (nprocs + <span class="number">31</span>) / <span class="number">32</span></span><br><span class="line"></span><br><span class="line">导致：maskWords数值溢出了，导致下面截取<span class="built_in">panic</span>。</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nprocs &lt;= <span class="type">int32</span>(<span class="built_in">cap</span>(allp)) &#123;</span><br><span class="line">	allp = allp[:nprocs]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="GOMAXPROCS最大值？？"><a class="header-anchor" href="#GOMAXPROCS最大值？？">¶</a>GOMAXPROCS最大值？？</h3>
<blockquote>
<p>所以GOMAXPROCS最大为: int32(^uint32(0) &gt;&gt; 1)-31</p>
</blockquote>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>GPM</tag>
        <tag>Go源码</tag>
        <tag>Day</tag>
      </tags>
  </entry>
  <entry>
    <title>「49」Go runtime操作「持续更新」</title>
    <url>/archives/3b137bd0.html</url>
    <content><![CDATA[<p>主要从以下几个方面：</p>
<ul>
<li>变量的含义和存在的作用</li>
<li>方法的用途</li>
<li>设计方式分析</li>
</ul>
<span id="more"></span>
<h3 id="变量作用："><a class="header-anchor" href="#变量作用：">¶</a>变量作用：</h3>
<h4 id="全局的"><a class="header-anchor" href="#全局的">¶</a>全局的</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// 全局m</span></span><br><span class="line">	allm       *m</span><br><span class="line">	<span class="comment">// proc最大值</span></span><br><span class="line">	gomaxprocs <span class="type">int32</span></span><br><span class="line">	<span class="comment">// cpu数量</span></span><br><span class="line">	ncpu       <span class="type">int32</span></span><br><span class="line">	forcegc    forcegcstate</span><br><span class="line">	<span class="comment">// 调度过程中的结构体</span></span><br><span class="line">	sched      schedt</span><br><span class="line">	<span class="comment">// gomaxprocs数量</span></span><br><span class="line">	newprocs   <span class="type">int32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// allpLock protects P-less reads and size changes of allp, idlepMask,</span></span><br><span class="line">	<span class="comment">// and timerpMask, and all writes to allp.</span></span><br><span class="line">	<span class="comment">// 全局p对应的lock</span></span><br><span class="line">	allpLock mutex</span><br><span class="line">	<span class="comment">// len(allp) == gomaxprocs; may change at safe points, otherwise</span></span><br><span class="line">	<span class="comment">// immutable.</span></span><br><span class="line">	<span class="comment">// P的全局队列</span></span><br><span class="line">	allp []*p</span><br><span class="line">	......</span><br><span class="line">	....</span><br><span class="line">	...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="G的状态："><a class="header-anchor" href="#G的状态：">¶</a>G的状态：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_Gidle</span><br><span class="line">_Grunnable</span><br><span class="line">_Grunning</span><br><span class="line">_Gsyscall</span><br><span class="line">_Gwaiting</span><br><span class="line">_Gdead</span><br><span class="line">_Gcopystack</span><br><span class="line">_Gpreempted</span><br><span class="line">_Gscan = <span class="number">0x1000</span></span><br><span class="line">_Gscanrunnable</span><br><span class="line">_Gscansyscall</span><br><span class="line">_Gscanwaiting</span><br><span class="line">_Gscanpreempted</span><br></pre></td></tr></table></figure>
<h4 id="P的状态："><a class="header-anchor" href="#P的状态：">¶</a>P的状态：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_Pidle</span><br><span class="line">_Prunning</span><br><span class="line">_Psyscall</span><br><span class="line">_Pgcstop</span><br><span class="line">_Pdead</span><br></pre></td></tr></table></figure>
<h4 id="sudog"><a class="header-anchor" href="#sudog">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/runtime2.go#L332">sudog</a></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sudog represents a g in a wait list, such as for sending/receiving</span></span><br><span class="line"><span class="comment">// on a channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sudog is necessary because the g ↔ synchronization object relation</span></span><br><span class="line"><span class="comment">// is many-to-many. A g can be on many wait lists, so there may be</span></span><br><span class="line"><span class="comment">// many sudogs for one g; and many gs may be waiting on the same</span></span><br><span class="line"><span class="comment">// synchronization object, so there may be many sudogs for one object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sudogs are allocated from a special pool. Use acquireSudog and</span></span><br><span class="line"><span class="comment">// releaseSudog to allocate and free them.</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The following fields are protected by the hchan.lock of the</span></span><br><span class="line">	<span class="comment">// channel this sudog is blocking on. shrinkstack depends on</span></span><br><span class="line">	<span class="comment">// this for sudogs involved in channel ops.</span></span><br><span class="line">	<span class="comment">// 当前处于goroutine</span></span><br><span class="line">	g *g </span><br><span class="line"></span><br><span class="line">	<span class="comment">// isSelect indicates g is participating in a select, so</span></span><br><span class="line">	<span class="comment">// g.selectDone must be CAS&#x27;d to win the wake-up race.</span></span><br><span class="line">	<span class="comment">// 标记select</span></span><br><span class="line">	isSelect <span class="type">bool</span></span><br><span class="line">	next     *sudog</span><br><span class="line">	prev     *sudog</span><br><span class="line">	elem     unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The following fields are never accessed concurrently.</span></span><br><span class="line">	<span class="comment">// For channels, waitlink is only accessed by g.</span></span><br><span class="line">	<span class="comment">// For semaphores, all fields (including the ones above)</span></span><br><span class="line">	<span class="comment">// are only accessed when holding a semaRoot lock.</span></span><br><span class="line"></span><br><span class="line">	acquiretime <span class="type">int64</span></span><br><span class="line">	releasetime <span class="type">int64</span></span><br><span class="line">	ticket      <span class="type">uint32</span></span><br><span class="line">	parent      *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">	waitlink    *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">	waittail    *sudog <span class="comment">// semaRoot</span></span><br><span class="line">	c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="g"><a class="header-anchor" href="#g">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/runtime2.go#L395">g</a></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// panic结构</span></span><br><span class="line">_panic		*_panic</span><br><span class="line"><span class="comment">// defer函数结构</span></span><br><span class="line">_defer		*_defer</span><br><span class="line"><span class="comment">// 绑定的m</span></span><br><span class="line">m     		 *m</span><br><span class="line"><span class="comment">// goid序号</span></span><br><span class="line">goid		 <span class="type">int64</span></span><br><span class="line"><span class="comment">// 抢占关系 </span></span><br><span class="line">preempt		 <span class="type">bool</span></span><br><span class="line"><span class="comment">// 等待的队列</span></span><br><span class="line">waiting		 *sudog</span><br><span class="line"><span class="comment">//cached for time.sleep</span></span><br><span class="line">timer		 *timer</span><br><span class="line">.....</span><br><span class="line">....</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="m"><a class="header-anchor" href="#m">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/runtime2.go#L477">m</a></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">g0 		*g</span><br><span class="line">currg 	*g</span><br><span class="line">procid  <span class="type">uint64</span></span><br><span class="line"><span class="comment">// 自旋</span></span><br><span class="line">spinning <span class="type">bool</span> </span><br><span class="line"><span class="comment">// 随机数</span></span><br><span class="line">fastrand [<span class="number">2</span>]<span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">park     note</span><br><span class="line">alllink *m</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="p"><a class="header-anchor" href="#p">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/runtime2.go#L556">p</a></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">id		<span class="type">int32</span></span><br><span class="line">status 	<span class="type">uint32</span></span><br><span class="line">m 		*m</span><br><span class="line"><span class="comment">// timer使用相关</span></span><br><span class="line">timerslock mutex</span><br><span class="line">timers []*timer</span><br><span class="line">numTimers <span class="type">uint32</span></span><br><span class="line"><span class="comment">// 抢占关系</span></span><br><span class="line">preempt <span class="type">bool</span></span><br></pre></td></tr></table></figure>
<h4 id="defer"><a class="header-anchor" href="#defer">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/runtime2.go#L865">_defer</a></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">fn        *funcval <span class="comment">// can be nil for open-coded defers</span></span><br><span class="line">_panic    *_panic  <span class="comment">// panic that is running defer</span></span><br><span class="line">link      *_defer</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="panic"><a class="header-anchor" href="#panic">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/runtime2.go#L903">_panic</a></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A _panic holds information about an active panic.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A _panic value must only ever live on the stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The argp and link fields are stack pointers, but don&#x27;t need special</span></span><br><span class="line"><span class="comment">// handling during stack growth: because they are pointer-typed and</span></span><br><span class="line"><span class="comment">// _panic values only live on the stack, regular stack pointer</span></span><br><span class="line"><span class="comment">// adjustment takes care of them.</span></span><br><span class="line"><span class="keyword">type</span> _panic <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// function</span></span><br><span class="line">	argp      unsafe.Pointer <span class="comment">// pointer to arguments of deferred call run during panic; cannot move - known to liblink</span></span><br><span class="line">	<span class="comment">// 参数</span></span><br><span class="line">	arg       <span class="keyword">interface</span>&#123;&#125;    <span class="comment">// argument to panic</span></span><br><span class="line">	<span class="comment">// link to _panic</span></span><br><span class="line">	link      *_panic        <span class="comment">// link to earlier panic</span></span><br><span class="line">	pc        <span class="type">uintptr</span>        <span class="comment">// where to return to in runtime if this panic is bypassed</span></span><br><span class="line">	sp        unsafe.Pointer <span class="comment">// where to return to in runtime if this panic is bypassed</span></span><br><span class="line">	<span class="comment">// recover标志</span></span><br><span class="line">	recovered <span class="type">bool</span>           <span class="comment">// whether this panic is over</span></span><br><span class="line">	aborted   <span class="type">bool</span>           <span class="comment">// the panic was aborted</span></span><br><span class="line">	goexit    <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="持续更新…"><a class="header-anchor" href="#持续更新…">¶</a>持续更新…</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go源码</tag>
        <tag>Day</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>「47」GPM main启动</title>
    <url>/archives/66b6223a.html</url>
    <content><![CDATA[<p>之前扯过GPM的<a href="https://blog.imrcrab.com/archives/392d66f0.html">g0和m0关系</a>和<a href="https://blog.imrcrab.com/archives/9bb71eca.html">main函数入口</a>的一些相关信息。</p>
<p>多次看go mian函数的启动流程，多次分析，多次理解，关注点和结论各有不同，以此记录。</p>
<h3 id="👋入口："><a class="header-anchor" href="#👋入口：">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/asm_amd64.s#L22">👋入口</a>：</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210505_094951.png" alt=""></p>
<span id="more"></span>
<h3 id="搞一个简单的main函数看下汇编："><a class="header-anchor" href="#搞一个简单的main函数看下汇编：">¶</a>搞一个简单的main函数看下汇编：</h3>
<h4 id="Main函数"><a class="header-anchor" href="#Main函数">¶</a>Main函数</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="汇编结果"><a class="header-anchor" href="#汇编结果">¶</a>汇编结果</h4>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210506_111747.png" alt=""></p>
<h3 id="大体流程："><a class="header-anchor" href="#大体流程：">¶</a>大体流程：</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210506_013950.png" alt=""></p>
<h3 id="汇编代码定义："><a class="header-anchor" href="#汇编代码定义：">¶</a>汇编代码定义：</h3>
<ul>
<li>全局：<a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/asm_amd64.s#L236">👉🏻</a></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210506_112649.png" alt=""></p>
<ul>
<li>入口：<a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/asm_amd64.s#L22">👉🏻</a></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210506_122959.png" alt=""></p>
<h3 id="rt0-go函数："><a class="header-anchor" href="#rt0-go函数：">¶</a>rt0_go函数：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT|TOPFRAME,$<span class="number">0</span></span><br><span class="line">	<span class="comment">// copy arguments forward on an even stack</span></span><br><span class="line">	MOVQ	DI, AX		<span class="comment">// argc</span></span><br><span class="line">	MOVQ	SI, BX		<span class="comment">// argv</span></span><br><span class="line">	SUBQ	$(<span class="number">4</span>*<span class="number">8</span>+<span class="number">7</span>), SP		<span class="comment">// 2args 2auto</span></span><br><span class="line">	ANDQ	$~<span class="number">15</span>, SP</span><br><span class="line">	MOVQ	AX, <span class="number">16</span>(SP)</span><br><span class="line">	MOVQ	BX, <span class="number">24</span>(SP)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建操作系统stack</span></span><br><span class="line">	<span class="comment">// create istack out of the given (operating system) stack.</span></span><br><span class="line">	<span class="comment">// _cgo_init may update stackguard.</span></span><br><span class="line">	MOVQ	$runtime·g0(SB), DI</span><br><span class="line">	LEAQ	(<span class="number">-64</span>*<span class="number">1024</span>+<span class="number">104</span>)(SP), BX</span><br><span class="line">	MOVQ	BX, g_stackguard0(DI)</span><br><span class="line">	MOVQ	BX, g_stackguard1(DI)</span><br><span class="line">	MOVQ	BX, (g_stack+stack_lo)(DI)</span><br><span class="line">	MOVQ	SP, (g_stack+stack_hi)(DI)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find out information about the processor we&#x27;re on</span></span><br><span class="line">	MOVL	$<span class="number">0</span>, AX</span><br><span class="line">	CPUID</span><br><span class="line">	MOVL	AX, SI</span><br><span class="line">	CMPL	AX, $<span class="number">0</span></span><br><span class="line">	JE	nocpuinfo</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化选择</span></span><br><span class="line">	<span class="comment">// Figure out how to serialize RDTSC.</span></span><br><span class="line">	<span class="comment">// On Intel processors LFENCE is enough. AMD requires MFENCE.</span></span><br><span class="line">	<span class="comment">// Don&#x27;t know about the rest, so let&#x27;s do MFENCE.</span></span><br><span class="line">	CMPL	BX, $<span class="number">0x756E6547</span>  <span class="comment">// &quot;Genu&quot;</span></span><br><span class="line">	JNE	notintel</span><br><span class="line">	CMPL	DX, $<span class="number">0x49656E69</span>  <span class="comment">// &quot;ineI&quot;</span></span><br><span class="line">	JNE	notintel</span><br><span class="line">	CMPL	CX, $<span class="number">0x6C65746E</span>  <span class="comment">// &quot;ntel&quot;</span></span><br><span class="line">	JNE	notintel</span><br><span class="line">	MOVB	$<span class="number">1</span>, runtime·isIntel(SB)</span><br><span class="line">	MOVB	$<span class="number">1</span>, runtime·lfenceBeforeRdtsc(SB)</span><br><span class="line">notintel:</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Load EAX=1 cpuid flags</span></span><br><span class="line">	MOVL	$<span class="number">1</span>, AX</span><br><span class="line">	CPUID</span><br><span class="line">	MOVL	AX, runtime·processorVersionInfo(SB)</span><br><span class="line"></span><br><span class="line">nocpuinfo:</span><br><span class="line">	<span class="comment">// if there is an _cgo_init, call it.</span></span><br><span class="line">	MOVQ	_cgo_init(SB), AX</span><br><span class="line">	TESTQ	AX, AX</span><br><span class="line">	JZ	needtls</span><br><span class="line">	<span class="comment">// arg 1: g0, already in DI</span></span><br><span class="line">	MOVQ	$setg_gcc&lt;&gt;(SB), SI <span class="comment">// arg 2: setg_gcc</span></span><br><span class="line">#ifdef GOOS_android</span><br><span class="line">	MOVQ	$runtime·tls_g(SB), DX 	<span class="comment">// arg 3: &amp;tls_g</span></span><br><span class="line">	<span class="comment">// arg 4: TLS base, stored in slot 0 (Android&#x27;s TLS_SLOT_SELF).</span></span><br><span class="line">	<span class="comment">// Compensate for tls_g (+16).</span></span><br><span class="line">	MOVQ	<span class="number">-16</span>(TLS), CX</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">	MOVQ	$<span class="number">0</span>, DX	<span class="comment">// arg 3, 4: not used when using platform&#x27;s TLS</span></span><br><span class="line">	MOVQ	$<span class="number">0</span>, CX</span><br><span class="line">#endif</span><br><span class="line">#ifdef GOOS_windows</span><br><span class="line">	<span class="comment">// Adjust for the Win64 calling convention.</span></span><br><span class="line">	MOVQ	CX, R9 <span class="comment">// arg 4</span></span><br><span class="line">	MOVQ	DX, R8 <span class="comment">// arg 3</span></span><br><span class="line">	MOVQ	SI, DX <span class="comment">// arg 2</span></span><br><span class="line">	MOVQ	DI, CX <span class="comment">// arg 1</span></span><br><span class="line">#endif</span><br><span class="line">	CALL	AX</span><br><span class="line"></span><br><span class="line">	<span class="comment">// update stackguard after _cgo_init</span></span><br><span class="line">	MOVQ	$runtime·g0(SB), CX</span><br><span class="line">	MOVQ	(g_stack+stack_lo)(CX), AX</span><br><span class="line">	ADDQ	$const__StackGuard, AX</span><br><span class="line">	MOVQ	AX, g_stackguard0(CX)</span><br><span class="line">	MOVQ	AX, g_stackguard1(CX)</span><br><span class="line"></span><br><span class="line">#ifndef GOOS_windows</span><br><span class="line">	JMP ok</span><br><span class="line">#endif</span><br><span class="line">needtls:</span><br><span class="line">#ifdef GOOS_plan9</span><br><span class="line">	<span class="comment">// skip TLS setup on Plan 9</span></span><br><span class="line">	JMP ok</span><br><span class="line">#endif</span><br><span class="line">#ifdef GOOS_solaris</span><br><span class="line">	<span class="comment">// skip TLS setup on Solaris</span></span><br><span class="line">	JMP ok</span><br><span class="line">#endif</span><br><span class="line">#ifdef GOOS_illumos</span><br><span class="line">	<span class="comment">// skip TLS setup on illumos</span></span><br><span class="line">	JMP ok</span><br><span class="line">#endif</span><br><span class="line">#ifdef GOOS_darwin</span><br><span class="line">	<span class="comment">// skip TLS setup on Darwin</span></span><br><span class="line">	JMP ok</span><br><span class="line">#endif</span><br><span class="line">#ifdef GOOS_openbsd</span><br><span class="line">	<span class="comment">// skip TLS setup on OpenBSD</span></span><br><span class="line">	JMP ok</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	LEAQ	runtime·m0+m_tls(SB), DI</span><br><span class="line">	CALL	runtime·settls(SB)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tls设置</span></span><br><span class="line">	<span class="comment">// store through it, to make sure it works</span></span><br><span class="line">	get_tls(BX)</span><br><span class="line">	MOVQ	$<span class="number">0x123</span>, g(BX)</span><br><span class="line">	MOVQ	runtime·m0+m_tls(SB), AX</span><br><span class="line">	CMPQ	AX, $<span class="number">0x123</span></span><br><span class="line">	JEQ <span class="number">2</span>(PC)</span><br><span class="line">	CALL	runtime·abort(SB)</span><br><span class="line">ok:</span><br><span class="line">	<span class="comment">// set the per-goroutine and per-mach &quot;registers&quot;</span></span><br><span class="line">	get_tls(BX)</span><br><span class="line">	LEAQ	runtime·g0(SB), CX</span><br><span class="line">	MOVQ	CX, g(BX)</span><br><span class="line">	LEAQ	runtime·m0(SB), AX</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m.g0绑定一个g0</span></span><br><span class="line">	<span class="comment">// save m-&gt;g0 = g0</span></span><br><span class="line">	MOVQ	CX, m_g0(AX)</span><br><span class="line">    <span class="comment">// g0绑定m0</span></span><br><span class="line">	<span class="comment">// save m0 to g0-&gt;m</span></span><br><span class="line">	MOVQ	AX, g_m(CX)</span><br><span class="line"></span><br><span class="line">	CLD				<span class="comment">// convention is D is always left cleared</span></span><br><span class="line">	CALL	runtime·check(SB)</span><br><span class="line"></span><br><span class="line">	MOVL	<span class="number">16</span>(SP), AX		<span class="comment">// copy argc</span></span><br><span class="line">	MOVL	AX, <span class="number">0</span>(SP)</span><br><span class="line">	MOVQ	<span class="number">24</span>(SP), AX		<span class="comment">// copy argv</span></span><br><span class="line">	MOVQ	AX, <span class="number">8</span>(SP)</span><br><span class="line">    <span class="comment">// 参数初始化</span></span><br><span class="line">	CALL	runtime·args(SB)</span><br><span class="line">    <span class="comment">// 系统初始化</span></span><br><span class="line">	CALL	runtime·osinit(SB)</span><br><span class="line">    <span class="comment">// 调度任务初始化，具体逻辑下面有提到</span></span><br><span class="line">	CALL	runtime·schedinit(SB)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第一个g，用于启动程序</span></span><br><span class="line">	<span class="comment">// create a new goroutine to start program</span></span><br><span class="line">	MOVQ	$runtime·mainPC(SB), AX		<span class="comment">// entry</span></span><br><span class="line">	PUSHQ	AX</span><br><span class="line">	PUSHQ	$<span class="number">0</span>			<span class="comment">// arg size</span></span><br><span class="line">	CALL	runtime·newproc(SB)</span><br><span class="line">	POPQ	AX</span><br><span class="line">	POPQ	AX</span><br><span class="line"></span><br><span class="line">	<span class="comment">// start this M</span></span><br><span class="line">    <span class="comment">//  启动M</span></span><br><span class="line">	CALL	runtime·mstart(SB)</span><br><span class="line"></span><br><span class="line">	CALL	runtime·abort(SB)	<span class="comment">// mstart should never return</span></span><br><span class="line">	RET</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prevent dead-code elimination of debugCallV2, which is</span></span><br><span class="line">	<span class="comment">// intended to be called by debuggers.</span></span><br><span class="line">	MOVQ	$runtime·debugCallV2&lt;ABIInternal&gt;(SB), AX</span><br><span class="line">	RET</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="➡️➡️👋mstart作用"><a class="header-anchor" href="#➡️➡️👋mstart作用">¶</a>➡️➡️<a href="https://blog.imrcrab.com/archives/392d66f0.html#mstart">👋mstart作用</a></h3>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>GPM</tag>
        <tag>Go源码</tag>
        <tag>Day</tag>
      </tags>
  </entry>
  <entry>
    <title>「46」chan布局和设计「源码」</title>
    <url>/archives/a0547b09.html</url>
    <content><![CDATA[<p>chan在Go中很常用，平时用的不少，但是总是没用的完整，<br>
下来看了多次chan源码，总结记录下：</p>
<h3 id="结构方面"><a class="header-anchor" href="#结构方面">¶</a>结构方面</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/Canvas%201.png" alt=""></p>
<span id="more"></span>
<h3 id="makechan方面"><a class="header-anchor" href="#makechan方面">¶</a>makechan方面</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/makechan.png" alt=""></p>
<h3 id="chansend「c-“aaa”」消息发送"><a class="header-anchor" href="#chansend「c-“aaa”」消息发送">¶</a>chansend「c&lt;-“aaa”」消息发送</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/chansend.png" alt=""></p>
<h3 id="chanrecv-「-c」-消息消费"><a class="header-anchor" href="#chanrecv-「-c」-消息消费">¶</a>chanrecv 「&lt;-c」 消息消费</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/chanrecv.png" alt=""></p>
<h3 id="closed过程"><a class="header-anchor" href="#closed过程">¶</a>closed过程</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/closed.png" alt=""></p>
<h3 id="summary"><a class="header-anchor" href="#summary">¶</a>summary</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/summary.png" alt=""></p>
<h3 id="待更…"><a class="header-anchor" href="#待更…">¶</a>待更…</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go源码</tag>
        <tag>Day</tag>
        <tag>chan</tag>
      </tags>
  </entry>
  <entry>
    <title>「45」Go 1.17特性</title>
    <url>/archives/5549cd1.html</url>
    <content><![CDATA[<p>Go 1.17特性：</p>
<span id="more"></span>
<h2 id="1、「slice」-allow-conversion-from-slice-to-array-ptr"><a class="header-anchor" href="#1、「slice」-allow-conversion-from-slice-to-array-ptr">¶</a>1、「slice」 <a href="https://github.com/golang/go/issues/395">allow conversion from slice to array ptr </a></h2>
<blockquote>
<p>commit: <a href="https://github.com/golang/go/commit/760d3b2a16544aab553ca7ec6e6ed3bf4dc9aa3f">reflect: allow conversion from slice to array ptr</a></p>
</blockquote>
<p>参考：<br>
<a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoConvertSliceToArray">Go 1.17 will allow converting a slice to an array pointer (some of the time)</a></p>
<h2 id="2、「net」-add-IP-IsPrivate"><a class="header-anchor" href="#2、「net」-add-IP-IsPrivate">¶</a>2、「net」  add IP.IsPrivate</h2>
<p><a href="https://go-review.googlesource.com/c/go/+/272668/">👋➡️review:</a></p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210424_011546.png" alt=""></p>
<h2 id="3、「Test」-add-TB-Setenv"><a class="header-anchor" href="#3、「Test」-add-TB-Setenv">¶</a>3、「Test」 <a href="https://github.com/bynov/go/commit/0ca12fa565318f350b927e2ef94f3b4f792c75c2">add TB.Setenv</a></h2>
<blockquote>
<p>测试后还原env变量，不能用于并发测试</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210424_012002.png" alt=""></p>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>Go_1.17</tag>
      </tags>
  </entry>
  <entry>
    <title>「44」redis-sds源码</title>
    <url>/archives/9989a7c4.html</url>
    <content><![CDATA[<blockquote>
<p>SDS在redis中也算是用来存储string高效的做法，采用header+string的形式。</p>
</blockquote>
<h3 id="学完预期的目标"><a class="header-anchor" href="#学完预期的目标">¶</a>学完预期的目标:</h3>
<ul>
<li>SDS 结构类型</li>
<li>SDS 结构为何高效？</li>
<li>创建？</li>
<li>扩容？</li>
<li>释放？</li>
<li>复制？</li>
<li>Join连接？</li>
<li>Resize the allocation ？？</li>
<li>其它</li>
</ul>
<span id="more"></span>
<h3 id="SDS结构"><a class="header-anchor" href="#SDS结构">¶</a>SDS结构</h3>
<blockquote>
<p><a href="https://github.com/redis/redis/blob/unstable/src/sds.h#L43">☞☞ SDS官方定义</a></p>
</blockquote>
<blockquote>
<p>⚙️ 4种大小的定义，适配不同的场景需求。</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210726_112207.png" alt=""></p>
<h3 id="why高效"><a class="header-anchor" href="#why高效">¶</a>why高效?</h3>
<h4 id="获取字符串长度：O-1"><a class="header-anchor" href="#获取字符串长度：O-1">¶</a>获取字符串长度：O(1)</h4>
<p>sds: O(1)<br>
c字符串： O(N)</p>
<h4 id="防止内存溢出"><a class="header-anchor" href="#防止内存溢出">¶</a>防止内存溢出</h4>
<p>sds: 封装好的函数，易于操作和检查<br>
c字符串：操作不当易内存溢出</p>
<h4 id="内存分配"><a class="header-anchor" href="#内存分配">¶</a>内存分配</h4>
<p>sds: 空间预分配和惰性释放<br>
c字符串：无此特性</p>
<h4 id="二进制安全"><a class="header-anchor" href="#二进制安全">¶</a>二进制安全</h4>
<p>sds: 按照二进制方式处理，因此无限制<br>
c字符串：必须符合编码（ascii），限制c中不能保存图片和音频等</p>
<h3 id="SDS-API列表"><a class="header-anchor" href="#SDS-API列表">¶</a>SDS API列表</h3>
<blockquote>
<p>待更新…</p>
</blockquote>
<h3 id="Reference"><a class="header-anchor" href="#Reference">¶</a>Reference</h3>
<ul>
<li>
<p><a href="https://github.com/redis/redis/blob/unstable/src/sds.h#L43">☞ SDS官方定义</a></p>
</li>
<li>
<p><a href="https://github.com/antirez/sds">👉🏿 Simple Dynamic Strings</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
        <tag>SDS</tag>
      </tags>
  </entry>
  <entry>
    <title>「43」Redis AOF持久化</title>
    <url>/archives/777dd730.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序:</h3>
<p>AOF开启的配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">#appendonly no</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>
<p>但是redis根据这配置到底是如何实现 AOF的呢?</p>
<span id="more"></span>
<h3 id="appendOnly起点："><a class="header-anchor" href="#appendOnly起点：">¶</a>appendOnly起点：</h3>
<p>通过config.c配置文件可以查到appendOnly对应的变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">createBoolConfig(<span class="string">&quot;appendonly&quot;</span>, NULL, MODIFIABLE_CONFIG, server.aof_enabled, <span class="number">0</span>, NULL, updateAppendonly)</span><br></pre></td></tr></table></figure>
<h4 id="关于aof-enable使用地方："><a class="header-anchor" href="#关于aof-enable使用地方：">¶</a>关于aof_enable使用地方：</h4>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210318_020243.png" alt=""></p>
<h4 id="再看下aof-state使用地方："><a class="header-anchor" href="#再看下aof-state使用地方：">¶</a>再看下aof_state使用地方：</h4>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210318_020100.png" alt=""></p>
<h3 id="主要方向："><a class="header-anchor" href="#主要方向：">¶</a>主要方向：</h3>
<ul>
<li>aof在启动时候加载顺序</li>
<li>aof存文件如何被触发执行的</li>
<li>aof保存的机制/同步策略？</li>
<li>aof机制和rdb混用？</li>
<li>aof如何保持较高的性能？</li>
</ul>
<h4 id="server启动，aof开启，加载流程："><a class="header-anchor" href="#server启动，aof开启，加载流程：">¶</a>server启动，aof开启，加载流程：</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Replay the append log file. On success C_OK is returned. On non fatal</span></span><br><span class="line"><span class="comment"> * error (the append only file is zero-length) C_ERR is returned. On</span></span><br><span class="line"><span class="comment"> * fatal error an error message is logged and the program exists. */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">loadAppendOnlyFile</span><span class="params">(<span class="type">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">client</span> *fakeClient;</span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">redis_stat</span> sb;</span><br><span class="line">    <span class="type">int</span> old_aof_state = server.aof_state;</span><br><span class="line">    <span class="type">long</span> loops = <span class="number">0</span>;</span><br><span class="line">    <span class="type">off_t</span> valid_up_to = <span class="number">0</span>; <span class="comment">/* Offset of latest well-formed command loaded. */</span></span><br><span class="line">    <span class="type">off_t</span> valid_before_multi = <span class="number">0</span>; <span class="comment">/* Offset before MULTI command loaded. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">serverLog</span>(LL_WARNING,<span class="string">&quot;Fatal error: can&#x27;t open the append log file for reading: %s&quot;</span>,<span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle a zero-length AOF file as a special case. An empty AOF file</span></span><br><span class="line"><span class="comment">     * is a valid AOF because an empty server with AOF enabled will create</span></span><br><span class="line"><span class="comment">     * a zero length file at startup, that will remain like that if no write</span></span><br><span class="line"><span class="comment">     * operation is received. */</span></span><br><span class="line">    <span class="keyword">if</span> (fp &amp;&amp; <span class="built_in">redis_fstat</span>(<span class="built_in">fileno</span>(fp),&amp;sb) != <span class="number">-1</span> &amp;&amp; sb.st_size == <span class="number">0</span>) &#123;</span><br><span class="line">        server.aof_current_size = <span class="number">0</span>;</span><br><span class="line">        server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">        <span class="built_in">fclose</span>(fp);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Temporarily disable AOF, to prevent EXEC from feeding a MULTI</span></span><br><span class="line"><span class="comment">     * to the same file we&#x27;re about to read. */</span></span><br><span class="line">    server.aof_state = AOF_OFF;</span><br><span class="line">    <span class="comment">// 创建aof客户端</span></span><br><span class="line">    fakeClient = <span class="built_in">createAOFClient</span>();</span><br><span class="line">    <span class="comment">//加载文件</span></span><br><span class="line">    <span class="built_in">startLoadingFile</span>(fp, filename, RDBFLAGS_AOF_PREAMBLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if this AOF file has an RDB preamble. In that case we need to</span></span><br><span class="line"><span class="comment">     * load the RDB file and later continue loading the AOF tail. */</span></span><br><span class="line">    <span class="comment">// 检查aof头部有没有rdb格式的内容，先加载rdb再加载aof</span></span><br><span class="line">    <span class="type">char</span> sig[<span class="number">5</span>]; <span class="comment">/* &quot;REDIS&quot; */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fread</span>(sig,<span class="number">1</span>,<span class="number">5</span>,fp) != <span class="number">5</span> || <span class="built_in">memcmp</span>(sig,<span class="string">&quot;REDIS&quot;</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* No RDB preamble, seek back at 0 offset. */</span></span><br><span class="line">        <span class="comment">// 没有rdb格式的，</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fseek</span>(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* RDB preamble. Pass loading the RDB functions. */</span></span><br><span class="line">        rio rdb;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">serverLog</span>(LL_NOTICE,<span class="string">&quot;Reading RDB preamble from AOF file...&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fseek</span>(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">        <span class="built_in">rioInitWithFile</span>(&amp;rdb,fp);</span><br><span class="line">        <span class="comment">// 加载rdb格式的文件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">rdbLoadRio</span>(&amp;rdb,RDBFLAGS_AOF_PREAMBLE,<span class="literal">NULL</span>) != C_OK) &#123;</span><br><span class="line">            <span class="built_in">serverLog</span>(LL_WARNING,<span class="string">&quot;Error reading the RDB preamble of the AOF file, AOF loading aborted&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> readerr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">serverLog</span>(LL_NOTICE,<span class="string">&quot;Reading the remaining AOF tail...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read the actual AOF file, in REPL format, command by command. */</span></span><br><span class="line">    <span class="comment">// 按照aof协议来读取/解析aof文件</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> argc, j;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">        robj **argv;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        sds argsds;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">redisCommand</span> *cmd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Serve the clients from time to time */</span></span><br><span class="line">        <span class="keyword">if</span> (!(loops++ % <span class="number">1000</span>)) &#123;</span><br><span class="line">            <span class="built_in">loadingProgress</span>(<span class="built_in">ftello</span>(fp));</span><br><span class="line">            <span class="built_in">processEventsWhileBlocked</span>();</span><br><span class="line">            <span class="built_in">processModuleLoadingProgressEvent</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fgets</span>(buf,<span class="built_in">sizeof</span>(buf),fp) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">feof</span>(fp))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">&#x27;*&#x27;</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">        argc = <span class="built_in">atoi</span>(buf+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (argc &lt; <span class="number">1</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Load the next command in the AOF as our fake client</span></span><br><span class="line"><span class="comment">         * argv. */</span></span><br><span class="line">        argv = <span class="built_in">zmalloc</span>(<span class="built_in">sizeof</span>(robj*)*argc);</span><br><span class="line">        fakeClient-&gt;argc = argc;</span><br><span class="line">        fakeClient-&gt;argv = argv;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">            <span class="comment">/* Parse the argument len. */</span></span><br><span class="line">            <span class="type">char</span> *readres = <span class="built_in">fgets</span>(buf,<span class="built_in">sizeof</span>(buf),fp);</span><br><span class="line">            <span class="keyword">if</span> (readres == <span class="literal">NULL</span> || buf[<span class="number">0</span>] != <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">                fakeClient-&gt;argc = j; <span class="comment">/* Free up to j-1. */</span></span><br><span class="line">                <span class="built_in">freeFakeClientArgv</span>(fakeClient);</span><br><span class="line">                <span class="keyword">if</span> (readres == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">goto</span> readerr;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">goto</span> fmterr;</span><br><span class="line">            &#125;</span><br><span class="line">            len = <span class="built_in">strtol</span>(buf+<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Read it into a string object. */</span></span><br><span class="line">            argsds = <span class="built_in">sdsnewlen</span>(SDS_NOINIT,len);</span><br><span class="line">            <span class="keyword">if</span> (len &amp;&amp; <span class="built_in">fread</span>(argsds,len,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">sdsfree</span>(argsds);</span><br><span class="line">                fakeClient-&gt;argc = j; <span class="comment">/* Free up to j-1. */</span></span><br><span class="line">                <span class="built_in">freeFakeClientArgv</span>(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">            &#125;</span><br><span class="line">            argv[j] = <span class="built_in">createObject</span>(OBJ_STRING,argsds);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Discard CRLF. */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fread</span>(buf,<span class="number">2</span>,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123;</span><br><span class="line">                fakeClient-&gt;argc = j+<span class="number">1</span>; <span class="comment">/* Free up to j. */</span></span><br><span class="line">                <span class="built_in">freeFakeClientArgv</span>(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Command lookup */</span></span><br><span class="line">        cmd = <span class="built_in">lookupCommand</span>(argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">        <span class="comment">// 未知命令，启动直接退出了</span></span><br><span class="line">        <span class="keyword">if</span> (!cmd) &#123;</span><br><span class="line">            <span class="built_in">serverLog</span>(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;Unknown command &#x27;%s&#x27; reading the append only file&quot;</span>,</span><br><span class="line">                (<span class="type">char</span>*)argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmd == server.multiCommand) valid_before_multi = valid_up_to;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Run the command in the context of a fake client */</span></span><br><span class="line">        fakeClient-&gt;cmd = fakeClient-&gt;lastcmd = cmd;</span><br><span class="line">        <span class="keyword">if</span> (fakeClient-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">            fakeClient-&gt;cmd-&gt;proc != execCommand)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">queueMultiCommand</span>(fakeClient);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cmd-&gt;<span class="built_in">proc</span>(fakeClient);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The fake client should not have a reply */</span></span><br><span class="line">        <span class="built_in">serverAssert</span>(fakeClient-&gt;bufpos == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     <span class="built_in">listLength</span>(fakeClient-&gt;reply) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The fake client should never get blocked */</span></span><br><span class="line">        <span class="built_in">serverAssert</span>((fakeClient-&gt;flags &amp; CLIENT_BLOCKED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Clean up. Command code may have changed argv/argc so we use the</span></span><br><span class="line"><span class="comment">         * argv/argc of the client instead of the local variables. */</span></span><br><span class="line">        <span class="built_in">freeFakeClientArgv</span>(fakeClient);</span><br><span class="line">        fakeClient-&gt;cmd = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (server.aof_load_truncated) valid_up_to = <span class="built_in">ftello</span>(fp);</span><br><span class="line">        <span class="keyword">if</span> (server.key_load_delay)</span><br><span class="line">            <span class="built_in">debugDelay</span>(server.key_load_delay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This point can only be reached when EOF is reached without errors.</span></span><br><span class="line"><span class="comment">     * If the client is in the middle of a MULTI/EXEC, handle it as it was</span></span><br><span class="line"><span class="comment">     * a short read, even if technically the protocol is correct: we want</span></span><br><span class="line"><span class="comment">     * to remove the unprocessed tail and continue. */</span></span><br><span class="line">    <span class="keyword">if</span> (fakeClient-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        <span class="built_in">serverLog</span>(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Revert incomplete MULTI/EXEC transaction in AOF file&quot;</span>);</span><br><span class="line">        valid_up_to = valid_before_multi;</span><br><span class="line">        <span class="keyword">goto</span> uxeof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">loaded_ok: <span class="comment">/* DB loaded, cleanup and return C_OK to the caller. */</span></span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="built_in">freeFakeClient</span>(fakeClient);</span><br><span class="line">    server.aof_state = old_aof_state;</span><br><span class="line">    <span class="built_in">stopLoading</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">aofUpdateCurrentSize</span>();</span><br><span class="line">    server.aof_rewrite_base_size = server.aof_current_size;</span><br><span class="line">    server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">readerr: <span class="comment">/* Read error. If feof(fp) is true, fall through to unexpected EOF. */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">feof</span>(fp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fakeClient) <span class="built_in">freeFakeClient</span>(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">        <span class="built_in">fclose</span>(fp);</span><br><span class="line">        <span class="built_in">serverLog</span>(LL_WARNING,<span class="string">&quot;Unrecoverable error reading the append only file: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">uxeof: <span class="comment">/* Unexpected AOF end of file. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_load_truncated) &#123;</span><br><span class="line">        <span class="built_in">serverLog</span>(LL_WARNING,<span class="string">&quot;!!! Warning: short read while loading the AOF file !!!&quot;</span>);</span><br><span class="line">        <span class="built_in">serverLog</span>(LL_WARNING,<span class="string">&quot;!!! Truncating the AOF at offset %llu !!!&quot;</span>,</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) valid_up_to);</span><br><span class="line">        <span class="keyword">if</span> (valid_up_to == <span class="number">-1</span> || <span class="built_in">truncate</span>(filename,valid_up_to) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid_up_to == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">serverLog</span>(LL_WARNING,<span class="string">&quot;Last valid command offset is invalid&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">serverLog</span>(LL_WARNING,<span class="string">&quot;Error truncating the AOF file: %s&quot;</span>,</span><br><span class="line">                    <span class="built_in">strerror</span>(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Make sure the AOF file descriptor points to the end of the</span></span><br><span class="line"><span class="comment">             * file after the truncate call. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.aof_fd != <span class="number">-1</span> &amp;&amp; <span class="built_in">lseek</span>(server.aof_fd,<span class="number">0</span>,SEEK_END) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">serverLog</span>(LL_WARNING,<span class="string">&quot;Can&#x27;t seek the end of the AOF file: %s&quot;</span>,</span><br><span class="line">                    <span class="built_in">strerror</span>(errno));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">serverLog</span>(LL_WARNING,</span><br><span class="line">                    <span class="string">&quot;AOF loaded anyway because aof-load-truncated is enabled&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> loaded_ok;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fakeClient) <span class="built_in">freeFakeClient</span>(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="built_in">serverLog</span>(LL_WARNING,<span class="string">&quot;Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;. 2) Alternatively you can set the &#x27;aof-load-truncated&#x27; configuration option to yes and restart the server.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">fmterr: <span class="comment">/* Format error. */</span></span><br><span class="line">    <span class="keyword">if</span> (fakeClient) <span class="built_in">freeFakeClient</span>(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="built_in">serverLog</span>(LL_WARNING,<span class="string">&quot;Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="流程图："><a class="header-anchor" href="#流程图：">¶</a>流程图：</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210318_032504.png" alt=""></p>
<h4 id="aof触发流程："><a class="header-anchor" href="#aof触发流程：">¶</a>aof触发流程：</h4>
<p>参照前面的方法，先找到appendfsync对应的变量，然后看使用场景。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">createEnumConfig</span>(<span class="string">&quot;appendfsync&quot;</span>, <span class="literal">NULL</span>, MODIFIABLE_CONFIG, aof_fsync_enum, server.aof_fsync, AOF_FSYNC_EVERYSEC, <span class="literal">NULL</span>, <span class="literal">NULL</span>),</span><br></pre></td></tr></table></figure>
<h5 id="appendfsync取值"><a class="header-anchor" href="#appendfsync取值">¶</a>appendfsync取值</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">configEnum aof_fsync_enum[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;everysec&quot;</span>, AOF_FSYNC_EVERYSEC&#125;, 每秒</span><br><span class="line">    &#123;<span class="string">&quot;always&quot;</span>, AOF_FSYNC_ALWAYS&#125;, 每个操作</span><br><span class="line">    &#123;<span class="string">&quot;no&quot;</span>, AOF_FSYNC_NO&#125;, 由操作系统决定何时同步</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="aof-fsync-enum哪里用到了？"><a class="header-anchor" href="#aof-fsync-enum哪里用到了？">¶</a>aof_fsync_enum哪里用到了？</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210318_041746.png" alt=""></p>
<h5 id="流程图"><a class="header-anchor" href="#流程图">¶</a>流程图:</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/redis-2021-3-18-22-38.png" alt=""></p>
<h4 id="aof和RDB混用的情况"><a class="header-anchor" href="#aof和RDB混用的情况">¶</a>aof和RDB混用的情况</h4>
<h5 id="配置项"><a class="header-anchor" href="#配置项">¶</a>配置项:</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">aof-use-rdb-preamble  <span class="literal">true</span>/<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">config.c配置:</span><br><span class="line"></span><br><span class="line">createBoolConfig(<span class="string">&quot;aof-use-rdb-preamble&quot;</span>, NULL, MODIFIABLE_CONFIG, server.aof_use_rdb_preamble, <span class="number">1</span>, NULL, NULL),</span><br></pre></td></tr></table></figure>
<h5 id="流程图-v2"><a class="header-anchor" href="#流程图-v2">¶</a>流程图:</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/redis-2021-03-21-23-34.png" alt=""></p>
<h4 id="aof文件如何“高效”持久化"><a class="header-anchor" href="#aof文件如何“高效”持久化">¶</a>aof文件如何“高效”持久化</h4>
<h5 id="如何持久化到硬盘？「flushAppendOnlyFile」"><a class="header-anchor" href="#如何持久化到硬盘？「flushAppendOnlyFile」">¶</a>如何持久化到硬盘？「flushAppendOnlyFile」</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">flushAppendOnlyFile函数</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line"> Write the append only file buffer on disk.</span><br></pre></td></tr></table></figure>
<h5 id="流程图：-v2"><a class="header-anchor" href="#流程图：-v2">¶</a>流程图：</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/acsz8-d5ehw.webp" alt=""></p>
<h4 id="AOF-APPEND-ONLY数据量过大"><a class="header-anchor" href="#AOF-APPEND-ONLY数据量过大">¶</a>AOF APPEND ONLY数据量过大</h4>
<blockquote>
<p>通过源码先看看流程：</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/2022/redis-rewriteAppendOnlyfile.png" alt=""></p>
<h3 id="Tips-And-Tricks"><a class="header-anchor" href="#Tips-And-Tricks">¶</a>Tips And Tricks</h3>
<h4 id="AOF数据量过大问题"><a class="header-anchor" href="#AOF数据量过大问题">¶</a>AOF数据量过大问题</h4>
<h3 id="Todo"><a class="header-anchor" href="#Todo">¶</a>Todo</h3>
<ul>
<li><input type="checkbox" id="checkbox0"><label for="checkbox0">[aof和rdb多维度比较]</label></li>
<li><input type="checkbox" id="checkbox1"><label for="checkbox1">[AOF数据量过大问题]</label></li>
</ul>
<h3 id="End"><a class="header-anchor" href="#End">¶</a>End</h3>
]]></content>
      <tags>
        <tag>Day</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>「42」Git Log常用场景</title>
    <url>/archives/a02f04ba.html</url>
    <content><![CDATA[<h2 id="前序："><a class="header-anchor" href="#前序：">¶</a>前序：</h2>
<p>前面有总结过<a href="https://blog.imrcrab.com/archives/3c1dd822.html">Git常用的一些操作</a></p>
<p>最近有很多使用到git log – 的命令和需求，所以来搞搞这个git log的用法:</p>
<span id="more"></span>
<h2 id="git-log命令基本使用："><a class="header-anchor" href="#git-log命令基本使用：">¶</a>git log命令基本使用：</h2>
<blockquote>
<p>这里用go仓库的log来演示和学习log相关操作。</p>
</blockquote>
<h3 id="版本："><a class="header-anchor" href="#版本：">¶</a>版本：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ git version</span><br><span class="line">git version <span class="number">2.24</span><span class="number">.3</span> (Apple Git<span class="number">-128</span>)</span><br></pre></td></tr></table></figure>
<h3 id="常用及展示："><a class="header-anchor" href="#常用及展示：">¶</a>常用及展示：</h3>
<h4 id="git-log-help"><a class="header-anchor" href="#git-log-help">¶</a>git log --help</h4>
<blockquote>
<p>查看使用方法「划重点」：</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210309_010044.png" alt=""></p>
<p><strong>图中option地方为可选的配置项</strong></p>
<h4 id="git-log"><a class="header-anchor" href="#git-log">¶</a>git log</h4>
<blockquote>
<p>组成部分：</p>
</blockquote>
<ul>
<li>commit ID</li>
<li>author</li>
<li>date</li>
<li>commit message</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210309_125518.png" alt=""></p>
<h4 id="git-log-s"><a class="header-anchor" href="#git-log-s">¶</a>git log --s***</h4>
<blockquote>
<p>git log --s 然后按tab建就可以看到下面的信息，</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --s</span><br><span class="line">--shortstat               -- generate summary diffstat</span><br><span class="line">--show-linear-break       -- show a barrier between commits from different branches</span><br><span class="line">--show-signature          -- validate GPG signature of commit</span><br><span class="line">--simplify-by-decoration  -- show only commits that are referenced by a ref</span><br><span class="line">--simplify-merges         -- milder version of --full-history</span><br><span class="line">--since                   -- show commits more recent than given date</span><br><span class="line">--single-worktree         -- examine the current working tree only</span><br><span class="line">--skip                    -- skip given number of commits before output</span><br><span class="line">--source                  -- show which ref each commit is reached from</span><br><span class="line">--sparse                  -- when paths are given, display only commits that changes any of them</span><br><span class="line">--src-prefix              -- use given prefix for source</span><br><span class="line">--stat                    -- generate diffstat instead of patch</span><br><span class="line">--stdin                   -- additionally read commits from standard input</span><br><span class="line">--submodule               -- select output format for submodule differences</span><br><span class="line">--summary                 -- generate condensed summary of extended header information</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="git-log-stat"><a class="header-anchor" href="#git-log-stat">¶</a>git log --stat</h5>
<blockquote>
<p>可以看到diff的文件信息<br>
<img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210309_010656.png" alt=""></p>
</blockquote>
<h4 id="git-log-pretty"><a class="header-anchor" href="#git-log-pretty">¶</a>git log --pretty=?</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下面命令按下tab自动补全的信息：</span><br><span class="line">$ git log --pretty= </span><br><span class="line">email    -- use email headers like From and Subject</span><br><span class="line">format   -- specify own format</span><br><span class="line">full     -- all parts of commit messages</span><br><span class="line">fuller   -- like full and includes dates</span><br><span class="line">medium   -- most parts of messages</span><br><span class="line">oneline  -- commit-ids and subject of messages</span><br><span class="line">raw      -- the raw commits</span><br><span class="line">short    -- few headers and only subject of messages</span><br></pre></td></tr></table></figure>
<h5 id="git-log-pretty-fuller"><a class="header-anchor" href="#git-log-pretty-fuller">¶</a>git log --pretty=fuller</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210309_011529.png" alt=""></p>
<h4 id="git-log-author"><a class="header-anchor" href="#git-log-author">¶</a>git log --author=?</h4>
<blockquote>
<p>git log --author=“Alex Brainman”</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210309_011728.png" alt=""></p>
<h4 id="合并在一起，所有基本信息："><a class="header-anchor" href="#合并在一起，所有基本信息：">¶</a>合并在一起，所有基本信息：</h4>
<blockquote>
<p>git log --author=“Alex Brainman” --stat --graph --tags --pretty=oneline --decorate</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210309_012016.png" alt=""></p>
<h4 id="某个文件的log"><a class="header-anchor" href="#某个文件的log">¶</a>某个文件的log</h4>
<blockquote>
<p>查看所有src/runtime文件夹的具体提交信息</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log  --stat --graph --tags --pretty=oneline --decorate src/runtime/</span><br></pre></td></tr></table></figure>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210309_012342.png" alt=""></p>
<h5 id="pretty-fuller和pretty-oneline的区别："><a class="header-anchor" href="#pretty-fuller和pretty-oneline的区别：">¶</a>pretty=fuller和pretty=oneline的区别：</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210309_012556.png" alt=""></p>
<h4 id="git-log-before-after"><a class="header-anchor" href="#git-log-before-after">¶</a>git log --before=*** --after=***</h4>
<blockquote>
<p>pretty: oneline VS fuller</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log  --stat --graph --tags --pretty=oneline --before=&quot;2021-03-09&quot; --after=&quot;2020-03-10&quot;  --decorate src/runtime/</span><br><span class="line"></span><br><span class="line">git log  --stat --graph --tags --pretty=fuller --before=&quot;2021-03-09&quot; --after=&quot;2020-03-10&quot; --decorate src/runtime/</span><br></pre></td></tr></table></figure>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210309_013157.png" alt=""></p>
<h3 id="End"><a class="header-anchor" href="#End">¶</a>End</h3>
]]></content>
      <tags>
        <tag>Git</tag>
        <tag>Day</tag>
      </tags>
  </entry>
  <entry>
    <title>「41」关于go中 _ [忽略]的使用</title>
    <url>/archives/9af9679c.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序:</h3>
<ul>
<li>前段时间看了这么个问题,输出是what?:</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(fff(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fff</span><span class="params">(x <span class="type">int</span>)</span></span> (_, __ <span class="type">int</span>) &#123;</span><br><span class="line">	_, __ = x, x</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="结果分析"><a class="header-anchor" href="#结果分析">¶</a>结果分析</h3>
<h4 id="outpus"><a class="header-anchor" href="#outpus">¶</a>outpus:</h4>
<blockquote>
<p>0 1</p>
</blockquote>
<h4 id="汇编分析"><a class="header-anchor" href="#汇编分析">¶</a>汇编分析:</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">▶ go tool compile -N -l -S signore.go </span><br><span class="line"><span class="string">&quot;&quot;</span>.main STEXT size=<span class="number">158</span> args=<span class="number">0x0</span> locals=<span class="number">0x40</span> funcid=<span class="number">0x0</span></span><br><span class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (signore.go:<span class="number">3</span>)     TEXT    <span class="string">&quot;&quot;</span>.main(SB), ABIInternal, $<span class="number">64</span><span class="number">-0</span></span><br><span class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (signore.go:<span class="number">3</span>)     MOVQ    (TLS), CX</span><br><span class="line">        <span class="number">0x0009</span> <span class="number">00009</span> (signore.go:<span class="number">3</span>)     CMPQ    SP, <span class="number">16</span>(CX)</span><br><span class="line">        <span class="number">0x000d</span> <span class="number">00013</span> (signore.go:<span class="number">3</span>)     PCDATA  $<span class="number">0</span>, $<span class="number">-2</span></span><br><span class="line">        <span class="number">0x000d</span> <span class="number">00013</span> (signore.go:<span class="number">3</span>)     JLS     <span class="number">148</span></span><br><span class="line">        <span class="number">0x0013</span> <span class="number">00019</span> (signore.go:<span class="number">3</span>)     PCDATA  $<span class="number">0</span>, $<span class="number">-1</span></span><br><span class="line">        <span class="number">0x0013</span> <span class="number">00019</span> (signore.go:<span class="number">3</span>)     SUBQ    $<span class="number">64</span>, SP</span><br><span class="line">        <span class="number">0x0017</span> <span class="number">00023</span> (signore.go:<span class="number">3</span>)     MOVQ    BP, <span class="number">56</span>(SP)</span><br><span class="line">        <span class="number">0x001c</span> <span class="number">00028</span> (signore.go:<span class="number">3</span>)     LEAQ    <span class="number">56</span>(SP), BP</span><br><span class="line">        <span class="number">0x0021</span> <span class="number">00033</span> (signore.go:<span class="number">3</span>)     FUNCDATA        $<span class="number">0</span>, gclocals·<span class="number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">        <span class="number">0x0021</span> <span class="number">00033</span> (signore.go:<span class="number">3</span>)     FUNCDATA        $<span class="number">1</span>, gclocals·<span class="number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">        <span class="number">0x0021</span> <span class="number">00033</span> (signore.go:<span class="number">4</span>)     MOVQ    $<span class="number">1</span>, (SP)</span><br><span class="line">        <span class="number">0x0029</span> <span class="number">00041</span> (signore.go:<span class="number">4</span>)     PCDATA  $<span class="number">1</span>, $<span class="number">0</span></span><br><span class="line">        <span class="number">0x0029</span> <span class="number">00041</span> (signore.go:<span class="number">4</span>)     CALL    <span class="string">&quot;&quot;</span>.fff(SB)</span><br><span class="line">        <span class="number">0x002e</span> <span class="number">00046</span> (signore.go:<span class="number">4</span>)     MOVQ    <span class="number">8</span>(SP), AX</span><br><span class="line">        <span class="number">0x0033</span> <span class="number">00051</span> (signore.go:<span class="number">4</span>)     MOVQ    <span class="number">16</span>(SP), CX</span><br><span class="line">        <span class="number">0x0038</span> <span class="number">00056</span> (signore.go:<span class="number">4</span>)     MOVQ    AX, <span class="string">&quot;&quot;</span>..autotmp_2+<span class="number">32</span>(SP)</span><br><span class="line">        <span class="number">0x003d</span> <span class="number">00061</span> (signore.go:<span class="number">4</span>)     MOVQ    CX, <span class="string">&quot;&quot;</span>..autotmp_3+<span class="number">24</span>(SP)</span><br><span class="line">        <span class="number">0x0042</span> <span class="number">00066</span> (signore.go:<span class="number">4</span>)     MOVQ    <span class="string">&quot;&quot;</span>..autotmp_2+<span class="number">32</span>(SP), AX</span><br><span class="line">        <span class="number">0x0047</span> <span class="number">00071</span> (signore.go:<span class="number">4</span>)     MOVQ    AX, <span class="string">&quot;&quot;</span>..autotmp_0+<span class="number">48</span>(SP)</span><br><span class="line">        <span class="number">0x004c</span> <span class="number">00076</span> (signore.go:<span class="number">4</span>)     MOVQ    <span class="string">&quot;&quot;</span>..autotmp_3+<span class="number">24</span>(SP), AX</span><br><span class="line">        <span class="number">0x0051</span> <span class="number">00081</span> (signore.go:<span class="number">4</span>)     MOVQ    AX, <span class="string">&quot;&quot;</span>..autotmp_1+<span class="number">40</span>(SP)</span><br><span class="line">        <span class="number">0x0056</span> <span class="number">00086</span> (signore.go:<span class="number">4</span>)     CALL    runtime.printlock(SB)</span><br><span class="line">        <span class="number">0x005b</span> <span class="number">00091</span> (signore.go:<span class="number">4</span>)     MOVQ    <span class="string">&quot;&quot;</span>..autotmp_0+<span class="number">48</span>(SP), AX</span><br><span class="line">        <span class="number">0x0060</span> <span class="number">00096</span> (signore.go:<span class="number">4</span>)     MOVQ    AX, (SP)</span><br><span class="line">        <span class="number">0x0064</span> <span class="number">00100</span> (signore.go:<span class="number">4</span>)     CALL    runtime.printint(SB)</span><br><span class="line">        <span class="number">0x0069</span> <span class="number">00105</span> (signore.go:<span class="number">4</span>)     CALL    runtime.printsp(SB)</span><br><span class="line">        <span class="number">0x006e</span> <span class="number">00110</span> (signore.go:<span class="number">4</span>)     MOVQ    <span class="string">&quot;&quot;</span>..autotmp_1+<span class="number">40</span>(SP), AX</span><br><span class="line">        <span class="number">0x0073</span> <span class="number">00115</span> (signore.go:<span class="number">4</span>)     MOVQ    AX, (SP)</span><br><span class="line">        <span class="number">0x0077</span> <span class="number">00119</span> (signore.go:<span class="number">4</span>)     CALL    runtime.printint(SB)</span><br><span class="line">        <span class="number">0x007c</span> <span class="number">00124</span> (signore.go:<span class="number">4</span>)     NOP</span><br><span class="line">        <span class="number">0x0080</span> <span class="number">00128</span> (signore.go:<span class="number">4</span>)     CALL    runtime.printnl(SB)</span><br><span class="line">        <span class="number">0x0085</span> <span class="number">00133</span> (signore.go:<span class="number">4</span>)     CALL    runtime.printunlock(SB)</span><br><span class="line">        <span class="number">0x008a</span> <span class="number">00138</span> (signore.go:<span class="number">5</span>)     MOVQ    <span class="number">56</span>(SP), BP</span><br><span class="line">        <span class="number">0x008f</span> <span class="number">00143</span> (signore.go:<span class="number">5</span>)     ADDQ    $<span class="number">64</span>, SP</span><br><span class="line">        <span class="number">0x0093</span> <span class="number">00147</span> (signore.go:<span class="number">5</span>)     RET</span><br><span class="line">        <span class="number">0x0094</span> <span class="number">00148</span> (signore.go:<span class="number">5</span>)     NOP</span><br><span class="line">        <span class="number">0x0094</span> <span class="number">00148</span> (signore.go:<span class="number">3</span>)     PCDATA  $<span class="number">1</span>, $<span class="number">-1</span></span><br><span class="line">        <span class="number">0x0094</span> <span class="number">00148</span> (signore.go:<span class="number">3</span>)     PCDATA  $<span class="number">0</span>, $<span class="number">-2</span></span><br><span class="line">        <span class="number">0x0094</span> <span class="number">00148</span> (signore.go:<span class="number">3</span>)     CALL    runtime.morestack_noctxt(SB)</span><br><span class="line">        <span class="number">0x0099</span> <span class="number">00153</span> (signore.go:<span class="number">3</span>)     PCDATA  $<span class="number">0</span>, $<span class="number">-1</span></span><br><span class="line">        <span class="number">0x0099</span> <span class="number">00153</span> (signore.go:<span class="number">3</span>)     JMP     <span class="number">0</span></span><br><span class="line">        <span class="number">0x0000</span> <span class="number">65</span> <span class="number">48</span> <span class="number">8b</span> <span class="number">0</span>c <span class="number">25</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">48</span> <span class="number">3b</span> <span class="number">61</span> <span class="number">10</span> <span class="number">0f</span> <span class="number">86</span> <span class="number">81</span>  eH..%....H;a....</span><br><span class="line">        <span class="number">0x0010</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">48</span> <span class="number">83</span> ec <span class="number">40</span> <span class="number">48</span> <span class="number">89</span> <span class="number">6</span>c <span class="number">24</span> <span class="number">38</span> <span class="number">48</span> <span class="number">8</span>d <span class="number">6</span>c <span class="number">24</span>  ...H..@H.l$<span class="number">8</span>H.l$</span><br><span class="line">        <span class="number">0x0020</span> <span class="number">38</span> <span class="number">48</span> c7 <span class="number">04</span> <span class="number">24</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">48</span> <span class="number">8b</span>  <span class="number">8</span>H..$.........H.</span><br><span class="line">        <span class="number">0x0030</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span> <span class="number">48</span> <span class="number">8b</span> <span class="number">4</span>c <span class="number">24</span> <span class="number">10</span> <span class="number">48</span> <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">20</span> <span class="number">48</span> <span class="number">89</span> <span class="number">4</span>c  D$.H.L$.H.D$ H.L</span><br><span class="line">        <span class="number">0x0040</span> <span class="number">24</span> <span class="number">18</span> <span class="number">48</span> <span class="number">8b</span> <span class="number">44</span> <span class="number">24</span> <span class="number">20</span> <span class="number">48</span> <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">30</span> <span class="number">48</span> <span class="number">8b</span> <span class="number">44</span> <span class="number">24</span>  $.H.D$ H.D$<span class="number">0</span>H.D$</span><br><span class="line">        <span class="number">0x0050</span> <span class="number">18</span> <span class="number">48</span> <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">28</span> e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">48</span> <span class="number">8b</span> <span class="number">44</span> <span class="number">24</span> <span class="number">30</span>  .H.D$(.....H.D$<span class="number">0</span></span><br><span class="line">        <span class="number">0x0060</span> <span class="number">48</span> <span class="number">89</span> <span class="number">04</span> <span class="number">24</span> e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">48</span> <span class="number">8b</span>  H..$..........H.</span><br><span class="line">        <span class="number">0x0070</span> <span class="number">44</span> <span class="number">24</span> <span class="number">28</span> <span class="number">48</span> <span class="number">89</span> <span class="number">04</span> <span class="number">24</span> e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0f</span> <span class="number">1f</span> <span class="number">40</span> <span class="number">00</span>  D$(H..$.......@.</span><br><span class="line">        <span class="number">0x0080</span> e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">48</span> <span class="number">8b</span> <span class="number">6</span>c <span class="number">24</span> <span class="number">38</span> <span class="number">48</span>  ..........H.l$<span class="number">8</span>H</span><br><span class="line">        <span class="number">0x0090</span> <span class="number">83</span> c4 <span class="number">40</span> c3 e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> e9 <span class="number">62</span> ff ff ff        ..@.......b...</span><br><span class="line">        rel <span class="number">5</span>+<span class="number">4</span> t=<span class="number">17</span> TLS+<span class="number">0</span></span><br><span class="line">        rel <span class="number">42</span>+<span class="number">4</span> t=<span class="number">8</span> <span class="string">&quot;&quot;</span>.fff+<span class="number">0</span></span><br><span class="line">        rel <span class="number">87</span>+<span class="number">4</span> t=<span class="number">8</span> runtime.printlock+<span class="number">0</span></span><br><span class="line">        rel <span class="number">101</span>+<span class="number">4</span> t=<span class="number">8</span> runtime.printint+<span class="number">0</span></span><br><span class="line">        rel <span class="number">106</span>+<span class="number">4</span> t=<span class="number">8</span> runtime.printsp+<span class="number">0</span></span><br><span class="line">        rel <span class="number">120</span>+<span class="number">4</span> t=<span class="number">8</span> runtime.printint+<span class="number">0</span></span><br><span class="line">        rel <span class="number">129</span>+<span class="number">4</span> t=<span class="number">8</span> runtime.printnl+<span class="number">0</span></span><br><span class="line">        rel <span class="number">134</span>+<span class="number">4</span> t=<span class="number">8</span> runtime.printunlock+<span class="number">0</span></span><br><span class="line">        rel <span class="number">149</span>+<span class="number">4</span> t=<span class="number">8</span> runtime.morestack_noctxt+<span class="number">0</span></span><br><span class="line"><span class="string">&quot;&quot;</span>.fff STEXT nosplit size=<span class="number">29</span> args=<span class="number">0x18</span> locals=<span class="number">0x0</span> funcid=<span class="number">0x0</span></span><br><span class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (signore.go:<span class="number">7</span>)     TEXT    <span class="string">&quot;&quot;</span>.fff(SB), NOSPLIT|ABIInternal, $<span class="number">0</span><span class="number">-24</span></span><br><span class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (signore.go:<span class="number">7</span>)     FUNCDATA        $<span class="number">0</span>, gclocals·<span class="number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (signore.go:<span class="number">7</span>)     FUNCDATA        $<span class="number">1</span>, gclocals·<span class="number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">        <span class="comment">// ***这个 [~b]很关键,划重点</span></span><br><span class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (signore.go:<span class="number">7</span>)     MOVQ    $<span class="number">0</span>, <span class="string">&quot;&quot;</span>.~b1+<span class="number">16</span>(SP) </span><br><span class="line">        <span class="number">0x0009</span> <span class="number">00009</span> (signore.go:<span class="number">7</span>)     MOVQ    $<span class="number">0</span>, <span class="string">&quot;&quot;</span>.__+<span class="number">24</span>(SP)</span><br><span class="line">        <span class="number">0x0012</span> <span class="number">00018</span> (signore.go:<span class="number">8</span>)     MOVQ    <span class="string">&quot;&quot;</span>.x+<span class="number">8</span>(SP), AX</span><br><span class="line">        <span class="number">0x0017</span> <span class="number">00023</span> (signore.go:<span class="number">8</span>)     MOVQ    AX, <span class="string">&quot;&quot;</span>.__+<span class="number">24</span>(SP)</span><br><span class="line">        <span class="number">0x001c</span> <span class="number">00028</span> (signore.go:<span class="number">9</span>)     RET</span><br><span class="line">        <span class="number">0x0000</span> <span class="number">48</span> c7 <span class="number">44</span> <span class="number">24</span> <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">48</span> c7 <span class="number">44</span> <span class="number">24</span> <span class="number">18</span> <span class="number">00</span> <span class="number">00</span>  H.D$.....H.D$...</span><br><span class="line">        <span class="number">0x0010</span> <span class="number">00</span> <span class="number">00</span> <span class="number">48</span> <span class="number">8b</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span> <span class="number">48</span> <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">18</span> c3           ..H.D$.H.D$..</span><br><span class="line">go.cuinfo.packagename. SDWARFCUINFO dupok size=<span class="number">0</span></span><br><span class="line">        <span class="number">0x0000</span> <span class="number">6</span>d <span class="number">61</span> <span class="number">69</span> <span class="number">6</span>e                                      main</span><br><span class="line"><span class="string">&quot;&quot;</span>..inittask SNOPTRDATA size=<span class="number">24</span></span><br><span class="line">        <span class="number">0x0000</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ................</span><br><span class="line">        <span class="number">0x0010</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                          ........</span><br><span class="line">gclocals·<span class="number">33</span>cdeccccebe80329f1fdbee7f5874cb SRODATA dupok size=<span class="number">8</span></span><br><span class="line">        <span class="number">0x0000</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                          ........</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="为何-就可以忽略返回值呢"><a class="header-anchor" href="#为何-就可以忽略返回值呢">¶</a>为何 _ 就可以忽略返回值呢?</h4>
<blockquote>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/cmd/compile/internal/gc/dcl.go#L426">官方文档</a></p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210302_095628.png" alt=""></p>
<h4 id="调用方"><a class="header-anchor" href="#调用方">¶</a>调用方:</h4>
<ul>
<li>dcl 「参数」</li>
<li>import 「导入」</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210302_100643.png" alt=""></p>
<h5 id="再向上"><a class="header-anchor" href="#再向上">¶</a>再向上:</h5>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/cmd/compile/internal/gc/reflect.go#L1290">–&gt;genhash</a></p>
<h5 id="再向上-v2"><a class="header-anchor" href="#再向上-v2">¶</a>再向上:</h5>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/cmd/compile/internal/gc/pgen.go#L228">—&gt;compile</a></p>
<h5 id="start"><a class="header-anchor" href="#start">¶</a>start:</h5>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/cmd/compile/internal/gc/main.go#L714">—&gt;gc.main</a></p>
<blockquote>
<p>有意思的点: gc.main需要9步,编译在第8步了,前面的有兴趣可自己看看.</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210302_101636.png" alt=""></p>
<h3 id="End"><a class="header-anchor" href="#End">¶</a>End</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>「40」Quick Sort Plus之通用模版</title>
    <url>/archives/359bb4b6.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序:</h3>
<p><a href="https://blog.imrcrab.com/archives/aa75061e.html">「37」Quick Sort快速排序</a>分析过快速排序,之前有个问题一直是个痛点:<br>
自定义结构体排序过程中,还是要写不少逻辑判断代码,可以再抽象点么?<br>
用最少的代码,完全实现结构体按照不通的字段进行排序.</p>
<span id="more"></span>
<p><a href="https://blog.imrcrab.com/archives/aa75061e.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99%E5%81%9A%E6%B3%95%EF%BC%9A">「37节」自定义排序做法:</a></p>
<h3 id="方案设想"><a class="header-anchor" href="#方案设想">¶</a>方案设想:</h3>
<ul>
<li>1、利用reflect反射,传入多个字段的名称,</li>
<li>2、每个字段指定升序或者降序.</li>
<li>3、提供升序或者降序.</li>
</ul>
<h4 id="coding"><a class="header-anchor" href="#coding">¶</a>coding:</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSortAll</span><span class="params">(a []<span class="keyword">interface</span>&#123;&#125;, left, right <span class="type">int</span>, By <span class="keyword">func</span>(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>) []<span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">		mid := partitionAll(a, left, right, By)</span><br><span class="line">		QuickSortAll(a, left, mid<span class="number">-1</span>, By)</span><br><span class="line">		QuickSortAll(a, mid+<span class="number">1</span>, right, By)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partitionAll</span><span class="params">(a []<span class="keyword">interface</span>&#123;&#125;, left <span class="type">int</span>, right <span class="type">int</span>, By <span class="keyword">func</span>(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>) <span class="type">int</span> &#123;</span><br><span class="line">	pivot := a[left]</span><br><span class="line">	<span class="keyword">for</span> ; left &lt; right; &#123;</span><br><span class="line">		<span class="comment">//for ; left &lt; right &amp;&amp; a[right] &gt;= pivot; &#123;</span></span><br><span class="line">		<span class="keyword">for</span> ; left &lt; right &amp;&amp; By(a[right], pivot); &#123;</span><br><span class="line">			right--</span><br><span class="line">		&#125;</span><br><span class="line">		a[left] = a[right]</span><br><span class="line">		<span class="comment">//for ; left &lt; right &amp;&amp; a[left] &lt;= pivot; &#123;</span></span><br><span class="line">		<span class="keyword">for</span> ; left &lt; right &amp;&amp; By(pivot, a[left]); &#123;</span><br><span class="line">			left++</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		a[right] = a[left]</span><br><span class="line">	&#125;</span><br><span class="line">	a[left] = pivot</span><br><span class="line">	<span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="type">string</span></span><br><span class="line">	Age   <span class="type">int</span></span><br><span class="line">	Count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的部分</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	flagResult = <span class="literal">false</span></span><br><span class="line">	SortLow    = - <span class="number">1</span></span><br><span class="line">	SortEquals = <span class="number">0</span></span><br><span class="line">	SortHigh   = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序规则,来源可以自定义</span></span><br><span class="line"><span class="comment">// K: 排序字段 &quot;Count&quot;  v: true--&gt; 小--&gt;大    false--&gt; 大--&gt;小</span></span><br><span class="line"><span class="comment">// 支持多个key，当key对应的值相等时候，则排序取决于第二个key自定义的排序规则。</span></span><br><span class="line"><span class="comment">// eg: 按照Name升序</span></span><br><span class="line"><span class="keyword">var</span> SortingRules = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>&#123;<span class="string">&quot;Name&quot;</span>: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// eg: 按照Name升序,name相同时候,按照age降序.</span></span><br><span class="line"><span class="comment">// var SortingRules = map[string]bool&#123;&quot;Name&quot;: true,&quot;Age&quot; : false&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	isp := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, counter)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; counter; i++ &#123;</span><br><span class="line">		isp = <span class="built_in">append</span>(isp, User&#123;</span><br><span class="line">			Name:  strconv.Itoa(rand.Intn(counter)),</span><br><span class="line">			Age:   i,</span><br><span class="line">			Count: rand.Intn(counter),</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="comment">//isp = append(isp, strconv.Itoa(rand.Intn(counter))+&quot;===&quot;)</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(isp)</span><br><span class="line">	t := time.Now().Unix()</span><br><span class="line">	<span class="comment">// 主要的排序过程</span></span><br><span class="line">	num := QuickSortAll(isp, <span class="number">0</span>, <span class="built_in">len</span>(isp)<span class="number">-1</span>, <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="comment">// 类型不匹配则返回true，无法保证顺序</span></span><br><span class="line">		<span class="keyword">if</span> reflect.ValueOf(a).Kind() != reflect.ValueOf(b).Kind() &#123;</span><br><span class="line">			<span class="keyword">return</span> !flagResult</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sortByRules(a, b, SortingRules)</span><br><span class="line"></span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">	fmt.Println(<span class="string">&quot;耗时：&quot;</span>,time.Now().Unix() - t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sortByRules 自定义排序规则</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortByRules</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;, sortingRules <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	ofType := reflect.ValueOf(a).Kind()</span><br><span class="line">	va := reflect.ValueOf(a)</span><br><span class="line">	vb := reflect.ValueOf(b)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> v, k := <span class="keyword">range</span> sortingRules &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ofType != reflect.Struct &#123;</span><br><span class="line">			<span class="comment">//非结构体，常用的类型</span></span><br><span class="line">			result := typeChooseOfReflect(va, vb, k)</span><br><span class="line">			<span class="keyword">if</span> result == SortEquals &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> result &lt; SortEquals &#123;</span><br><span class="line">				<span class="keyword">return</span> flagResult</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> !flagResult</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> ofType == reflect.Struct &#123;</span><br><span class="line">			<span class="comment">// 结构体比较</span></span><br><span class="line">			of := va.FieldByName(v)</span><br><span class="line">			ofb := vb.FieldByName(v)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> of.Kind() == reflect.Struct || ofb.Kind() == reflect.Struct &#123;</span><br><span class="line">				<span class="keyword">return</span> !flagResult</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> !of.IsValid() || !ofb.IsValid() &#123;</span><br><span class="line">				<span class="keyword">return</span> !flagResult</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			result := typeChooseOfReflect(of, ofb, k)</span><br><span class="line">			<span class="keyword">if</span> result == SortEquals &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> result &lt; SortEquals &#123;</span><br><span class="line">				<span class="keyword">return</span> flagResult</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> !flagResult</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> !flagResult</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typeChooseOfReflect 类型选择映射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeChooseOfReflect</span><span class="params">(valueOfA, valueOfB reflect.Value, flag <span class="type">bool</span>)</span></span> <span class="type">int8</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> flag &#123;</span><br><span class="line">		valueOfA, valueOfB = valueOfB, valueOfA</span><br><span class="line">	&#125;</span><br><span class="line">	kind := valueOfA.Type().Kind()</span><br><span class="line">	<span class="keyword">switch</span> kind &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Bool:</span><br><span class="line">		<span class="keyword">return</span> SortHigh</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</span><br><span class="line">		<span class="keyword">if</span> valueOfA.Int() &lt; valueOfB.Int() &#123;</span><br><span class="line">			<span class="keyword">return</span> SortHigh</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> valueOfA.Int() == valueOfB.Int() &#123;</span><br><span class="line">			<span class="keyword">return</span> SortEquals</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:</span><br><span class="line">		<span class="keyword">if</span> valueOfA.Uint() &lt; valueOfB.Uint() &#123;</span><br><span class="line">			<span class="keyword">return</span> SortHigh</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> valueOfA.Uint() == valueOfB.Uint() &#123;</span><br><span class="line">			<span class="keyword">return</span> SortEquals</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> reflect.Float32, reflect.Float64:</span><br><span class="line">		<span class="keyword">if</span> valueOfA.Float() &lt; valueOfB.Float() &#123;</span><br><span class="line">			<span class="keyword">return</span> SortHigh</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> valueOfA.Float() == valueOfB.Float() &#123;</span><br><span class="line">			<span class="keyword">return</span> SortEquals</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> reflect.String:</span><br><span class="line">		<span class="keyword">return</span> -<span class="type">int8</span>(strings.Compare(valueOfA.String(), valueOfB.String()))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> SortLow</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="outputs"><a class="header-anchor" href="#outputs">¶</a>outputs:</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="number">1</span> <span class="number">0</span> <span class="number">7</span>&#125; &#123;<span class="number">7</span> <span class="number">1</span> <span class="number">9</span>&#125; &#123;<span class="number">1</span> <span class="number">2</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">3</span> <span class="number">0</span>&#125; &#123;<span class="number">6</span> <span class="number">4</span> <span class="number">0</span>&#125; &#123;<span class="number">4</span> <span class="number">5</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">6</span> <span class="number">9</span>&#125; &#123;<span class="number">8</span> <span class="number">7</span> <span class="number">4</span>&#125; &#123;<span class="number">1</span> <span class="number">8</span> <span class="number">5</span>&#125; &#123;<span class="number">7</span> <span class="number">9</span> <span class="number">6</span>&#125;]</span><br><span class="line">[&#123;<span class="number">1</span> <span class="number">0</span> <span class="number">7</span>&#125; &#123;<span class="number">1</span> <span class="number">8</span> <span class="number">5</span>&#125; &#123;<span class="number">1</span> <span class="number">2</span> <span class="number">8</span>&#125; &#123;<span class="number">2</span> <span class="number">6</span> <span class="number">9</span>&#125; &#123;<span class="number">4</span> <span class="number">5</span> <span class="number">1</span>&#125; &#123;<span class="number">5</span> <span class="number">3</span> <span class="number">0</span>&#125; &#123;<span class="number">6</span> <span class="number">4</span> <span class="number">0</span>&#125; &#123;<span class="number">7</span> <span class="number">1</span> <span class="number">9</span>&#125; &#123;<span class="number">7</span> <span class="number">9</span> <span class="number">6</span>&#125; &#123;<span class="number">8</span> <span class="number">7</span> <span class="number">4</span>&#125;]</span><br><span class="line">耗时： <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="修改自定义规则"><a class="header-anchor" href="#修改自定义规则">¶</a>修改自定义规则:</h4>
<h5 id="多个规则排序"><a class="header-anchor" href="#多个规则排序">¶</a>多个规则排序</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eg: 按照Name升序,name相同时候,按照age降序.</span></span><br><span class="line"><span class="comment">// var SortingRules = map[string]bool&#123;&quot;Name&quot;: true,&quot;Age&quot; : false&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="outputs-v2"><a class="header-anchor" href="#outputs-v2">¶</a>outputs:</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="number">1</span> <span class="number">0</span> <span class="number">7</span>&#125; &#123;<span class="number">7</span> <span class="number">1</span> <span class="number">9</span>&#125; &#123;<span class="number">1</span> <span class="number">2</span> <span class="number">8</span>&#125; &#123;<span class="number">5</span> <span class="number">3</span> <span class="number">0</span>&#125; &#123;<span class="number">6</span> <span class="number">4</span> <span class="number">0</span>&#125; &#123;<span class="number">4</span> <span class="number">5</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">6</span> <span class="number">9</span>&#125; &#123;<span class="number">8</span> <span class="number">7</span> <span class="number">4</span>&#125; &#123;<span class="number">1</span> <span class="number">8</span> <span class="number">5</span>&#125; &#123;<span class="number">7</span> <span class="number">9</span> <span class="number">6</span>&#125;]</span><br><span class="line">[&#123;<span class="number">1</span> <span class="number">8</span> <span class="number">5</span>&#125; &#123;<span class="number">1</span> <span class="number">2</span> <span class="number">8</span>&#125; &#123;<span class="number">1</span> <span class="number">0</span> <span class="number">7</span>&#125; &#123;<span class="number">2</span> <span class="number">6</span> <span class="number">9</span>&#125; &#123;<span class="number">4</span> <span class="number">5</span> <span class="number">1</span>&#125; &#123;<span class="number">5</span> <span class="number">3</span> <span class="number">0</span>&#125; &#123;<span class="number">6</span> <span class="number">4</span> <span class="number">0</span>&#125; &#123;<span class="number">7</span> <span class="number">9</span> <span class="number">6</span>&#125; &#123;<span class="number">7</span> <span class="number">1</span> <span class="number">9</span>&#125; &#123;<span class="number">8</span> <span class="number">7</span> <span class="number">4</span>&#125;]</span><br><span class="line">耗时： <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h5 id="常见类型排序"><a class="header-anchor" href="#常见类型排序">¶</a>常见类型排序:</h5>
<p>修改重要部分:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// K: 排序字段 &quot;Count&quot;  v: true--&gt; 小--&gt;大    false--&gt; 大--&gt;小</span></span><br><span class="line"><span class="comment">// 支持多个key，当key对应的值相等时候，则排序取决于第二个key自定义的排序规则.(多个kv以第一个为准「仅在基本类型下有效」)</span></span><br><span class="line"><span class="comment">// eg: string类型排序,则key值为任意,value值决定排序规则,</span></span><br><span class="line"><span class="keyword">var</span> SortingRules = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>&#123;<span class="string">&quot;&quot;</span>: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	isp := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, counter)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; counter; i++ &#123;</span><br><span class="line">		<span class="comment">/*isp = append(isp, User&#123;</span></span><br><span class="line"><span class="comment">			Name:  strconv.Itoa(rand.Intn(counter)),</span></span><br><span class="line"><span class="comment">			Age:   i,</span></span><br><span class="line"><span class="comment">			Count: rand.Intn(counter),</span></span><br><span class="line"><span class="comment">		&#125;)*/</span></span><br><span class="line">        <span class="comment">//***** string类型排序 *****</span></span><br><span class="line">		isp = <span class="built_in">append</span>(isp, strconv.Itoa(rand.Intn(counter))+<span class="string">&quot;===&quot;</span>)</span><br><span class="line">        <span class="comment">//***** int类型排序 *****</span></span><br><span class="line">		<span class="comment">// isp = append(isp, rand.Intn(counter))</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(isp)</span><br><span class="line">	t := time.Now().Unix()</span><br><span class="line">	<span class="comment">// 主要的排序过程</span></span><br><span class="line">	num := QuickSortAll(isp, <span class="number">0</span>, <span class="built_in">len</span>(isp)<span class="number">-1</span>, <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="comment">// 类型不匹配则返回true，无法保证顺序</span></span><br><span class="line">		<span class="keyword">if</span> reflect.ValueOf(a).Kind() != reflect.ValueOf(b).Kind() &#123;</span><br><span class="line">			<span class="keyword">return</span> !flagResult</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sortByRules(a, b, SortingRules)</span><br><span class="line"></span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">	fmt.Println(<span class="string">&quot;耗时：&quot;</span>,time.Now().Unix() - t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="outputs-v3"><a class="header-anchor" href="#outputs-v3">¶</a>outputs:</h5>
<ul>
<li>string类型:</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>=== <span class="number">7</span>=== <span class="number">7</span>=== <span class="number">9</span>=== <span class="number">1</span>=== <span class="number">8</span>=== <span class="number">5</span>=== <span class="number">0</span>=== <span class="number">6</span>=== <span class="number">0</span>===]</span><br><span class="line">[<span class="number">0</span>=== <span class="number">0</span>=== <span class="number">1</span>=== <span class="number">1</span>=== <span class="number">5</span>=== <span class="number">6</span>=== <span class="number">7</span>=== <span class="number">7</span>=== <span class="number">8</span>=== <span class="number">9</span>===]</span><br><span class="line">耗时： <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>int类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">7</span> <span class="number">7</span> <span class="number">9</span> <span class="number">1</span> <span class="number">8</span> <span class="number">5</span> <span class="number">0</span> <span class="number">6</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">耗时： <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结:</h3>
<p>到这里也就差不多该结束了,基本和常用的就这么多了,其它需要扩充的后续再补充.</p>
<ul>
<li>优化点:
<ul>
<li>字段名称不区分大小写</li>
</ul>
</li>
</ul>
<h3 id="End"><a class="header-anchor" href="#End">¶</a>End</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>「39」Go select源码实现分析</title>
    <url>/archives/e1051649.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p>关于Go中select的特性，很多坑，也容易栽。</p>
<p>好奇底层 到计算机层面到底是如何处理的？！</p>
<p>如果有Go的相关经验，就晓得select经常性配合chan一起来使用，<br>
有个问题：线程安全吗？ 多个case到底是如何选择的？ 随机么？why?</p>
<span id="more"></span>
<h3 id="version"><a class="header-anchor" href="#version">¶</a>version</h3>
<blockquote>
<p>go version 1.14</p>
</blockquote>
<h3 id="简单使用"><a class="header-anchor" href="#简单使用">¶</a>简单使用</h3>
<blockquote>
<p>例1:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SelectGo</span><span class="params">(cc, end <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> cc &lt;- x:</span><br><span class="line">			x, y = y, x+y</span><br><span class="line">		<span class="keyword">case</span> &lt;-end:</span><br><span class="line">			fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的结构会等待 cc &lt;- x或者 &lt;-end两个任意一个返回，无论哪个表达式返回都会立刻执行case的代码块。</p>
</blockquote>
<blockquote>
<p>当select中的两个case都满足条件，那就随机触发其中一个。</p>
</blockquote>
<h4 id="汇编实现："><a class="header-anchor" href="#汇编实现：">¶</a>汇编实现：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> tool compile -N -l -S sselect.<span class="keyword">go</span> </span><br><span class="line"><span class="string">&quot;&quot;</span>.SelectGo STEXT size=<span class="number">490</span> args=<span class="number">0x10</span> locals=<span class="number">0xf0</span> funcid=<span class="number">0x0</span> </span><br><span class="line">        <span class="comment">// SelectGo 函数</span></span><br><span class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     TEXT    <span class="string">&quot;&quot;</span>.SelectGo(SB), ABIInternal, $<span class="number">240</span><span class="number">-16</span></span><br><span class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     MOVQ    (TLS), CX</span><br><span class="line">        <span class="number">0x0009</span> <span class="number">00009</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     LEAQ    <span class="number">-112</span>(SP), AX</span><br><span class="line">        <span class="number">0x000e</span> <span class="number">00014</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     CMPQ    AX, <span class="number">16</span>(CX)</span><br><span class="line">        <span class="number">0x0012</span> <span class="number">00018</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     PCDATA  $<span class="number">0</span>, $<span class="number">-2</span></span><br><span class="line">        <span class="number">0x0012</span> <span class="number">00018</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     JLS     <span class="number">480</span></span><br><span class="line">        <span class="number">0x0018</span> <span class="number">00024</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     PCDATA  $<span class="number">0</span>, $<span class="number">-1</span></span><br><span class="line">        <span class="number">0x0018</span> <span class="number">00024</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     SUBQ    $<span class="number">240</span>, SP</span><br><span class="line">        <span class="number">0x001f</span> <span class="number">00031</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     MOVQ    BP, <span class="number">232</span>(SP)</span><br><span class="line">        <span class="number">0x0027</span> <span class="number">00039</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     LEAQ    <span class="number">232</span>(SP), BP</span><br><span class="line">        <span class="number">0x002f</span> <span class="number">00047</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     FUNCDATA        $<span class="number">0</span>, gclocals·dc9b0298814590ca3ffc3a889546fc8b(SB)</span><br><span class="line">        <span class="number">0x002f</span> <span class="number">00047</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     FUNCDATA        $<span class="number">1</span>, gclocals·<span class="number">90105</span>ebf2cf472b05305b6351ad183b7(SB)</span><br><span class="line">        <span class="number">0x002f</span> <span class="number">00047</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     FUNCDATA        $<span class="number">2</span>, <span class="string">&quot;&quot;</span>.SelectGo.stkobj(SB)</span><br><span class="line">        <span class="number">0x002f</span> <span class="number">00047</span> (sselect.<span class="keyword">go</span>:<span class="number">6</span>)     MOVQ    $<span class="number">0</span>, <span class="string">&quot;&quot;</span>.x+<span class="number">80</span>(SP)</span><br><span class="line">        <span class="number">0x0038</span> <span class="number">00056</span> (sselect.<span class="keyword">go</span>:<span class="number">6</span>)     MOVQ    $<span class="number">1</span>, <span class="string">&quot;&quot;</span>.y+<span class="number">72</span>(SP)</span><br><span class="line">        <span class="number">0x0041</span> <span class="number">00065</span> (sselect.<span class="keyword">go</span>:<span class="number">7</span>)     JMP     <span class="number">67</span></span><br><span class="line">        <span class="number">0x0043</span> <span class="number">00067</span> (sselect.<span class="keyword">go</span>:<span class="number">9</span>)     JMP     <span class="number">69</span></span><br><span class="line">        <span class="number">0x0045</span> <span class="number">00069</span> (sselect.<span class="keyword">go</span>:<span class="number">9</span>)     MOVQ    <span class="string">&quot;&quot;</span>.c+<span class="number">248</span>(SP), AX</span><br><span class="line">        <span class="number">0x004d</span> <span class="number">00077</span> (sselect.<span class="keyword">go</span>:<span class="number">9</span>)     MOVQ    AX, <span class="string">&quot;&quot;</span>..autotmp_4+<span class="number">128</span>(SP)</span><br><span class="line">        <span class="number">0x0055</span> <span class="number">00085</span> (sselect.<span class="keyword">go</span>:<span class="number">9</span>)     MOVQ    <span class="string">&quot;&quot;</span>.x+<span class="number">80</span>(SP), AX</span><br><span class="line">        <span class="number">0x005a</span> <span class="number">00090</span> (sselect.<span class="keyword">go</span>:<span class="number">9</span>)     MOVQ    AX, <span class="string">&quot;&quot;</span>..autotmp_5+<span class="number">96</span>(SP)</span><br><span class="line">        <span class="number">0x005f</span> <span class="number">00095</span> (sselect.<span class="keyword">go</span>:<span class="number">11</span>)    MOVQ    <span class="string">&quot;&quot;</span>.quit+<span class="number">256</span>(SP), AX</span><br><span class="line">        <span class="number">0x0067</span> <span class="number">00103</span> (sselect.<span class="keyword">go</span>:<span class="number">11</span>)    MOVQ    AX, <span class="string">&quot;&quot;</span>..autotmp_6+<span class="number">120</span>(SP)</span><br><span class="line">        <span class="number">0x006c</span> <span class="number">00108</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     XORPS   X0, X0</span><br><span class="line">        <span class="number">0x006f</span> <span class="number">00111</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     MOVUPS  X0, <span class="string">&quot;&quot;</span>..autotmp_8+<span class="number">200</span>(SP)</span><br><span class="line">        <span class="number">0x0077</span> <span class="number">00119</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     MOVUPS  X0, <span class="string">&quot;&quot;</span>..autotmp_8+<span class="number">216</span>(SP)</span><br><span class="line">        <span class="number">0x007f</span> <span class="number">00127</span> (sselect.<span class="keyword">go</span>:<span class="number">9</span>)     MOVQ    <span class="string">&quot;&quot;</span>..autotmp_4+<span class="number">128</span>(SP), AX</span><br><span class="line">        <span class="number">0x0087</span> <span class="number">00135</span> (sselect.<span class="keyword">go</span>:<span class="number">9</span>)     MOVQ    AX, <span class="string">&quot;&quot;</span>..autotmp_8+<span class="number">200</span>(SP)</span><br><span class="line">        <span class="number">0x008f</span> <span class="number">00143</span> (sselect.<span class="keyword">go</span>:<span class="number">9</span>)     LEAQ    <span class="string">&quot;&quot;</span>..autotmp_5+<span class="number">96</span>(SP), AX</span><br><span class="line">        <span class="number">0x0094</span> <span class="number">00148</span> (sselect.<span class="keyword">go</span>:<span class="number">9</span>)     MOVQ    AX, <span class="string">&quot;&quot;</span>..autotmp_8+<span class="number">208</span>(SP)</span><br><span class="line">        <span class="number">0x009c</span> <span class="number">00156</span> (sselect.<span class="keyword">go</span>:<span class="number">11</span>)    MOVQ    <span class="string">&quot;&quot;</span>..autotmp_6+<span class="number">120</span>(SP), AX</span><br><span class="line">        <span class="number">0x00a1</span> <span class="number">00161</span> (sselect.<span class="keyword">go</span>:<span class="number">11</span>)    MOVQ    AX, <span class="string">&quot;&quot;</span>..autotmp_8+<span class="number">216</span>(SP)</span><br><span class="line">        <span class="number">0x00a9</span> <span class="number">00169</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     LEAQ    <span class="string">&quot;&quot;</span>..autotmp_8+<span class="number">200</span>(SP), AX</span><br><span class="line">        <span class="number">0x00b1</span> <span class="number">00177</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     MOVQ    AX, <span class="string">&quot;&quot;</span>..autotmp_12+<span class="number">152</span>(SP)</span><br><span class="line">        <span class="number">0x00b9</span> <span class="number">00185</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     LEAQ    <span class="string">&quot;&quot;</span>..autotmp_9+<span class="number">88</span>(SP), AX</span><br><span class="line">        <span class="number">0x00be</span> <span class="number">00190</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     MOVQ    AX, <span class="string">&quot;&quot;</span>..autotmp_13+<span class="number">144</span>(SP)</span><br><span class="line">        <span class="number">0x00c6</span> <span class="number">00198</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     MOVQ    <span class="string">&quot;&quot;</span>..autotmp_12+<span class="number">152</span>(SP), CX</span><br><span class="line">        <span class="number">0x00ce</span> <span class="number">00206</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     MOVQ    CX, (SP)</span><br><span class="line">        <span class="number">0x00d2</span> <span class="number">00210</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     MOVQ    AX, <span class="number">8</span>(SP)</span><br><span class="line">        <span class="number">0x00d7</span> <span class="number">00215</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     MOVQ    $<span class="number">0</span>, <span class="number">16</span>(SP)</span><br><span class="line">        <span class="number">0x00e0</span> <span class="number">00224</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     MOVQ    $<span class="number">1</span>, <span class="number">24</span>(SP)</span><br><span class="line">        <span class="number">0x00e9</span> <span class="number">00233</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     MOVQ    $<span class="number">1</span>, <span class="number">32</span>(SP)</span><br><span class="line">        <span class="number">0x00f2</span> <span class="number">00242</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     MOVB    $<span class="number">1</span>, <span class="number">40</span>(SP)</span><br><span class="line">        <span class="number">0x00f7</span> <span class="number">00247</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     PCDATA  $<span class="number">1</span>, $<span class="number">0</span></span><br><span class="line">        <span class="number">0x00f7</span> <span class="number">00247</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     CALL    runtime.selectgo(SB)</span><br><span class="line">        <span class="number">0x00fc</span> <span class="number">00252</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     MOVQ    <span class="number">48</span>(SP), AX</span><br><span class="line">        <span class="number">0x0101</span> <span class="number">00257</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     MOVBLZX <span class="number">56</span>(SP), CX</span><br><span class="line">        <span class="number">0x0106</span> <span class="number">00262</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     MOVQ    AX, <span class="string">&quot;&quot;</span>..autotmp_10+<span class="number">112</span>(SP)</span><br><span class="line">        <span class="number">0x010b</span> <span class="number">00267</span> (sselect.<span class="keyword">go</span>:<span class="number">8</span>)     MOVB    CL, <span class="string">&quot;&quot;</span>..autotmp_11+<span class="number">71</span>(SP)</span><br><span class="line">        <span class="number">0x010f</span> <span class="number">00271</span> (sselect.<span class="keyword">go</span>:<span class="number">9</span>)     CMPQ    <span class="string">&quot;&quot;</span>..autotmp_10+<span class="number">112</span>(SP), $<span class="number">0</span></span><br><span class="line">        <span class="number">0x0115</span> <span class="number">00277</span> (sselect.<span class="keyword">go</span>:<span class="number">9</span>)     JEQ     <span class="number">281</span></span><br><span class="line">        <span class="number">0x0117</span> <span class="number">00279</span> (sselect.<span class="keyword">go</span>:<span class="number">9</span>)     JMP     <span class="number">327</span></span><br><span class="line">        <span class="number">0x0119</span> <span class="number">00281</span> (sselect.<span class="keyword">go</span>:<span class="number">10</span>)    MOVQ    <span class="string">&quot;&quot;</span>.x+<span class="number">80</span>(SP), AX</span><br><span class="line">        <span class="number">0x011e</span> <span class="number">00286</span> (sselect.<span class="keyword">go</span>:<span class="number">10</span>)    ADDQ    <span class="string">&quot;&quot;</span>.y+<span class="number">72</span>(SP), AX</span><br><span class="line">        <span class="number">0x0123</span> <span class="number">00291</span> (sselect.<span class="keyword">go</span>:<span class="number">10</span>)    MOVQ    AX, <span class="string">&quot;&quot;</span>..autotmp_14+<span class="number">104</span>(SP)</span><br><span class="line">        <span class="number">0x0128</span> <span class="number">00296</span> (sselect.<span class="keyword">go</span>:<span class="number">10</span>)    MOVQ    <span class="string">&quot;&quot;</span>.y+<span class="number">72</span>(SP), AX</span><br><span class="line">        <span class="number">0x012d</span> <span class="number">00301</span> (sselect.<span class="keyword">go</span>:<span class="number">10</span>)    MOVQ    AX, <span class="string">&quot;&quot;</span>.x+<span class="number">80</span>(SP)</span><br><span class="line">        <span class="number">0x0132</span> <span class="number">00306</span> (sselect.<span class="keyword">go</span>:<span class="number">10</span>)    MOVQ    <span class="string">&quot;&quot;</span>..autotmp_14+<span class="number">104</span>(SP), AX</span><br><span class="line">        <span class="number">0x0137</span> <span class="number">00311</span> (sselect.<span class="keyword">go</span>:<span class="number">10</span>)    MOVQ    AX, <span class="string">&quot;&quot;</span>.y+<span class="number">72</span>(SP)</span><br><span class="line">        <span class="number">0x013c</span> <span class="number">00316</span> (sselect.<span class="keyword">go</span>:<span class="number">9</span>)     JMP     <span class="number">318</span></span><br><span class="line">        <span class="number">0x013e</span> <span class="number">00318</span> (sselect.<span class="keyword">go</span>:<span class="number">9</span>)     PCDATA  $<span class="number">1</span>, $<span class="number">-1</span></span><br><span class="line">        <span class="number">0x013e</span> <span class="number">00318</span> (sselect.<span class="keyword">go</span>:<span class="number">9</span>)     NOP</span><br><span class="line">        <span class="number">0x0140</span> <span class="number">00320</span> (sselect.<span class="keyword">go</span>:<span class="number">9</span>)     JMP     <span class="number">322</span></span><br><span class="line">        <span class="number">0x0142</span> <span class="number">00322</span> (sselect.<span class="keyword">go</span>:<span class="number">9</span>)     JMP     <span class="number">67</span></span><br><span class="line">        <span class="number">0x0147</span> <span class="number">00327</span> (sselect.<span class="keyword">go</span>:<span class="number">11</span>)    CMPQ    <span class="string">&quot;&quot;</span>..autotmp_10+<span class="number">112</span>(SP), $<span class="number">1</span></span><br><span class="line">        <span class="number">0x014d</span> <span class="number">00333</span> (sselect.<span class="keyword">go</span>:<span class="number">11</span>)    JEQ     <span class="number">340</span></span><br><span class="line">        <span class="number">0x014f</span> <span class="number">00335</span> (sselect.<span class="keyword">go</span>:<span class="number">11</span>)    JMP     <span class="number">478</span></span><br><span class="line">        <span class="number">0x0154</span> <span class="number">00340</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    XORPS   X0, X0</span><br><span class="line">        <span class="number">0x0157</span> <span class="number">00343</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    MOVUPS  X0, <span class="string">&quot;&quot;</span>..autotmp_7+<span class="number">160</span>(SP)</span><br><span class="line">        <span class="number">0x015f</span> <span class="number">00351</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    LEAQ    <span class="string">&quot;&quot;</span>..autotmp_7+<span class="number">160</span>(SP), AX</span><br><span class="line">        <span class="number">0x0167</span> <span class="number">00359</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    MOVQ    AX, <span class="string">&quot;&quot;</span>..autotmp_16+<span class="number">136</span>(SP)</span><br><span class="line">        <span class="number">0x016f</span> <span class="number">00367</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    TESTB   AL, (AX)</span><br><span class="line">        <span class="number">0x0171</span> <span class="number">00369</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    LEAQ    <span class="keyword">type</span>.<span class="type">string</span>(SB), CX</span><br><span class="line">        <span class="number">0x0178</span> <span class="number">00376</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    MOVQ    CX, <span class="string">&quot;&quot;</span>..autotmp_7+<span class="number">160</span>(SP)</span><br><span class="line">        <span class="number">0x0180</span> <span class="number">00384</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    LEAQ    <span class="string">&quot;&quot;</span>..stmp_0(SB), CX</span><br><span class="line">        <span class="number">0x0187</span> <span class="number">00391</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    MOVQ    CX, <span class="string">&quot;&quot;</span>..autotmp_7+<span class="number">168</span>(SP)</span><br><span class="line">        <span class="number">0x018f</span> <span class="number">00399</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    TESTB   AL, (AX)</span><br><span class="line">        <span class="number">0x0191</span> <span class="number">00401</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    JMP     <span class="number">403</span></span><br><span class="line">        <span class="number">0x0193</span> <span class="number">00403</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    MOVQ    AX, <span class="string">&quot;&quot;</span>..autotmp_15+<span class="number">176</span>(SP)</span><br><span class="line">        <span class="number">0x019b</span> <span class="number">00411</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    MOVQ    $<span class="number">1</span>, <span class="string">&quot;&quot;</span>..autotmp_15+<span class="number">184</span>(SP)</span><br><span class="line">        <span class="number">0x01a7</span> <span class="number">00423</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    MOVQ    $<span class="number">1</span>, <span class="string">&quot;&quot;</span>..autotmp_15+<span class="number">192</span>(SP)</span><br><span class="line">        <span class="number">0x01b3</span> <span class="number">00435</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    MOVQ    AX, (SP)</span><br><span class="line">        <span class="number">0x01b7</span> <span class="number">00439</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    MOVQ    $<span class="number">1</span>, <span class="number">8</span>(SP)</span><br><span class="line">        <span class="number">0x01c0</span> <span class="number">00448</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    MOVQ    $<span class="number">1</span>, <span class="number">16</span>(SP)</span><br><span class="line">        <span class="number">0x01c9</span> <span class="number">00457</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    PCDATA  $<span class="number">1</span>, $<span class="number">1</span></span><br><span class="line">        <span class="number">0x01c9</span> <span class="number">00457</span> (sselect.<span class="keyword">go</span>:<span class="number">12</span>)    CALL    fmt.Println(SB)</span><br><span class="line">        <span class="number">0x01ce</span> <span class="number">00462</span> (sselect.<span class="keyword">go</span>:<span class="number">13</span>)    MOVQ    <span class="number">232</span>(SP), BP</span><br><span class="line">        <span class="number">0x01d6</span> <span class="number">00470</span> (sselect.<span class="keyword">go</span>:<span class="number">13</span>)    ADDQ    $<span class="number">240</span>, SP</span><br><span class="line">        <span class="number">0x01dd</span> <span class="number">00477</span> (sselect.<span class="keyword">go</span>:<span class="number">13</span>)    RET</span><br><span class="line">        <span class="number">0x01de</span> <span class="number">00478</span> (sselect.<span class="keyword">go</span>:<span class="number">11</span>)    PCDATA  $<span class="number">1</span>, $<span class="number">-1</span></span><br><span class="line">        <span class="number">0x01de</span> <span class="number">00478</span> (sselect.<span class="keyword">go</span>:<span class="number">11</span>)    XCHGL   AX, AX</span><br><span class="line">        <span class="number">0x01df</span> <span class="number">00479</span> (sselect.<span class="keyword">go</span>:<span class="number">11</span>)    NOP</span><br><span class="line">        <span class="number">0x01df</span> <span class="number">00479</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     PCDATA  $<span class="number">1</span>, $<span class="number">-1</span></span><br><span class="line">        <span class="number">0x01df</span> <span class="number">00479</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     PCDATA  $<span class="number">0</span>, $<span class="number">-2</span></span><br><span class="line">        <span class="number">0x01df</span> <span class="number">00479</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     NOP</span><br><span class="line">        <span class="number">0x01e0</span> <span class="number">00480</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     CALL    runtime.morestack_noctxt(SB)</span><br><span class="line">        <span class="number">0x01e5</span> <span class="number">00485</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     PCDATA  $<span class="number">0</span>, $<span class="number">-1</span></span><br><span class="line">        <span class="number">0x01e5</span> <span class="number">00485</span> (sselect.<span class="keyword">go</span>:<span class="number">5</span>)     JMP     <span class="number">0</span></span><br><span class="line">        ......</span><br><span class="line">        ....</span><br><span class="line">        ...</span><br><span class="line">        ..</span><br><span class="line">        .</span><br></pre></td></tr></table></figure>
<h3 id="场景"><a class="header-anchor" href="#场景">¶</a>场景</h3>
<h4 id="非阻塞式："><a class="header-anchor" href="#非阻塞式：">¶</a>非阻塞式：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> i := &lt;-ch:</span><br><span class="line">		<span class="built_in">println</span>(i)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="keyword">default</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>select同时监听多个case是否可执行，如果多个case不可执行，有default就执行。</p>
</blockquote>
<h4 id="随机执行"><a class="header-anchor" href="#随机执行">¶</a>随机执行</h4>
<blockquote>
<p>关于下面的程序到底是打印什么？</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="keyword">range</span> time.Tick(<span class="number">1</span> * time.Second) &#123;</span><br><span class="line">			ch &lt;- <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ch:</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;case1&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> &lt;-ch:</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;case2&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="outputs"><a class="header-anchor" href="#outputs">¶</a>outputs:</h5>
<ul>
<li>随机性</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">case1</span><br><span class="line">case2</span><br><span class="line">case1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="正题：为何是随机？"><a class="header-anchor" href="#正题：为何是随机？">¶</a>正题：为何是随机？</h3>
<h4 id="select-case的结构"><a class="header-anchor" href="#select-case的结构">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/select.go#L29">select case的结构</a></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> scase <span class="keyword">struct</span> &#123;</span><br><span class="line">	c           *hchan         <span class="comment">// chan</span></span><br><span class="line">	elem        unsafe.Pointer <span class="comment">// data element</span></span><br><span class="line">	kind        <span class="type">uint16</span></span><br><span class="line">	pc          <span class="type">uintptr</span> <span class="comment">// race pc (for race detector / msan)</span></span><br><span class="line">	releasetime <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现原理"><a class="header-anchor" href="#实现原理">¶</a>实现原理</h4>
<ul>
<li>go对于中间代码会有部分的优化： <a href="https://github.com/golang/go/blob/release-branch.go1.14/src/cmd/compile/internal/gc/select.go#L108">walkselectcases</a></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkselectcases</span><span class="params">(cases *Nodes)</span></span> []*Node &#123;</span><br><span class="line">	ncas := cases.Len()</span><br><span class="line">	sellineno := lineno</span><br><span class="line"></span><br><span class="line">	<span class="comment">// optimization: zero-case select 没有case的情况</span></span><br><span class="line">	<span class="keyword">if</span> ncas == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []*Node&#123;mkcall(<span class="string">&quot;block&quot;</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// optimization: one-case select: single op.</span></span><br><span class="line">	<span class="keyword">if</span> ncas == <span class="number">1</span> &#123;</span><br><span class="line">        ..........</span><br><span class="line">        ........</span><br><span class="line">        ......</span><br><span class="line">        ...</span><br><span class="line">        ..</span><br><span class="line">        .</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="随机化原因？"><a class="header-anchor" href="#随机化原因？">¶</a>随机化原因？</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210223_052947.png" alt=""></p>
<ul>
<li>关于fastrandn后面单独分析吧，还挺有意思的。</li>
</ul>
<h5 id="没有case-单单一个select情况"><a class="header-anchor" href="#没有case-单单一个select情况">¶</a>没有case,单单一个select情况:</h5>
<blockquote>
<p>前几行就写的很清楚了。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">block</span><span class="params">()</span></span> &#123;</span><br><span class="line">	gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonSelectNoCases, traceEvGoStop, <span class="number">1</span>) <span class="comment">// forever</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="多看一步："><a class="header-anchor" href="#多看一步：">¶</a>多看一步：</h6>
<ul>
<li>waitReasonSelectNoCases干嘛的？</li>
</ul>
<p>这里逻列了g wait的所有情况，有什么用，不是这次研究的重点！<br>
有兴趣可以下来查查，看看哪里都用到了。<br>
<a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/runtime2.go#L948">链接🔗</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	waitReasonZero                  waitReason = <span class="literal">iota</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line">	waitReasonGCAssistMarking                         <span class="comment">// &quot;GC assist marking&quot;</span></span><br><span class="line">	waitReasonIOWait                                  <span class="comment">// &quot;IO wait&quot;</span></span><br><span class="line">	waitReasonChanReceiveNilChan                      <span class="comment">// &quot;chan receive (nil chan)&quot;</span></span><br><span class="line">	waitReasonChanSendNilChan                         <span class="comment">// &quot;chan send (nil chan)&quot;</span></span><br><span class="line">	waitReasonDumpingHeap                             <span class="comment">// &quot;dumping heap&quot;</span></span><br><span class="line">	waitReasonGarbageCollection                       <span class="comment">// &quot;garbage collection&quot;</span></span><br><span class="line">	waitReasonGarbageCollectionScan                   <span class="comment">// &quot;garbage collection scan&quot;</span></span><br><span class="line">	waitReasonPanicWait                               <span class="comment">// &quot;panicwait&quot;</span></span><br><span class="line">	waitReasonSelect                                  <span class="comment">// &quot;select&quot;</span></span><br><span class="line">	waitReasonSelectNoCases                           <span class="comment">// &quot;select (no cases)&quot;</span></span><br><span class="line">	waitReasonGCAssistWait                            <span class="comment">// &quot;GC assist wait&quot;</span></span><br><span class="line">	waitReasonGCSweepWait                             <span class="comment">// &quot;GC sweep wait&quot;</span></span><br><span class="line">	waitReasonGCScavengeWait                          <span class="comment">// &quot;GC scavenge wait&quot;</span></span><br><span class="line">	waitReasonChanReceive                             <span class="comment">// &quot;chan receive&quot;</span></span><br><span class="line">	waitReasonChanSend                                <span class="comment">// &quot;chan send&quot;</span></span><br><span class="line">	waitReasonFinalizerWait                           <span class="comment">// &quot;finalizer wait&quot;</span></span><br><span class="line">	waitReasonForceGGIdle                             <span class="comment">// &quot;force gc (idle)&quot;</span></span><br><span class="line">	waitReasonSemacquire                              <span class="comment">// &quot;semacquire&quot;</span></span><br><span class="line">	waitReasonSleep                                   <span class="comment">// &quot;sleep&quot;</span></span><br><span class="line">	waitReasonSyncCondWait                            <span class="comment">// &quot;sync.Cond.Wait&quot;</span></span><br><span class="line">	waitReasonTimerGoroutineIdle                      <span class="comment">// &quot;timer goroutine (idle)&quot;</span></span><br><span class="line">	waitReasonTraceReaderBlocked                      <span class="comment">// &quot;trace reader (blocked)&quot;</span></span><br><span class="line">	waitReasonWaitForGCCycle                          <span class="comment">// &quot;wait for GC cycle&quot;</span></span><br><span class="line">	waitReasonGCWorkerIdle                            <span class="comment">// &quot;GC worker (idle)&quot;</span></span><br><span class="line">	waitReasonPreempted                               <span class="comment">// &quot;preempted&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="非阻塞的操作"><a class="header-anchor" href="#非阻塞的操作">¶</a>非阻塞的操作</h5>
<p>像例子1那样，如果两个case，包含一个default，则为非阻塞的操作。<br>
<a href="https://github.com/golang/go/blob/release-branch.go1.14/src/cmd/compile/internal/gc/select.go#L108">walkselectcases</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkselectcases</span><span class="params">(cases *Nodes)</span></span> []*Node &#123;</span><br><span class="line">	ncas := cases.Len()</span><br><span class="line">	sellineno := lineno</span><br><span class="line"></span><br><span class="line">	<span class="comment">// optimization: zero-case select</span></span><br><span class="line">	<span class="keyword">if</span> ncas == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []*Node&#123;mkcall(<span class="string">&quot;block&quot;</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// optimization: one-case select: single op.</span></span><br><span class="line">	<span class="keyword">if</span> ncas == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 包含default的情况</span></span><br><span class="line">		cas := cases.First()</span><br><span class="line">		setlineno(cas)</span><br><span class="line">		l := cas.Ninit.Slice()</span><br><span class="line">		<span class="keyword">if</span> cas.Left != <span class="literal">nil</span> &#123; <span class="comment">// not default:</span></span><br><span class="line">			n := cas.Left</span><br><span class="line">			l = <span class="built_in">append</span>(l, n.Ninit.Slice()...)</span><br><span class="line">			n.Ninit.Set(<span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				Fatalf(<span class="string">&quot;select %v&quot;</span>, n.Op)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> OSEND:</span><br><span class="line">				<span class="comment">// already ok</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> OSELRECV, OSELRECV2:</span><br><span class="line">				<span class="keyword">if</span> n.Op == OSELRECV || n.List.Len() == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> n.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">						n = n.Right</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						n.Op = OAS</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> n.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">					nblank = typecheck(nblank, ctxExpr|ctxAssign)</span><br><span class="line">					n.Left = nblank</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				n.Op = OAS2</span><br><span class="line">				n.List.Prepend(n.Left)</span><br><span class="line">				n.Rlist.Set1(n.Right)</span><br><span class="line">				n.Right = <span class="literal">nil</span></span><br><span class="line">				n.Left = <span class="literal">nil</span></span><br><span class="line">				n.SetTypecheck(<span class="number">0</span>)</span><br><span class="line">				n = typecheck(n, ctxStmt)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			l = <span class="built_in">append</span>(l, n)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		l = <span class="built_in">append</span>(l, cas.Nbody.Slice()...)</span><br><span class="line">		l = <span class="built_in">append</span>(l, nod(OBREAK, <span class="literal">nil</span>, <span class="literal">nil</span>))</span><br><span class="line">		<span class="keyword">return</span> l</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="流程化问题"><a class="header-anchor" href="#流程化问题">¶</a>流程化问题</h4>
<ul>
<li>1、将所有的case转换成包含channel等信息的<a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/select.go#L29">runtime.scase结构</a></li>
<li>2、调用运行时函数selectgo从多个就绪的channel中选择一个可以执行的scase结构体。</li>
<li>3、for循环生成一组if语句，判断case是否被选中。</li>
</ul>
<h5 id="case转换为if的情况："><a class="header-anchor" href="#case转换为if的情况：">¶</a>case转换为if的情况：</h5>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/select.go#L542">reflect_rselect🔗</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:linkname reflect_rselect reflect.rselect</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_rselect</span><span class="params">(cases []runtimeSelect)</span></span> (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(cases) == <span class="number">0</span> &#123;</span><br><span class="line">		block()</span><br><span class="line">	&#125;</span><br><span class="line">	sel := <span class="built_in">make</span>([]scase, <span class="built_in">len</span>(cases)) <span class="comment">// 初始化</span></span><br><span class="line">	orig := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(cases))</span><br><span class="line">	nsends, nrecvs := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	dflt := <span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> i, rc := <span class="keyword">range</span> cases &#123;</span><br><span class="line">		<span class="keyword">var</span> j <span class="type">int</span></span><br><span class="line">		<span class="keyword">switch</span> rc.dir &#123;</span><br><span class="line">		<span class="keyword">case</span> selectDefault:</span><br><span class="line">			dflt = i</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">case</span> selectSend:</span><br><span class="line">			j = nsends</span><br><span class="line">			nsends++</span><br><span class="line">		<span class="keyword">case</span> selectRecv:</span><br><span class="line">			nrecvs++</span><br><span class="line">			j = <span class="built_in">len</span>(cases) - nrecvs</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sel[j] = scase&#123;c: rc.ch, elem: rc.val&#125;</span><br><span class="line">		orig[j] = i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Only a default case. 只有default的情况</span></span><br><span class="line">	<span class="keyword">if</span> nsends+nrecvs == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> dflt, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compact sel and orig if necessary.</span></span><br><span class="line">	<span class="keyword">if</span> nsends+nrecvs &lt; <span class="built_in">len</span>(cases) &#123;</span><br><span class="line">		<span class="built_in">copy</span>(sel[nsends:], sel[<span class="built_in">len</span>(cases)-nrecvs:])</span><br><span class="line">		<span class="built_in">copy</span>(orig[nsends:], orig[<span class="built_in">len</span>(cases)-nrecvs:])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	order := <span class="built_in">make</span>([]<span class="type">uint16</span>, <span class="number">2</span>*(nsends+nrecvs))</span><br><span class="line">	<span class="keyword">var</span> pc0 *<span class="type">uintptr</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		pcs := <span class="built_in">make</span>([]<span class="type">uintptr</span>, nsends+nrecvs)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> pcs &#123;</span><br><span class="line">			selectsetpc(&amp;pcs[i])</span><br><span class="line">		&#125;</span><br><span class="line">		pc0 = &amp;pcs[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//调用selectgo获取结果</span></span><br><span class="line">	chosen, recvOK := selectgo(&amp;sel[<span class="number">0</span>], &amp;order[<span class="number">0</span>], pc0, nsends, nrecvs, dflt == <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Translate chosen back to caller&#x27;s ordering.</span></span><br><span class="line">	<span class="keyword">if</span> chosen &lt; <span class="number">0</span> &#123;</span><br><span class="line">		chosen = dflt</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		chosen = orig[chosen]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> chosen, recvOK</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="selectgo主循环"><a class="header-anchor" href="#selectgo主循环">¶</a>selectgo主循环</h4>
<blockquote>
<p>selectgo会根据不通的逻辑判断,跳转到不通的逻辑中,主要分为如下几部分:</p>
</blockquote>
<ul>
<li>bufrecv 可以从缓存区读取数据</li>
<li>bufsend 可以向缓存区写入数据</li>
<li>recv 可以从休眠的发送方获取数据</li>
<li>send 可以向休眠的接收方发送数据</li>
<li>rclose 可以从关闭的channel读取EOF</li>
<li>sclose 可以向关闭的channel发送数据</li>
<li>retc 结束调用并返回</li>
</ul>
<h5 id="send-recv分析"><a class="header-anchor" href="#send-recv分析">¶</a>send &amp; recv分析</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">..</span><br><span class="line">...</span><br><span class="line">....</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">	<span class="comment">// pass 1 - look for something already waiting</span></span><br><span class="line">	<span class="keyword">var</span> dfli <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> dfl *scase</span><br><span class="line">	<span class="keyword">var</span> casi <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> cas *scase</span><br><span class="line">	<span class="keyword">var</span> recvOK <span class="type">bool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">		casi = <span class="type">int</span>(pollorder[i])</span><br><span class="line">		cas = &amp;scases[casi]</span><br><span class="line">		c = cas.c</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line">		<span class="keyword">case</span> caseNil:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseRecv:</span><br><span class="line">			sg = c.sendq.dequeue()</span><br><span class="line">			<span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> recv</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">//缓存区total&gt;0</span></span><br><span class="line">				<span class="keyword">goto</span> bufrecv</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// chan已经关闭</span></span><br><span class="line">				<span class="keyword">goto</span> rclose</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseSend:</span><br><span class="line">			<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">				racereadpc(c.raceaddr(), cas.pc, chansendpc)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// channel关闭了,但是向其发送消息</span></span><br><span class="line">				<span class="keyword">goto</span> sclose</span><br><span class="line">			&#125;</span><br><span class="line">			sg = c.recvq.dequeue()</span><br><span class="line">			<span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// 向出队的channel发送消息</span></span><br><span class="line">				<span class="keyword">goto</span> send</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">goto</span> bufsend</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseDefault:</span><br><span class="line">			dfli = casi</span><br><span class="line">			dfl = cas</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">.....</span><br><span class="line">....</span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line">.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里可能要温习下hchan结构:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="type">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">	dataqsiz <span class="type">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">	elemsize <span class="type">uint16</span></span><br><span class="line">	closed   <span class="type">uint32</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">	<span class="comment">// with stack shrinking.</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="bufrecv"><a class="header-anchor" href="#bufrecv">¶</a>bufrecv:</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bufrecv:</span><br><span class="line">	<span class="comment">// can receive from buffer</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			raceWriteObjectPC(c.elemtype, cas.elem, cas.pc, chanrecvpc)</span><br><span class="line">		&#125;</span><br><span class="line">		raceacquire(chanbuf(c, c.recvx))</span><br><span class="line">		racerelease(chanbuf(c, c.recvx))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		msanwrite(cas.elem, c.elemtype.size)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// recv 赋值</span></span><br><span class="line">	recvOK = <span class="literal">true</span></span><br><span class="line">	qp = chanbuf(c, c.recvx) <span class="comment">// chan指针指向</span></span><br><span class="line">	<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123; </span><br><span class="line">		typedmemmove(c.elemtype, cas.elem, qp)</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemclr(c.elemtype, qp)</span><br><span class="line">	c.recvx++</span><br><span class="line">	<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">		c.recvx = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.qcount--</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="bufsend"><a class="header-anchor" href="#bufsend">¶</a>bufsend:</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bufsend:</span><br><span class="line">	<span class="comment">// can send to buffer</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceacquire(chanbuf(c, c.sendx))</span><br><span class="line">		racerelease(chanbuf(c, c.sendx))</span><br><span class="line">		raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(cas.elem, c.elemtype.size)</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemmove(c.elemtype, chanbuf(c, c.sendx), cas.elem)</span><br><span class="line">	c.sendx++</span><br><span class="line">	<span class="keyword">if</span> c.sendx == c.dataqsiz &#123; <span class="comment">// 缓存区满了</span></span><br><span class="line">		c.sendx = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.qcount++</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br></pre></td></tr></table></figure>
<h5 id="recv"><a class="header-anchor" href="#recv">¶</a>recv:</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">recv:</span><br><span class="line">	<span class="comment">// can receive from sleeping sender (sg)</span></span><br><span class="line">	recv(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;syncrecv: cas0=&quot;</span>, cas0, <span class="string">&quot; c=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	recvOK = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="rclose"><a class="header-anchor" href="#rclose">¶</a>rclose:</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// read at end of closed channel</span></span><br><span class="line">selunlock(scases, lockorder)</span><br><span class="line">recvOK = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">	typedmemclr(c.elemtype, cas.elem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">	raceacquire(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> retc</span><br></pre></td></tr></table></figure>
<h5 id="send"><a class="header-anchor" href="#send">¶</a>send:</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">send:</span><br><span class="line">	<span class="comment">// can send to a sleeping receiver (sg)</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(cas.elem, c.elemtype.size)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// send函数</span></span><br><span class="line">	send(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;syncsend: cas0=&quot;</span>, cas0, <span class="string">&quot; c=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br></pre></td></tr></table></figure>
<h5 id="sclose"><a class="header-anchor" href="#sclose">¶</a>sclose:</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sclose:</span><br><span class="line">	<span class="comment">// send on closed channel</span></span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="comment">// 向一个close的channel发送消息,就发生panic</span></span><br><span class="line">	<span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="retc"><a class="header-anchor" href="#retc">¶</a>retc:</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">retc:</span><br><span class="line">	<span class="keyword">if</span> cas.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(cas.releasetime-t0, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> casi, recvOK</span><br></pre></td></tr></table></figure>
<h4 id="channel的recv和send方式"><a class="header-anchor" href="#channel的recv和send方式">¶</a>channel的recv和send方式:</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span>、当 <span class="keyword">case</span> 不包含 Channel 时；</span><br><span class="line">    这种 <span class="keyword">case</span> 会被跳过；</span><br><span class="line"><span class="number">2</span>、当 <span class="keyword">case</span> 会从 Channel 中recv数据时；</span><br><span class="line">    如果当前 Channel 的 sendq 上有等待的 Goroutine，就会跳到 recv 标签并从缓冲区读取数据后将等待 Goroutine 中的数据放入到缓冲区中相同的位置；</span><br><span class="line">    如果当前 Channel 的缓冲区不为空，就会跳到 bufrecv 标签处从缓冲区获取数据；</span><br><span class="line">    如果当前 Channel 已经被关闭，就会跳到 rclose 做一些清除的收尾工作；</span><br><span class="line"><span class="number">3</span>、当 <span class="keyword">case</span> 会向 Channel send数据时；</span><br><span class="line">    如果当前 Channel 已经被关，闭就会直接跳到 sclose 标签，触发 <span class="built_in">panic</span> 尝试中止程序；</span><br><span class="line">    如果当前 Channel 的 recvq 上有等待的 Goroutine，就会跳到 send 标签向 Channel 发送数据；</span><br><span class="line">    如果当前 Channel 的缓冲区存在空闲位置，就会将待发送的数据存入缓冲区；</span><br><span class="line"><span class="number">4</span>、当 <span class="keyword">select</span> 语句中包含 <span class="keyword">default</span> 时；</span><br><span class="line">    表示前面的所有 <span class="keyword">case</span> 都没有被执行，这里会解锁所有 Channel 并返回，意味着当前 <span class="keyword">select</span> 结构中的收发都是非阻塞的；</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="End"><a class="header-anchor" href="#End">¶</a>End</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>「38」上亿数据的快速排序</title>
    <url>/archives/26af015.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p>前面说到了快速排序的自定义通用方案:</p>
<p><a href="https://blog.imrcrab.com/archives/aa75061e.html#more">「37」Quick Sort快速排序</a></p>
<blockquote>
<p>但是又有一个新想法: 1亿条数据,100M内存,怎么搞?</p>
</blockquote>
<span id="more"></span>
<h3 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h3>
<h4 id="问题"><a class="header-anchor" href="#问题">¶</a>问题</h4>
<ul>
<li>内存不足以放1亿条数据</li>
<li>即使够用,一次把1亿条数据放入内存,如果说高并发下,每次都是1亿,消耗过大!</li>
</ul>
<h4 id="解决思路"><a class="header-anchor" href="#解决思路">¶</a>解决思路:</h4>
<p>大化小,小归大「归并算法的思想」,利用磁盘文件形式进行存储,比较,再存储…</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/sort_1.png" alt=""></p>
<h4 id="代码部分「其它语言类似」"><a class="header-anchor" href="#代码部分「其它语言类似」">¶</a>代码部分「其它语言类似」:</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="type">string</span></span><br><span class="line">	Age   <span class="type">int</span></span><br><span class="line">	Count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="number">100000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> SplitNum = Counter / <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSortAll</span><span class="params">(a []<span class="keyword">interface</span>&#123;&#125;, left, right <span class="type">int</span>, By <span class="keyword">func</span>(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>) []<span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">		mid := partitionAll(a, left, right, By)</span><br><span class="line">		QuickSortAll(a, left, mid<span class="number">-1</span>, By)</span><br><span class="line">		QuickSortAll(a, mid+<span class="number">1</span>, right, By)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partitionAll</span><span class="params">(a []<span class="keyword">interface</span>&#123;&#125;, left <span class="type">int</span>, right <span class="type">int</span>, By <span class="keyword">func</span>(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>) <span class="type">int</span> &#123;</span><br><span class="line">	pivot := a[left]</span><br><span class="line">	<span class="keyword">for</span> ; left &lt; right; &#123;</span><br><span class="line">		<span class="comment">//for ; left &lt; right &amp;&amp; a[right] &gt;= pivot; &#123;</span></span><br><span class="line">		<span class="keyword">for</span> ; left &lt; right &amp;&amp; By(a[right], pivot); &#123;</span><br><span class="line">			right--</span><br><span class="line">		&#125;</span><br><span class="line">		a[left] = a[right]</span><br><span class="line">		<span class="comment">//for ; left &lt; right &amp;&amp; a[left] &lt;= pivot; &#123;</span></span><br><span class="line">		<span class="keyword">for</span> ; left &lt; right &amp;&amp; By(pivot, a[left]); &#123;</span><br><span class="line">			left++</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		a[right] = a[left]</span><br><span class="line">	&#125;</span><br><span class="line">	a[left] = pivot</span><br><span class="line">	<span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartSort</span><span class="params">(dirName <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> lock sync.Mutex</span><br><span class="line">	resultPaths := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">	group, _ := errgroup.WithContext(context.TODO())</span><br><span class="line">	<span class="keyword">for</span> ia := <span class="number">0</span>; ia &lt; Counter; ia += SplitNum * <span class="number">2</span> &#123;</span><br><span class="line">		i := ia</span><br><span class="line">		<span class="comment">//group.Go(func() error &#123;</span></span><br><span class="line">		Mem(<span class="string">&quot;compareTwoFileObject&quot;</span>)</span><br><span class="line">		filePath, _ := compareTwoFileObject(dirName+<span class="string">&quot;/&quot;</span>+strconv.Itoa(i)+<span class="string">&quot;_split_quicksort.txt&quot;</span>,</span><br><span class="line">			dirName+<span class="string">&quot;/&quot;</span>+strconv.Itoa(i+SplitNum)+<span class="string">&quot;_split_quicksort.txt&quot;</span>, dirName, SortBy)</span><br><span class="line">		lock.Lock()</span><br><span class="line"></span><br><span class="line">		resultPaths = <span class="built_in">append</span>(resultPaths, filePath)</span><br><span class="line">		lock.Unlock()</span><br><span class="line">		<span class="comment">//return nil</span></span><br><span class="line">		<span class="comment">//&#125;)</span></span><br><span class="line">	&#125;</span><br><span class="line">	group.Wait()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> recursionDeal(resultPaths, dirName, lock)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursionDeal</span><span class="params">(paths []<span class="type">string</span>, dirName <span class="type">string</span>, lock sync.Mutex)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	tmpPaths := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(paths) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> paths[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	group, _ := errgroup.WithContext(context.TODO())</span><br><span class="line">	<span class="keyword">for</span> ia := <span class="number">0</span>; ia &lt; <span class="built_in">len</span>(paths); ia += <span class="number">2</span> &#123;</span><br><span class="line">		i := ia</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(paths)%<span class="number">2</span> != <span class="number">0</span> &amp;&amp; i == <span class="built_in">len</span>(paths)<span class="number">-1</span> &#123;</span><br><span class="line">			lock.Lock()</span><br><span class="line">			tmpPaths = <span class="built_in">append</span>(tmpPaths, paths[i])</span><br><span class="line">			lock.Unlock()</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//group.Go(func() error &#123;</span></span><br><span class="line">		filePath, _ := compareTwoFileObjectForRecursion(dirName+<span class="string">&quot;/&quot;</span>+paths[i], dirName+<span class="string">&quot;/&quot;</span>+paths[i+<span class="number">1</span>], dirName, SortBy)</span><br><span class="line">		lock.Lock()</span><br><span class="line">		tmpPaths = <span class="built_in">append</span>(tmpPaths, filePath)</span><br><span class="line">		lock.Unlock()</span><br><span class="line">		Mem(<span class="string">&quot;recursionDeal：&quot;</span> + filePath)</span><br><span class="line">		<span class="comment">//return nil</span></span><br><span class="line">		<span class="comment">//&#125;)</span></span><br><span class="line">	&#125;</span><br><span class="line">	_ = group.Wait()</span><br><span class="line">	<span class="keyword">return</span> recursionDeal(tmpPaths, dirName, lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compareTwoFileObject</span><span class="params">(filePathBefore, filePathAfter, dirName <span class="type">string</span>, By <span class="keyword">func</span>(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>) (resultFilePath <span class="type">string</span>, errRet <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		os.Remove(filePathBefore)</span><br><span class="line">		os.Remove(filePathAfter)</span><br><span class="line">	&#125;()</span><br><span class="line">	fileBefore, _ := readObjectFromFile(filePathBefore)</span><br><span class="line">	fileAfter, _ := readObjectFromFile(filePathAfter)</span><br><span class="line">	resultFilePath = sha1s(strconv.Itoa(<span class="type">int</span>(time.Now().UnixNano()))) + <span class="string">&quot;_split_quicksort.txt&quot;</span></span><br><span class="line">	f, _ := os.OpenFile(dirName+<span class="string">&quot;/&quot;</span>+resultFilePath, os.O_CREATE|os.O_RDWR|os.O_APPEND, os.ModeAppend|os.ModePerm)</span><br><span class="line"></span><br><span class="line">	flag := <span class="number">0</span></span><br><span class="line">	flagResultAfter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(fileBefore); i++ &#123;</span><br><span class="line">		tmp := fileBefore[i]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> ai := flag; ai &lt; <span class="built_in">len</span>(fileAfter); ai++ &#123;</span><br><span class="line">			<span class="keyword">if</span> flag+<span class="number">1</span> == <span class="built_in">len</span>(fileAfter) &#123;</span><br><span class="line">				<span class="comment">// fileAfter遍历完了</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(fileAfter) == ai+<span class="number">1</span> &#123;</span><br><span class="line">				<span class="comment">// 最后赋值</span></span><br><span class="line">				flag = ai</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> By(tmp, fileAfter[ai]) &#123;</span><br><span class="line">				tmpJson, _ := json.Marshal(fileAfter[ai])</span><br><span class="line">				f.WriteString(<span class="type">string</span>(tmpJson) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">				flagResultAfter = ai</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			flag = ai</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		tmpJson, _ := json.Marshal(tmp)</span><br><span class="line">		f.WriteString(<span class="type">string</span>(tmpJson) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fileAfter == <span class="literal">nil</span> &#123;</span><br><span class="line">		f.Close()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> flagResultAfter &lt; <span class="built_in">len</span>(fileAfter) &#123;</span><br><span class="line">		flagResultAfter++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fileAfter = fileAfter[flagResultAfter:]</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> fileAfter &#123;</span><br><span class="line">		tmpJson, _ := json.Marshal(v)</span><br><span class="line">		f.WriteString(<span class="type">string</span>(tmpJson) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f.Close()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件中的数据,用于排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readObjectFromFile</span><span class="params">(filePath <span class="type">string</span>)</span></span> (users []<span class="keyword">interface</span>&#123;&#125;, errRet <span class="type">error</span>) &#123;</span><br><span class="line">	fileBefore, err := os.Open(filePath)</span><br><span class="line">	<span class="keyword">defer</span> fileBefore.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		errRet = err</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	brBefore := bufio.NewReader(fileBefore)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		a, _, c := brBefore.ReadLine()</span><br><span class="line">		<span class="keyword">if</span> c == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		users = <span class="built_in">append</span>(users, resolveObject(a))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(users) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	QuickSortAll(users, <span class="number">0</span>, <span class="built_in">len</span>(users)<span class="number">-1</span>, SortBy)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mem</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m runtime.MemStats</span><br><span class="line">	runtime.ReadMemStats(&amp;m)</span><br><span class="line">	fmt.Println(msg, <span class="string">&quot;系统内存：&quot;</span>, m.Sys, <span class="string">&quot;   常驻内存：&quot;</span>, m.HeapInuse, <span class="string">&quot;    堆上分配的，gc后会归还： &quot;</span>, m.HeapAlloc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于两个排序好的文件,进行比较并存储</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compareTwoFileObjectForRecursion</span><span class="params">(filePathBefore, filePathAfter, dirName <span class="type">string</span>, By <span class="keyword">func</span>(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>) (resultFilePath <span class="type">string</span>, errRet <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	resultFilePath = sha1s(strconv.Itoa(<span class="type">int</span>(time.Now().UnixNano()))) + <span class="string">&quot;_split_quicksort.txt&quot;</span></span><br><span class="line">	f, _ := os.OpenFile(dirName+<span class="string">&quot;/&quot;</span>+resultFilePath, os.O_CREATE|os.O_RDWR|os.O_APPEND, os.ModeAppend|os.ModePerm)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		os.Remove(filePathBefore)</span><br><span class="line">		os.Remove(filePathAfter)</span><br><span class="line">	&#125;()</span><br><span class="line">	fileBefore, err := os.Open(filePathBefore)</span><br><span class="line">	<span class="keyword">defer</span> fileBefore.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		errRet = err</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	brBefore := bufio.NewReader(fileBefore)</span><br><span class="line"></span><br><span class="line">	fileAfter, err := os.Open(filePathAfter)</span><br><span class="line">	<span class="keyword">defer</span> fileAfter.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		errRet = err</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	brAfter := bufio.NewReader(fileAfter)</span><br><span class="line"></span><br><span class="line">	fa := <span class="literal">true</span></span><br><span class="line">	fb := <span class="literal">true</span></span><br><span class="line">	<span class="keyword">var</span> va, vb []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> ca, cb <span class="type">error</span></span><br><span class="line">		<span class="keyword">if</span> fa &#123;</span><br><span class="line">			a, _, cae := brBefore.ReadLine()</span><br><span class="line">			va = a</span><br><span class="line">			ca = cae</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> fb &#123;</span><br><span class="line">			b, _, cbe := brAfter.ReadLine()</span><br><span class="line">			vb = b</span><br><span class="line">			cb = cbe</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ca == io.EOF || cb == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(va) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(vb) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		bUser := User&#123;&#125;</span><br><span class="line">		_ = json.Unmarshal(vb, &amp;bUser)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> By(resolveObject(va), resolveObject(vb)) &#123;</span><br><span class="line"></span><br><span class="line">			f.WriteString(<span class="type">string</span>(vb) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">			fb = <span class="literal">true</span></span><br><span class="line">			fa = <span class="literal">false</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			f.WriteString(<span class="type">string</span>(va) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">			fa = <span class="literal">true</span></span><br><span class="line">			fb = <span class="literal">false</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		a, _, ca := brBefore.ReadLine()</span><br><span class="line">		<span class="keyword">if</span> ca == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		f.WriteString(<span class="type">string</span>(a) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		b, _, ca := brBefore.ReadLine()</span><br><span class="line">		<span class="keyword">if</span> ca == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		f.WriteString(<span class="type">string</span>(b) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Mem(filePathBefore + <span class="string">&quot;=====&gt;&quot;</span> + filePathAfter)</span><br><span class="line"></span><br><span class="line">	f.Close()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义序列化对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resolveObject</span><span class="params">(a []<span class="type">byte</span>)</span></span> User &#123;</span><br><span class="line">	user := User&#123;&#125;</span><br><span class="line">	_ = json.Unmarshal(a, &amp;user)</span><br><span class="line">	<span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SortBy</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a.(User).Age &lt;= b.(User).Age <span class="comment">//按照count排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sha1s</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	r := sha1.Sum([]<span class="type">byte</span>(s))</span><br><span class="line">	<span class="keyword">return</span> hex.EncodeToString(r[:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="注意事项"><a class="header-anchor" href="#注意事项">¶</a>注意事项:</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210221_110111.png" alt=""></p>
<blockquote>
<p>主函数,这次的数据都是自己造的,实景就按照某某某来源来操作把.</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dirName := <span class="string">&quot;tmp_quick_sort&quot;</span> + time.Now().Format(<span class="string">&quot;2006_01_02_15_04_05&quot;</span>)</span><br><span class="line">	err2 := os.Mkdir(dirName, os.ModeAppend|os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	f, err := os.OpenFile(dirName+<span class="string">&quot;/0_split_quicksort.txt&quot;</span>, os.O_CREATE|os.O_RDWR|os.O_APPEND, os.ModeAppend|os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(f)</span><br><span class="line">	&#125;</span><br><span class="line">	t := time.Now().Unix()</span><br><span class="line">	Mem(<span class="string">&quot;before write file&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; quicksort.Counter; i++ &#123;</span><br><span class="line">		auser := quicksort.User&#123;</span><br><span class="line">			Name:  strconv.Itoa(i),</span><br><span class="line">			Age:   i,</span><br><span class="line">			Count: rand.Intn(quicksort.Counter),</span><br><span class="line">		&#125;</span><br><span class="line">		marshal, _ := json.Marshal(auser)</span><br><span class="line"></span><br><span class="line">		f.Write(marshal)</span><br><span class="line">		f.Write([]<span class="type">byte</span>(<span class="string">&quot;\n&quot;</span>))</span><br><span class="line">		<span class="keyword">if</span> i%quicksort.SplitNum == <span class="number">0</span> &#123;</span><br><span class="line">			f.Close()</span><br><span class="line">			Mem(strconv.Itoa(i) + <span class="string">&quot;after write file&quot;</span>)</span><br><span class="line">			f, err = os.OpenFile(dirName+<span class="string">&quot;/&quot;</span>+strconv.Itoa(i)+<span class="string">&quot;_split_quicksort.txt&quot;</span>, os.O_CREATE|os.O_RDWR|os.O_APPEND, os.ModeAppend|os.ModePerm)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f.Close()</span><br><span class="line">	runtime.GC()</span><br><span class="line">	Mem(<span class="string">&quot;after write file&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;filename: &quot;</span>, quicksort.StartSort(dirName))</span><br><span class="line"></span><br><span class="line">	fmt.Println(time.Now().Unix() - t)</span><br><span class="line">	Mem(<span class="string">&quot;last msg&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(unsafe.Sizeof([<span class="number">100000</span>]quicksort.User&#123;&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="结果到底是否如设计的那样可行呢"><a class="header-anchor" href="#结果到底是否如设计的那样可行呢">¶</a>结果到底是否如设计的那样可行呢?</h4>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210221_102841.png" alt=""></p>
<h5 id="内存打印的实际情况"><a class="header-anchor" href="#内存打印的实际情况">¶</a>内存打印的实际情况</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210221_103339.png" alt=""></p>
<h3 id="后续改进"><a class="header-anchor" href="#后续改进">¶</a>后续改进</h3>
<h4 id="痛点"><a class="header-anchor" href="#痛点">¶</a>痛点:</h4>
<ul>
<li>单个服务器,速度太慢</li>
<li>单线程,有点慢「磁盘读写速度不快的,建议就使用单线程」</li>
<li>没有断点「电」继续的机制.</li>
</ul>
<h4 id="改进方法"><a class="header-anchor" href="#改进方法">¶</a>改进方法:</h4>
<ul>
<li>多服务器计算</li>
<li>改进排序,单服务器可以分左右两部分</li>
<li>增加任务记录机制,用于断点继续任务.</li>
</ul>
<h3 id="End"><a class="header-anchor" href="#End">¶</a>End</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>「37」Quick Sort快速排序</title>
    <url>/archives/aa75061e.html</url>
    <content><![CDATA[<!-- toc -->
<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p>最近在想一个问题：Go里面的sort包到底是怎么实现的，，，，<br>
想着想着就想到了快速排序，就试着手撕了一个，</p>
<p>有个关键问题，所有的都是针对int或者其它特定的类型，</p>
<p><em>那如何让排序算法通用性呢，</em></p>
<span id="more"></span>
<h3 id="快速排序"><a class="header-anchor" href="#快速排序">¶</a>快速排序</h3>
<p>不废话，先搞一个排序的代码来，再分析「遵循先用后分析的原则」</p>
<blockquote>
<p>默认从大–&gt;小，注释的那行放开就是 从小–&gt;大</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(a []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">		mid := partition(a, left, right)</span><br><span class="line">		QuickSort(a, left, mid<span class="number">-1</span>)</span><br><span class="line">		QuickSort(a, mid+<span class="number">1</span>, right)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(a []<span class="type">int</span>, left <span class="type">int</span>, right <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	pivot := a[left] <span class="comment">//基点</span></span><br><span class="line">	<span class="keyword">for</span> ; left &lt; right; &#123;</span><br><span class="line">		<span class="comment">//for ; left &lt; right &amp;&amp; a[right] &gt;= pivot; &#123; </span></span><br><span class="line">		<span class="keyword">for</span> ; left &lt; right &amp;&amp; a[right] &lt;= pivot; &#123;</span><br><span class="line">			right--</span><br><span class="line">		&#125;</span><br><span class="line">		a[left] = a[right]</span><br><span class="line">		<span class="comment">//for ; left &lt; right &amp;&amp; a[left] &lt;= pivot; &#123;</span></span><br><span class="line">		<span class="keyword">for</span> ; left &lt; right &amp;&amp; a[left] &gt;= pivot; &#123;</span><br><span class="line">			left++</span><br><span class="line">		&#125;</span><br><span class="line">		a[right] = a[left]</span><br><span class="line">	&#125;</span><br><span class="line">	a[left] = pivot</span><br><span class="line">	<span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="调用分析"><a class="header-anchor" href="#调用分析">¶</a>调用分析</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">	num :=QuickSort(s, <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span>)</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Outputs"><a class="header-anchor" href="#Outputs">¶</a>Outputs:</h5>
<blockquote>
<p>[7 6 5 4 3 2 1]</p>
</blockquote>
<h4 id="不足点："><a class="header-anchor" href="#不足点：">¶</a>不足点：</h4>
<ul>
<li>只能用在int型或者指定的类型，「不爽😕」</li>
<li>基点在最左边「后面分析为何不好」</li>
</ul>
<h5 id="改进点："><a class="header-anchor" href="#改进点：">¶</a>改进点：</h5>
<blockquote>
<p>既然是需要改进，那就朝着上面的不足点来搞。</p>
</blockquote>
<ul>
<li>通用类型的设计，「用go的断言：interface来做」</li>
<li>基点的选取尽量均衡「可选项」</li>
</ul>
<h4 id="Just-do-it"><a class="header-anchor" href="#Just-do-it">¶</a>Just do it</h4>
<h5 id="自定义排序规则做法："><a class="header-anchor" href="#自定义排序规则做法：">¶</a>自定义排序规则做法：</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSortAll</span><span class="params">(a []<span class="keyword">interface</span>&#123;&#125;, left, right <span class="type">int</span>, By <span class="keyword">func</span>(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>) []<span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">		mid := partitionAll(a, left, right, By)</span><br><span class="line">		QuickSortAll(a, left, mid<span class="number">-1</span>, By)</span><br><span class="line">		QuickSortAll(a, mid+<span class="number">1</span>, right, By)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partitionAll</span><span class="params">(a []<span class="keyword">interface</span>&#123;&#125;, left <span class="type">int</span>, right <span class="type">int</span>, By <span class="keyword">func</span>(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>) <span class="type">int</span> &#123;</span><br><span class="line">	pivot := a[left]</span><br><span class="line">	<span class="keyword">for</span> ; left &lt; right; &#123;</span><br><span class="line">		<span class="comment">//for ; left &lt; right &amp;&amp; a[right] &gt;= pivot; &#123;</span></span><br><span class="line">		<span class="keyword">for</span> ; left &lt; right &amp;&amp; By(a[right], pivot); &#123;</span><br><span class="line">			right--</span><br><span class="line">		&#125;</span><br><span class="line">		a[left] = a[right]</span><br><span class="line">		<span class="comment">//for ; left &lt; right &amp;&amp; a[left] &lt;= pivot; &#123;</span></span><br><span class="line">		<span class="keyword">for</span> ; left &lt; right &amp;&amp; By(pivot, a[left]); &#123;</span><br><span class="line">			left++</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		a[right] = a[left]</span><br><span class="line">	&#125;</span><br><span class="line">	a[left] = pivot</span><br><span class="line">	<span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="type">string</span></span><br><span class="line">	Age   <span class="type">int</span></span><br><span class="line">	Count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="number">100000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	isp := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, counter)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; counter; i++ &#123;</span><br><span class="line">		isp = <span class="built_in">append</span>(isp, User&#123;</span><br><span class="line">			Name:  strconv.Itoa(i),</span><br><span class="line">			Age:   i,</span><br><span class="line">			Count: rand.Intn(counter),</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	t := time.Now().Unix()</span><br><span class="line"></span><br><span class="line">	_ = QuickSortAll(isp, <span class="number">0</span>, <span class="built_in">len</span>(isp)<span class="number">-1</span>, <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="comment">// return a.(User).Count &gt;= b.(User).Count //按照count排序 从小到大</span></span><br><span class="line">        <span class="keyword">return</span> a.(User).Count &lt;= b.(User).Count <span class="comment">//按照count排序  从大到小</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">//fmt.Println(num)</span></span><br><span class="line">	fmt.Println(time.Now().Unix() - t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Outputs："><a class="header-anchor" href="#Outputs：">¶</a>Outputs：</h6>
<blockquote>
<p>91</p>
</blockquote>
<h5 id="跑个benchmark看看"><a class="header-anchor" href="#跑个benchmark看看">¶</a>跑个benchmark看看</h5>
<blockquote>
<p>上面的变量counter=10000000</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">cpu: Intel(R) Core(TM) i7<span class="number">-9750</span>H CPU @ <span class="number">2.60</span>GHz</span><br><span class="line">BenchmarkQuickSortAll</span><br><span class="line">BenchmarkQuickSortAll<span class="number">-12</span>    	       <span class="number">1</span>	<span class="number">6287198265</span> ns/op</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>
<h4 id="内存占用分析"><a class="header-anchor" href="#内存占用分析">¶</a>内存占用分析</h4>
<blockquote>
<p>改造下执行函数,加上打印内存情况:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Mem(fmt.Sprintf(<span class="string">&quot;for start&quot;</span>))</span><br><span class="line">	isp := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, counter)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; counter; i++ &#123;</span><br><span class="line">		isp = <span class="built_in">append</span>(isp, User&#123;</span><br><span class="line">			Name:  strconv.Itoa(i),</span><br><span class="line">			Age:   i,</span><br><span class="line">			Sage:  i,</span><br><span class="line">			Count: rand.Intn(counter),</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(unsafe.Sizeof(isp))</span><br><span class="line">	fmt.Println(unsafe.Sizeof([counter]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;))</span><br><span class="line">	t := time.Now().Unix()</span><br><span class="line">	Mem(fmt.Sprintf(<span class="string">&quot;for all slice&quot;</span>))</span><br><span class="line">	_ = QuickSortAll(isp, <span class="number">0</span>, <span class="built_in">len</span>(isp)<span class="number">-1</span>, <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="comment">// return a.(User).Count &gt;= b.(User).Count //按照count排序 从小到大</span></span><br><span class="line">		<span class="keyword">return</span> a.(User).Count &lt;= b.(User).Count <span class="comment">//按照count排序  从大到小</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">//fmt.Println(num)</span></span><br><span class="line">	fmt.Println(time.Now().Unix() - t)</span><br><span class="line">	Mem(fmt.Sprintf(<span class="string">&quot;for all end&quot;</span>))</span><br><span class="line"></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="number">10</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		runtime.GC()</span><br><span class="line">		Mem(fmt.Sprintf(<span class="string">&quot;for gc end&quot;</span>))</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mem</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m runtime.MemStats</span><br><span class="line">	runtime.ReadMemStats(&amp;m)</span><br><span class="line">	fmt.Println(msg, <span class="string">&quot;系统内存&quot;</span>, m.Sys, <span class="string">&quot; 常驻内存：&quot;</span>, m.HeapInuse, <span class="string">&quot;堆上分配的，gc后会归还： &quot;</span>, m.HeapAlloc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Outputs-v2"><a class="header-anchor" href="#Outputs-v2">¶</a>Outputs:</h5>
<blockquote>
<p>不同的系统可能会有些许偏差,关键点不在于数值大小,<br>
关键点在于: 向系统申请的大内存,没有归还给系统,如果说要频繁的申请大内存等操作,<br>
最好还是搞一个pool池子,不然容易内存暴增暴跌.</p>
</blockquote>
<ul>
<li>此处 <em>counter=10000000</em></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> start 系统内存： <span class="number">71388176</span>    常驻内存： <span class="number">450560</span>     堆上分配的，gc后会归还：  <span class="number">130808</span></span><br><span class="line">isp占用的字节大小：「isp结构占用」 <span class="number">24</span></span><br><span class="line">counter的切片占用的字节大小： <span class="number">160000000</span></span><br><span class="line"><span class="keyword">for</span> all slice 系统内存： <span class="number">784408744</span>    常驻内存： <span class="number">722001920</span>     堆上分配的，gc后会归还：  <span class="number">719855360</span></span><br><span class="line">耗时：  <span class="number">10</span>  S</span><br><span class="line"><span class="keyword">for</span> all end 系统内存： <span class="number">784408744</span>    常驻内存： <span class="number">722010112</span>     堆上分配的，gc后会归还：  <span class="number">719855616</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">785326248</span>    常驻内存： <span class="number">425984</span>     堆上分配的，gc后会归还：  <span class="number">131608</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">785326248</span>    常驻内存： <span class="number">417792</span>     堆上分配的，gc后会归还：  <span class="number">131416</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">785326248</span>    常驻内存： <span class="number">417792</span>     堆上分配的，gc后会归还：  <span class="number">131656</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">785326248</span>    常驻内存： <span class="number">417792</span>     堆上分配的，gc后会归还：  <span class="number">131672</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">785326248</span>    常驻内存： <span class="number">417792</span>     堆上分配的，gc后会归还：  <span class="number">131456</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">785326248</span>    常驻内存： <span class="number">417792</span>     堆上分配的，gc后会归还：  <span class="number">131792</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">785326248</span>    常驻内存： <span class="number">417792</span>     堆上分配的，gc后会归还：  <span class="number">131680</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">785326248</span>    常驻内存： <span class="number">417792</span>     堆上分配的，gc后会归还：  <span class="number">131696</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">785326248</span>    常驻内存： <span class="number">417792</span>     堆上分配的，gc后会归还：  <span class="number">131472</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">785326248</span>    常驻内存： <span class="number">417792</span>     堆上分配的，gc后会归还：  <span class="number">131696</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">785326248</span>    常驻内存： <span class="number">417792</span>     堆上分配的，gc后会归还：  <span class="number">131696</span></span><br></pre></td></tr></table></figure>
<h4 id="后续优化点"><a class="header-anchor" href="#后续优化点">¶</a>后续优化点:</h4>
<ul>
<li>如果数量过大,可以搞个内存池</li>
<li>如果数量庞大,建议分治,多次排序「这个数据量一般在G/T级别」</li>
</ul>
<h5 id="数量大的实验-函数内部复用"><a class="header-anchor" href="#数量大的实验-函数内部复用">¶</a>数量大的实验,函数内部复用:</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Mem(fmt.Sprintf(<span class="string">&quot;for start&quot;</span>))</span><br><span class="line">	isp := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, counter)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; counter; i++ &#123;</span><br><span class="line">		ssUser := User&#123;</span><br><span class="line">			Name:  strconv.Itoa(i),</span><br><span class="line">			Age:   i,</span><br><span class="line">			Sage:  i,</span><br><span class="line">			Count: rand.Intn(counter),</span><br><span class="line">		&#125;</span><br><span class="line">		isp = <span class="built_in">append</span>(isp,ssUser)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;isp占用的字节大小：「isp结构占用」&quot;</span>, unsafe.Sizeof(isp))</span><br><span class="line">	fmt.Println(<span class="string">&quot;counter的切片占用的字节大小：&quot;</span>, unsafe.Sizeof([counter]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;))</span><br><span class="line">	t := time.Now().Unix()</span><br><span class="line">	Mem(fmt.Sprintf(<span class="string">&quot;for all slice&quot;</span>))</span><br><span class="line">	_ = QuickSortAll(isp, <span class="number">0</span>, <span class="built_in">len</span>(isp)<span class="number">-1</span>, <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="comment">// return a.(User).Count &gt;= b.(User).Count //按照count排序 从小到大</span></span><br><span class="line">		<span class="keyword">return</span> a.(User).Count &lt;= b.(User).Count <span class="comment">//按照count排序  从大到小</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">//fmt.Println(num)</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;耗时： &quot;</span>, time.Now().Unix()-t, <span class="string">&quot; S&quot;</span>)</span><br><span class="line">	Mem(fmt.Sprintf(<span class="string">&quot;for all end&quot;</span>))</span><br><span class="line"></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="number">3</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		runtime.GC()</span><br><span class="line">		Mem(fmt.Sprintf(<span class="string">&quot;for gc end&quot;</span>))</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放内存,断开引用</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> isp &#123;</span><br><span class="line">		isp[i] = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	isp = isp[:<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">	runtime.GC()</span><br><span class="line">	Mem(fmt.Sprintf(<span class="string">&quot;gc before new start %d&quot;</span>, i))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; counter; i++ &#123;</span><br><span class="line">		stmp := User&#123;&#125;</span><br><span class="line">		stmp.Name = strconv.Itoa(i)</span><br><span class="line">		stmp.Age = i</span><br><span class="line">		stmp.Sage = i</span><br><span class="line">		stmp.Count = rand.Intn(counter)</span><br><span class="line">		isp = <span class="built_in">append</span>(isp, stmp)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> i%<span class="number">1000000</span> == <span class="number">0</span> &#123;</span><br><span class="line">			Mem(fmt.Sprintf(<span class="string">&quot;slice %d&quot;</span>, i))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//fmt.Println(isp)</span></span><br><span class="line">	<span class="comment">// ******关键点在于这个地方的内存会不会是前面同样打印处的倍数???</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;isp占用的字节大小：「isp结构占用」&quot;</span>, unsafe.Sizeof(isp))</span><br><span class="line">	<span class="comment">//fmt.Println(&quot;counter的切片占用的字节大小：&quot;, unsafe.Sizeof([counter]interface&#123;&#125;&#123;&#125;))</span></span><br><span class="line">	ts := time.Now().Unix()</span><br><span class="line">	Mem(fmt.Sprintf(<span class="string">&quot;for all slice&quot;</span>))</span><br><span class="line">	_ = QuickSortAll(isp, <span class="number">0</span>, <span class="built_in">len</span>(isp)<span class="number">-1</span>, <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="comment">// return a.(User).Count &gt;= b.(User).Count //按照count排序 从小到大</span></span><br><span class="line">		<span class="keyword">return</span> a.(User).Count &lt;= b.(User).Count <span class="comment">//按照count排序  从大到小</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">//fmt.Println(num)</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;耗时： &quot;</span>, time.Now().Unix()-ts, <span class="string">&quot; S&quot;</span>)</span><br><span class="line">	Mem(fmt.Sprintf(<span class="string">&quot;for all end&quot;</span>))</span><br><span class="line"></span><br><span class="line">	ia := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ia &gt; <span class="number">10</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		runtime.GC()</span><br><span class="line">		Mem(fmt.Sprintf(<span class="string">&quot;for gc end&quot;</span>))</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		ia++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mem</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m runtime.MemStats</span><br><span class="line">	runtime.ReadMemStats(&amp;m)</span><br><span class="line">	fmt.Println(msg, <span class="string">&quot;系统内存：&quot;</span>, m.Sys, <span class="string">&quot;   常驻内存：&quot;</span>, m.HeapInuse, <span class="string">&quot;    堆上分配的，gc后会归还： &quot;</span>, m.HeapAlloc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="Outputs-v3"><a class="header-anchor" href="#Outputs-v3">¶</a>Outputs:</h6>
<blockquote>
<p>还是同样的,内存的大小不重要,重要的是看分布:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">GOROOT=/usr/local/<span class="keyword">go</span> #gosetup</span><br><span class="line">GOPATH=/Users/k/<span class="keyword">go</span> #gosetup</span><br><span class="line">/usr/local/<span class="keyword">go</span>/bin/<span class="keyword">go</span> build -o /private/<span class="keyword">var</span>/folders/b0/hs49sy5x5qs1sw7cjxfm8gkm0000gn/T/___go_build_quicksort_go /Users/k/learn/<span class="keyword">go</span>-memory/src/main/quicksort.<span class="keyword">go</span> #gosetup</span><br><span class="line">/private/<span class="keyword">var</span>/folders/b0/hs49sy5x5qs1sw7cjxfm8gkm0000gn/T/___go_build_quicksort_go</span><br><span class="line"><span class="keyword">for</span> start 系统内存： <span class="number">71388176</span>    常驻内存： <span class="number">344064</span>     堆上分配的，gc后会归还：  <span class="number">130600</span></span><br><span class="line">isp占用的字节大小：「isp结构占用」 <span class="number">24</span></span><br><span class="line">counter的切片占用的字节大小： <span class="number">1600000000</span></span><br><span class="line"><span class="keyword">for</span> all slice 系统内存： <span class="number">7651851800</span>    常驻内存： <span class="number">7218954240</span>     堆上分配的，gc后会归还：  <span class="number">7199851600</span></span><br><span class="line">耗时：  <span class="number">168</span>  S</span><br><span class="line"><span class="keyword">for</span> all end 系统内存： <span class="number">7664827928</span>    常驻内存： <span class="number">7218962432</span>     堆上分配的，gc后会归还：  <span class="number">7199852696</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">7218962432</span>     堆上分配的，gc后会归还：  <span class="number">7199853016</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">7218962432</span>     堆上分配的，gc后会归还：  <span class="number">7199853040</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">7218962432</span>     堆上分配的，gc后会归还：  <span class="number">7199853048</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">7218962432</span>     堆上分配的，gc后会归还：  <span class="number">7199853048</span></span><br><span class="line">gc before <span class="built_in">new</span> start <span class="number">4</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">1600421888</span>     堆上分配的，gc后会归还：  <span class="number">1600134128</span></span><br><span class="line">slice <span class="number">0</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">1600430080</span>     堆上分配的，gc后会归还：  <span class="number">1600134560</span></span><br><span class="line">slice <span class="number">1000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">1656332288</span>     堆上分配的，gc后会归还：  <span class="number">1655853536</span></span><br><span class="line">slice <span class="number">2000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">1712513024</span>     堆上分配的，gc后会归还：  <span class="number">1711853840</span></span><br><span class="line">slice <span class="number">3000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">1768710144</span>     堆上分配的，gc后会归还：  <span class="number">1767854128</span></span><br><span class="line">slice <span class="number">4000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">1824890880</span>     堆上分配的，gc后会归还：  <span class="number">1823854192</span></span><br><span class="line">slice <span class="number">5000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">1881079808</span>     堆上分配的，gc后会归还：  <span class="number">1879854256</span></span><br><span class="line">slice <span class="number">6000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">1937276928</span>     堆上分配的，gc后会归还：  <span class="number">1935854336</span></span><br><span class="line">slice <span class="number">7000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">1993457664</span>     堆上分配的，gc后会归还：  <span class="number">1991854400</span></span><br><span class="line">slice <span class="number">8000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">2049662976</span>     堆上分配的，gc后会归还：  <span class="number">2047854704</span></span><br><span class="line">slice <span class="number">9000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">2105835520</span>     堆上分配的，gc后会归还：  <span class="number">2103854992</span></span><br><span class="line">slice <span class="number">10000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">2162024448</span>     堆上分配的，gc后会归还：  <span class="number">2159855056</span></span><br><span class="line">slice <span class="number">11000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">2218205184</span>     堆上分配的，gc后会归还：  <span class="number">2215855120</span></span><br><span class="line">slice <span class="number">12000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">2274410496</span>     堆上分配的，gc后会归还：  <span class="number">2271855200</span></span><br><span class="line">slice <span class="number">13000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">2330591232</span>     堆上分配的，gc后会归还：  <span class="number">2327855264</span></span><br><span class="line">slice <span class="number">14000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">2386771968</span>     堆上分配的，gc后会归还：  <span class="number">2383855328</span></span><br><span class="line">slice <span class="number">15000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">2442969088</span>     堆上分配的，gc后会归还：  <span class="number">2439855392</span></span><br><span class="line">slice <span class="number">16000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">2499149824</span>     堆上分配的，gc后会归还：  <span class="number">2495855456</span></span><br><span class="line">slice <span class="number">17000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">2555346944</span>     堆上分配的，gc后会归还：  <span class="number">2551855520</span></span><br><span class="line">slice <span class="number">18000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">2611544064</span>     堆上分配的，gc后会归还：  <span class="number">2607855824</span></span><br><span class="line">slice <span class="number">19000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">2667716608</span>     堆上分配的，gc后会归还：  <span class="number">2663856112</span></span><br><span class="line">slice <span class="number">20000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">2723921920</span>     堆上分配的，gc后会归还：  <span class="number">2719856192</span></span><br><span class="line">slice <span class="number">21000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">2780102656</span>     堆上分配的，gc后会归还：  <span class="number">2775856256</span></span><br><span class="line">slice <span class="number">22000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">2836283392</span>     堆上分配的，gc后会归还：  <span class="number">2831856320</span></span><br><span class="line">slice <span class="number">23000000</span> 系统内存： <span class="number">7665745432</span>    常驻内存： <span class="number">2892472320</span>     堆上分配的，gc后会归还：  <span class="number">2887856384</span></span><br><span class="line">slice <span class="number">24000000</span> 系统内存： <span class="number">7666073112</span>    常驻内存： <span class="number">2948661248</span>     堆上分配的，gc后会归还：  <span class="number">2943856448</span></span><br><span class="line">slice <span class="number">25000000</span> 系统内存： <span class="number">7666466328</span>    常驻内存： <span class="number">3004841984</span>     堆上分配的，gc后会归还：  <span class="number">2999856512</span></span><br><span class="line">slice <span class="number">26000000</span> 系统内存： <span class="number">7666859544</span>    常驻内存： <span class="number">3061039104</span>     堆上分配的，gc后会归还：  <span class="number">3055856576</span></span><br><span class="line">slice <span class="number">27000000</span> 系统内存： <span class="number">7667252760</span>    常驻内存： <span class="number">3117228032</span>     堆上分配的，gc后会归还：  <span class="number">3111856640</span></span><br><span class="line">slice <span class="number">28000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">3173433344</span>     堆上分配的，gc后会归还：  <span class="number">3167859936</span></span><br><span class="line">slice <span class="number">29000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">3229614080</span>     堆上分配的，gc后会归还：  <span class="number">3223857088</span></span><br><span class="line">slice <span class="number">30000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">3285794816</span>     堆上分配的，gc后会归还：  <span class="number">3279857376</span></span><br><span class="line">slice <span class="number">31000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">3341983744</span>     堆上分配的，gc后会归还：  <span class="number">3335857440</span></span><br><span class="line">slice <span class="number">32000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">3398172672</span>     堆上分配的，gc后会归还：  <span class="number">3391857504</span></span><br><span class="line">slice <span class="number">33000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">3454361600</span>     堆上分配的，gc后会归还：  <span class="number">3447857568</span></span><br><span class="line">slice <span class="number">34000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">3510550528</span>     堆上分配的，gc后会归还：  <span class="number">3503857632</span></span><br><span class="line">slice <span class="number">35000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">3566739456</span>     堆上分配的，gc后会归还：  <span class="number">3559857696</span></span><br><span class="line">slice <span class="number">36000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">3622936576</span>     堆上分配的，gc后会归还：  <span class="number">3615858000</span></span><br><span class="line">slice <span class="number">37000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">3679117312</span>     堆上分配的，gc后会归还：  <span class="number">3671858288</span></span><br><span class="line">slice <span class="number">38000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">3735306240</span>     堆上分配的，gc后会归还：  <span class="number">3727858352</span></span><br><span class="line">slice <span class="number">39000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">3791495168</span>     堆上分配的，gc后会归还：  <span class="number">3783858656</span></span><br><span class="line">slice <span class="number">40000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">3847684096</span>     堆上分配的，gc后会归还：  <span class="number">3839858960</span></span><br><span class="line">slice <span class="number">41000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">3903864832</span>     堆上分配的，gc后会归还：  <span class="number">3895859024</span></span><br><span class="line">slice <span class="number">42000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">3960061952</span>     堆上分配的，gc后会归还：  <span class="number">3951859328</span></span><br><span class="line">slice <span class="number">43000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">4016250880</span>     堆上分配的，gc后会归还：  <span class="number">4007859616</span></span><br><span class="line">slice <span class="number">44000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">4072431616</span>     堆上分配的，gc后会归还：  <span class="number">4063859680</span></span><br><span class="line">slice <span class="number">45000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">4128620544</span>     堆上分配的，gc后会归还：  <span class="number">4119859744</span></span><br><span class="line">slice <span class="number">46000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">4184809472</span>     堆上分配的，gc后会归还：  <span class="number">4175859808</span></span><br><span class="line">slice <span class="number">47000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">4240998400</span>     堆上分配的，gc后会归还：  <span class="number">4231859872</span></span><br><span class="line">slice <span class="number">48000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">4297179136</span>     堆上分配的，gc后会归还：  <span class="number">4287859936</span></span><br><span class="line">slice <span class="number">49000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">4353376256</span>     堆上分配的，gc后会归还：  <span class="number">4343860000</span></span><br><span class="line">slice <span class="number">50000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">4409565184</span>     堆上分配的，gc后会归还：  <span class="number">4399860064</span></span><br><span class="line">slice <span class="number">51000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">4465770496</span>     堆上分配的，gc后会归还：  <span class="number">4455860368</span></span><br><span class="line">slice <span class="number">52000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">4521943040</span>     堆上分配的，gc后会归还：  <span class="number">4511860656</span></span><br><span class="line">slice <span class="number">53000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">4578140160</span>     堆上分配的，gc后会归还：  <span class="number">4567860720</span></span><br><span class="line">slice <span class="number">54000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">4634320896</span>     堆上分配的，gc后会归还：  <span class="number">4623860784</span></span><br><span class="line">slice <span class="number">55000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">4690509824</span>     堆上分配的，gc后会归还：  <span class="number">4679860848</span></span><br><span class="line">slice <span class="number">56000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">4746690560</span>     堆上分配的，gc后会归还：  <span class="number">4735860912</span></span><br><span class="line">slice <span class="number">57000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">4802887680</span>     堆上分配的，gc后会归还：  <span class="number">4791860976</span></span><br><span class="line">slice <span class="number">58000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">4859068416</span>     堆上分配的，gc后会归还：  <span class="number">4847861040</span></span><br><span class="line">slice <span class="number">59000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">4915257344</span>     堆上分配的，gc后会归还：  <span class="number">4903861104</span></span><br><span class="line">slice <span class="number">60000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">4971446272</span>     堆上分配的，gc后会归还：  <span class="number">4959861168</span></span><br><span class="line">slice <span class="number">61000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">5027635200</span>     堆上分配的，gc后会归还：  <span class="number">5015861232</span></span><br><span class="line">slice <span class="number">62000000</span> 系统内存： <span class="number">7667318296</span>    常驻内存： <span class="number">5083815936</span>     堆上分配的，gc后会归还：  <span class="number">5071861296</span></span><br><span class="line">slice <span class="number">63000000</span> 系统内存： <span class="number">7667449368</span>    常驻内存： <span class="number">5140013056</span>     堆上分配的，gc后会归还：  <span class="number">5127861360</span></span><br><span class="line">slice <span class="number">64000000</span> 系统内存： <span class="number">7667842584</span>    常驻内存： <span class="number">5196201984</span>     堆上分配的，gc后会归还：  <span class="number">5183861424</span></span><br><span class="line">slice <span class="number">65000000</span> 系统内存： <span class="number">7668235800</span>    常驻内存： <span class="number">5252382720</span>     堆上分配的，gc后会归还：  <span class="number">5239861488</span></span><br><span class="line">slice <span class="number">66000000</span> 系统内存： <span class="number">7668629016</span>    常驻内存： <span class="number">5308579840</span>     堆上分配的，gc后会归还：  <span class="number">5295861552</span></span><br><span class="line">slice <span class="number">67000000</span> 系统内存： <span class="number">7669087768</span>    常驻内存： <span class="number">5364760576</span>     堆上分配的，gc后会归还：  <span class="number">5351861616</span></span><br><span class="line">slice <span class="number">68000000</span> 系统内存： <span class="number">7669480984</span>    常驻内存： <span class="number">5420957696</span>     堆上分配的，gc后会归还：  <span class="number">5407861680</span></span><br><span class="line">slice <span class="number">69000000</span> 系统内存： <span class="number">7669874200</span>    常驻内存： <span class="number">5477138432</span>     堆上分配的，gc后会归还：  <span class="number">5463861744</span></span><br><span class="line">slice <span class="number">70000000</span> 系统内存： <span class="number">7670267416</span>    常驻内存： <span class="number">5533327360</span>     堆上分配的，gc后会归还：  <span class="number">5519861808</span></span><br><span class="line">slice <span class="number">71000000</span> 系统内存： <span class="number">7670660632</span>    常驻内存： <span class="number">5589516288</span>     堆上分配的，gc后会归还：  <span class="number">5575861872</span></span><br><span class="line">slice <span class="number">72000000</span> 系统内存： <span class="number">7671119384</span>    常驻内存： <span class="number">5645705216</span>     堆上分配的，gc后会归还：  <span class="number">5631861936</span></span><br><span class="line">slice <span class="number">73000000</span> 系统内存： <span class="number">7671512600</span>    常驻内存： <span class="number">5701894144</span>     堆上分配的，gc后会归还：  <span class="number">5687862000</span></span><br><span class="line">slice <span class="number">74000000</span> 系统内存： <span class="number">7671905816</span>    常驻内存： <span class="number">5758083072</span>     堆上分配的，gc后会归还：  <span class="number">5743862064</span></span><br><span class="line">slice <span class="number">75000000</span> 系统内存： <span class="number">7672299032</span>    常驻内存： <span class="number">5814280192</span>     堆上分配的，gc后会归还：  <span class="number">5799862144</span></span><br><span class="line">slice <span class="number">76000000</span> 系统内存： <span class="number">7672692248</span>    常驻内存： <span class="number">5870460928</span>     堆上分配的，gc后会归还：  <span class="number">5855862224</span></span><br><span class="line">slice <span class="number">77000000</span> 系统内存： <span class="number">7673151000</span>    常驻内存： <span class="number">5926649856</span>     堆上分配的，gc后会归还：  <span class="number">5911862288</span></span><br><span class="line">slice <span class="number">78000000</span> 系统内存： <span class="number">7673544216</span>    常驻内存： <span class="number">5982846976</span>     堆上分配的，gc后会归还：  <span class="number">5967862352</span></span><br><span class="line">slice <span class="number">79000000</span> 系统内存： <span class="number">7673937432</span>    常驻内存： <span class="number">6039019520</span>     堆上分配的，gc后会归还：  <span class="number">6023862416</span></span><br><span class="line">slice <span class="number">80000000</span> 系统内存： <span class="number">7674330648</span>    常驻内存： <span class="number">6095216640</span>     堆上分配的，gc后会归还：  <span class="number">6079862480</span></span><br><span class="line">slice <span class="number">81000000</span> 系统内存： <span class="number">7674789400</span>    常驻内存： <span class="number">6151397376</span>     堆上分配的，gc后会归还：  <span class="number">6135862544</span></span><br><span class="line">slice <span class="number">82000000</span> 系统内存： <span class="number">7675182616</span>    常驻内存： <span class="number">6207594496</span>     堆上分配的，gc后会归还：  <span class="number">6191862624</span></span><br><span class="line">slice <span class="number">83000000</span> 系统内存： <span class="number">7675379224</span>    常驻内存： <span class="number">6263808000</span>     堆上分配的，gc后会归还：  <span class="number">6247863760</span></span><br><span class="line">slice <span class="number">84000000</span> 系统内存： <span class="number">7675379224</span>    常驻内存： <span class="number">6319964160</span>     堆上分配的，gc后会归还：  <span class="number">6303863824</span></span><br><span class="line">slice <span class="number">85000000</span> 系统内存： <span class="number">7675379224</span>    常驻内存： <span class="number">6376177664</span>     堆上分配的，gc后会归还：  <span class="number">6359864144</span></span><br><span class="line">slice <span class="number">86000000</span> 系统内存： <span class="number">7675379224</span>    常驻内存： <span class="number">6432358400</span>     堆上分配的，gc后会归还：  <span class="number">6415864432</span></span><br><span class="line">slice <span class="number">87000000</span> 系统内存： <span class="number">7675379224</span>    常驻内存： <span class="number">6488530944</span>     堆上分配的，gc后会归还：  <span class="number">6471858816</span></span><br><span class="line">slice <span class="number">88000000</span> 系统内存： <span class="number">7675379224</span>    常驻内存： <span class="number">6544711680</span>     堆上分配的，gc后会归还：  <span class="number">6527859104</span></span><br><span class="line">slice <span class="number">89000000</span> 系统内存： <span class="number">7675379224</span>    常驻内存： <span class="number">6600892416</span>     堆上分配的，gc后会归还：  <span class="number">6583859168</span></span><br><span class="line">slice <span class="number">90000000</span> 系统内存： <span class="number">7675575832</span>    常驻内存： <span class="number">6657081344</span>     堆上分配的，gc后会归还：  <span class="number">6639859232</span></span><br><span class="line">slice <span class="number">91000000</span> 系统内存： <span class="number">7676034584</span>    常驻内存： <span class="number">6713278464</span>     堆上分配的，gc后会归还：  <span class="number">6695859296</span></span><br><span class="line">slice <span class="number">92000000</span> 系统内存： <span class="number">7676427800</span>    常驻内存： <span class="number">6769459200</span>     堆上分配的，gc后会归还：  <span class="number">6751859360</span></span><br><span class="line">slice <span class="number">93000000</span> 系统内存： <span class="number">7676821016</span>    常驻内存： <span class="number">6825648128</span>     堆上分配的，gc后会归还：  <span class="number">6807859424</span></span><br><span class="line">slice <span class="number">94000000</span> 系统内存： <span class="number">7677214232</span>    常驻内存： <span class="number">6881837056</span>     堆上分配的，gc后会归还：  <span class="number">6863859488</span></span><br><span class="line">slice <span class="number">95000000</span> 系统内存： <span class="number">7677672984</span>    常驻内存： <span class="number">6938025984</span>     堆上分配的，gc后会归还：  <span class="number">6919859552</span></span><br><span class="line">slice <span class="number">96000000</span> 系统内存： <span class="number">7678066200</span>    常驻内存： <span class="number">6994206720</span>     堆上分配的，gc后会归还：  <span class="number">6975859616</span></span><br><span class="line">slice <span class="number">97000000</span> 系统内存： <span class="number">7678459416</span>    常驻内存： <span class="number">7050403840</span>     堆上分配的，gc后会归还：  <span class="number">7031859680</span></span><br><span class="line">slice <span class="number">98000000</span> 系统内存： <span class="number">7678852632</span>    常驻内存： <span class="number">7106592768</span>     堆上分配的，gc后会归还：  <span class="number">7087859744</span></span><br><span class="line">slice <span class="number">99000000</span> 系统内存： <span class="number">7679245848</span>    常驻内存： <span class="number">7162773504</span>     堆上分配的，gc后会归还：  <span class="number">7143859808</span></span><br><span class="line">isp占用的字节大小：「isp结构占用」 <span class="number">24</span></span><br><span class="line"><span class="keyword">for</span> all slice 系统内存： <span class="number">7679704600</span>    常驻内存： <span class="number">7218970624</span>     堆上分配的，gc后会归还：  <span class="number">7199859808</span></span><br><span class="line">耗时：  <span class="number">187</span>  S</span><br><span class="line"><span class="keyword">for</span> all end 系统内存： <span class="number">7679704600</span>    常驻内存： <span class="number">7218970624</span>     堆上分配的，gc后会归还：  <span class="number">7199857304</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">7679704600</span>    常驻内存： <span class="number">434176</span>     堆上分配的，gc后会归还：  <span class="number">131752</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">7679704600</span>    常驻内存： <span class="number">425984</span>     堆上分配的，gc后会归还：  <span class="number">131752</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">7679704600</span>    常驻内存： <span class="number">425984</span>     堆上分配的，gc后会归还：  <span class="number">131984</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">7679704600</span>    常驻内存： <span class="number">425984</span>     堆上分配的，gc后会归还：  <span class="number">131992</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">7679704600</span>    常驻内存： <span class="number">425984</span>     堆上分配的，gc后会归还：  <span class="number">131768</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">7679704600</span>    常驻内存： <span class="number">425984</span>     堆上分配的，gc后会归还：  <span class="number">131992</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">7679704600</span>    常驻内存： <span class="number">425984</span>     堆上分配的，gc后会归还：  <span class="number">131992</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">7679704600</span>    常驻内存： <span class="number">425984</span>     堆上分配的，gc后会归还：  <span class="number">131768</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">7679704600</span>    常驻内存： <span class="number">425984</span>     堆上分配的，gc后会归还：  <span class="number">131992</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">7679704600</span>    常驻内存： <span class="number">425984</span>     堆上分配的，gc后会归还：  <span class="number">131992</span></span><br><span class="line"><span class="keyword">for</span> gc end 系统内存： <span class="number">7679704600</span>    常驻内存： <span class="number">425984</span>     堆上分配的，gc后会归还：  <span class="number">131992</span></span><br></pre></td></tr></table></figure>
<h3 id="End"><a class="header-anchor" href="#End">¶</a>End</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>「36」defer panic源码分析</title>
    <url>/archives/b630d910.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p><a href="https://blog.imrcrab.com/archives/d586b949.html#more">「35」runtime:recover not correctly recover from panic</a>说到了v1.16修复的一个panic问题,这次顺带看看底层关于defer的处理.</p>
<span id="more"></span>
<h3 id="version"><a class="header-anchor" href="#version">¶</a>version</h3>
<blockquote>
<p>go version go1.14.14 darwin/amd64</p>
</blockquote>
<h3 id="defer处理"><a class="header-anchor" href="#defer处理">¶</a>defer处理</h3>
<h4 id="程序"><a class="header-anchor" href="#程序">¶</a>程序</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="汇编表示-「关于汇编的参考Plan-9汇编相关」"><a class="header-anchor" href="#汇编表示-「关于汇编的参考Plan-9汇编相关」">¶</a>汇编表示:「关于汇编的参考<a href="https://blog.imrcrab.com/archives/2ce846ed.html">Plan 9汇编相关</a>」</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0000</span> <span class="number">00000</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">7</span>)        TEXT    <span class="string">&quot;&quot;</span>.f(SB), ABIInternal, $<span class="number">128</span><span class="number">-0</span></span><br><span class="line"><span class="number">0x0000</span> <span class="number">00000</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">7</span>)        MOVQ    (TLS), CX</span><br><span class="line"><span class="number">0x0009</span> <span class="number">00009</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">7</span>)        CMPQ    SP, <span class="number">16</span>(CX)</span><br><span class="line"><span class="number">0x000d</span> <span class="number">00013</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">7</span>)        PCDATA  $<span class="number">0</span>, $<span class="number">-2</span></span><br><span class="line"><span class="number">0x000d</span> <span class="number">00013</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">7</span>)        JLS     <span class="number">119</span></span><br><span class="line"><span class="number">0x000f</span> <span class="number">00015</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">7</span>)        PCDATA  $<span class="number">0</span>, $<span class="number">-1</span></span><br><span class="line"><span class="number">0x000f</span> <span class="number">00015</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">7</span>)        ADDQ    $<span class="number">-128</span>, SP</span><br><span class="line"><span class="number">0x0013</span> <span class="number">00019</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">7</span>)        MOVQ    BP, <span class="number">120</span>(SP)</span><br><span class="line"><span class="number">0x0018</span> <span class="number">00024</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">7</span>)        LEAQ    <span class="number">120</span>(SP), BP</span><br><span class="line"><span class="number">0x001d</span> <span class="number">00029</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">7</span>)        FUNCDATA        $<span class="number">0</span>, gclocals·<span class="number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line"><span class="number">0x001d</span> <span class="number">00029</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">7</span>)        FUNCDATA        $<span class="number">1</span>, gclocals·<span class="number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line"><span class="number">0x001d</span> <span class="number">00029</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">8</span>)        MOVL    $<span class="number">24</span>, <span class="string">&quot;&quot;</span>..autotmp_0+<span class="number">24</span>(SP)</span><br><span class="line"><span class="number">0x0025</span> <span class="number">00037</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">8</span>)        LEAQ    <span class="string">&quot;&quot;</span>.sum·f(SB), AX</span><br><span class="line"><span class="number">0x002c</span> <span class="number">00044</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">8</span>)        MOVQ    AX, <span class="string">&quot;&quot;</span>..autotmp_0+<span class="number">48</span>(SP)</span><br><span class="line"><span class="number">0x0031</span> <span class="number">00049</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">8</span>)        MOVQ    $<span class="number">1</span>, <span class="string">&quot;&quot;</span>..autotmp_0+<span class="number">96</span>(SP)</span><br><span class="line"><span class="number">0x003a</span> <span class="number">00058</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">8</span>)        MOVQ    $<span class="number">2</span>, <span class="string">&quot;&quot;</span>..autotmp_0+<span class="number">104</span>(SP)</span><br><span class="line"><span class="number">0x0043</span> <span class="number">00067</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">8</span>)        LEAQ    <span class="string">&quot;&quot;</span>..autotmp_0+<span class="number">24</span>(SP), AX</span><br><span class="line"><span class="number">0x0048</span> <span class="number">00072</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">8</span>)        MOVQ    AX, (SP)</span><br><span class="line"><span class="number">0x004c</span> <span class="number">00076</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">8</span>)        PCDATA  $<span class="number">1</span>, $<span class="number">0</span></span><br><span class="line"><span class="number">0x004c</span> <span class="number">00076</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">8</span>)        CALL    runtime.deferprocStack(SB) <span class="comment">// 划重点,函数调用部分</span></span><br><span class="line"><span class="number">0x0051</span> <span class="number">00081</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">8</span>)        TESTL   AX, AX</span><br><span class="line"><span class="number">0x0053</span> <span class="number">00083</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">8</span>)        JNE     <span class="number">103</span></span><br><span class="line"><span class="number">0x0055</span> <span class="number">00085</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">8</span>)        JMP     <span class="number">87</span></span><br><span class="line"><span class="number">0x0057</span> <span class="number">00087</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">9</span>)        XCHGL   AX, AX</span><br><span class="line"><span class="number">0x0058</span> <span class="number">00088</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">9</span>)        CALL    runtime.deferreturn(SB)  <span class="comment">// 划重点,函数调用部分</span></span><br><span class="line"><span class="number">0x005d</span> <span class="number">00093</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">9</span>)        MOVQ    <span class="number">120</span>(SP), BP</span><br><span class="line"><span class="number">0x0062</span> <span class="number">00098</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">9</span>)        SUBQ    $<span class="number">-128</span>, SP</span><br><span class="line"><span class="number">0x0066</span> <span class="number">00102</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">9</span>)        RET</span><br><span class="line"><span class="number">0x0067</span> <span class="number">00103</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">8</span>)        XCHGL   AX, AX</span><br><span class="line"><span class="number">0x0068</span> <span class="number">00104</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">8</span>)        CALL    runtime.deferreturn(SB)  <span class="comment">// 划重点,函数调用部分</span></span><br><span class="line"><span class="number">0x006d</span> <span class="number">00109</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">8</span>)        MOVQ    <span class="number">120</span>(SP), BP</span><br><span class="line"><span class="number">0x0072</span> <span class="number">00114</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">8</span>)        SUBQ    $<span class="number">-128</span>, SP</span><br><span class="line"><span class="number">0x0076</span> <span class="number">00118</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">8</span>)        RET</span><br><span class="line"><span class="number">0x0077</span> <span class="number">00119</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">8</span>)        NOP</span><br><span class="line"><span class="number">0x0077</span> <span class="number">00119</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">7</span>)        PCDATA  $<span class="number">1</span>, $<span class="number">-1</span></span><br><span class="line"><span class="number">0x0077</span> <span class="number">00119</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">7</span>)        PCDATA  $<span class="number">0</span>, $<span class="number">-2</span></span><br><span class="line"><span class="number">0x0077</span> <span class="number">00119</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">7</span>)        CALL    runtime.morestack_noctxt(SB)</span><br><span class="line"><span class="number">0x007c</span> <span class="number">00124</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">7</span>)        PCDATA  $<span class="number">0</span>, $<span class="number">-1</span></span><br><span class="line"><span class="number">0x007c</span> <span class="number">00124</span> (src/main/ssp.<span class="keyword">go</span>:<span class="number">7</span>)        JMP     <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="defer官方定义"><a class="header-anchor" href="#defer官方定义">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/runtime2.go#L865">defer官方定义</a>:</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A _defer holds an entry on the list of deferred calls.</span></span><br><span class="line"><span class="comment">// If you add a field here, add code to clear it in freedefer and deferProcStack</span></span><br><span class="line"><span class="comment">// This struct must match the code in cmd/compile/internal/gc/reflect.go:deferstruct</span></span><br><span class="line"><span class="comment">// and cmd/compile/internal/gc/ssa.go:(*state).call.</span></span><br><span class="line"><span class="comment">// Some defers will be allocated on the stack and some on the heap. // 堆栈的不确定性</span></span><br><span class="line"><span class="comment">// All defers are logically part of the stack, so write barriers to</span></span><br><span class="line"><span class="comment">// initialize them are not required. All defers must be manually scanned,</span></span><br><span class="line"><span class="comment">// and for heap defers, marked.</span></span><br><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">	siz     <span class="type">int32</span> <span class="comment">// includes both arguments and results</span></span><br><span class="line">	started <span class="type">bool</span></span><br><span class="line">	heap    <span class="type">bool</span></span><br><span class="line">	<span class="comment">// openDefer indicates that this _defer is for a frame with open-coded</span></span><br><span class="line">	<span class="comment">// defers. We have only one defer record for the entire frame (which may</span></span><br><span class="line">	<span class="comment">// currently have 0, 1, or more defers active).</span></span><br><span class="line">	openDefer <span class="type">bool</span></span><br><span class="line">	sp        <span class="type">uintptr</span>  <span class="comment">// sp at time of defer</span></span><br><span class="line">	pc        <span class="type">uintptr</span>  <span class="comment">// pc at time of defer</span></span><br><span class="line">	fn        *funcval <span class="comment">// can be nil for open-coded defers 指向函数</span></span><br><span class="line">	_panic    *_panic  <span class="comment">// panic that is running defer</span></span><br><span class="line">	link      *_defer  <span class="comment">// 同一个goroutine所有的defer连城的链表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// If openDefer is true, the fields below record values about the stack</span></span><br><span class="line">	<span class="comment">// frame and associated function that has the open-coded defer(s). sp</span></span><br><span class="line">	<span class="comment">// above will be the sp for the frame, and pc will be address of the</span></span><br><span class="line">	<span class="comment">// deferreturn call in the function.</span></span><br><span class="line">	fd   unsafe.Pointer <span class="comment">// funcdata for the function associated with the frame</span></span><br><span class="line">	varp <span class="type">uintptr</span>        <span class="comment">// value of varp for the stack frame</span></span><br><span class="line">	<span class="comment">// framepc is the current pc associated with the stack frame. Together,</span></span><br><span class="line">	<span class="comment">// with sp above (which is the sp associated with the stack frame),</span></span><br><span class="line">	<span class="comment">// framepc/sp can be used as pc/sp pair to continue a stack trace via</span></span><br><span class="line">	<span class="comment">// gentraceback().</span></span><br><span class="line">	framepc <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="deferproc"><a class="header-anchor" href="#deferproc">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/panic.go#L218">deferproc</a></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a new deferred function fn with siz bytes of arguments.</span></span><br><span class="line"><span class="comment">// The compiler turns a defer statement into a call to this.</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferproc</span><span class="params">(siz <span class="type">int32</span>, fn *funcval)</span></span> &#123; <span class="comment">// arguments of fn follow fn</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	<span class="keyword">if</span> gp.m.curg != gp &#123;</span><br><span class="line">		<span class="comment">// go code on the system stack can&#x27;t defer</span></span><br><span class="line">		throw(<span class="string">&quot;defer on system stack&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// the arguments of fn are in a perilous state. The stack map</span></span><br><span class="line">	<span class="comment">// for deferproc does not describe them. So we can&#x27;t let garbage</span></span><br><span class="line">	<span class="comment">// collection or stack copying trigger until we&#x27;ve copied them out</span></span><br><span class="line">	<span class="comment">// to somewhere safe. The memmove below does that.</span></span><br><span class="line">	<span class="comment">// Until the copy completes, we can only call nosplit routines.</span></span><br><span class="line">    <span class="comment">// 获取调用者的sp「栈顶」</span></span><br><span class="line">	sp := getcallersp()</span><br><span class="line">	argp := <span class="type">uintptr</span>(unsafe.Pointer(&amp;fn)) + unsafe.Sizeof(fn)</span><br><span class="line">	callerpc := getcallerpc() <span class="comment">// 获取caller的pc</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从poll中获取或allocate一个</span></span><br><span class="line">	d := newdefer(siz)</span><br><span class="line">	<span class="keyword">if</span> d._panic != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;deferproc: d.panic != nil after newdefer&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 变量的初始化信息</span></span><br><span class="line">	d.link = gp._defer</span><br><span class="line">	gp._defer = d</span><br><span class="line">	d.fn = fn</span><br><span class="line">	d.pc = callerpc</span><br><span class="line">	d.sp = sp</span><br><span class="line">	<span class="keyword">switch</span> siz &#123; <span class="comment">// 关于siz的值的处理</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="comment">// Do nothing.</span></span><br><span class="line">	<span class="keyword">case</span> sys.PtrSize:</span><br><span class="line">		*(*<span class="type">uintptr</span>)(deferArgs(d)) = *(*<span class="type">uintptr</span>)(unsafe.Pointer(argp))</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		memmove(deferArgs(d), unsafe.Pointer(argp), <span class="type">uintptr</span>(siz))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// deferproc returns 0 normally.</span></span><br><span class="line">	<span class="comment">// a deferred func that stops a panic</span></span><br><span class="line">	<span class="comment">// makes the deferproc return 1.</span></span><br><span class="line">	<span class="comment">// the code the compiler generates always</span></span><br><span class="line">	<span class="comment">// checks the return value and jumps to the</span></span><br><span class="line">	<span class="comment">// end of the function if deferproc returns != 0.</span></span><br><span class="line">    <span class="comment">// 正常返回0,异常返回1</span></span><br><span class="line">	return0()</span><br><span class="line">	<span class="comment">// No code can go here - the C return register has</span></span><br><span class="line">	<span class="comment">// been set and must not be clobbered.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="newdefer"><a class="header-anchor" href="#newdefer">¶</a>newdefer</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate a Defer, usually using per-P pool. // pool池子</span></span><br><span class="line"><span class="comment">// Each defer must be released with freedefer.  The defer is not</span></span><br><span class="line"><span class="comment">// added to any defer chain yet.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This must not grow the stack because there may be a frame without</span></span><br><span class="line"><span class="comment">// stack map information when this is called.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newdefer</span><span class="params">(siz <span class="type">int32</span>)</span></span> *_defer &#123;</span><br><span class="line">	<span class="keyword">var</span> d *_defer</span><br><span class="line">	sc := deferclass(<span class="type">uintptr</span>(siz)) <span class="comment">// 计算sc</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	<span class="keyword">if</span> sc &lt; <span class="type">uintptr</span>(<span class="built_in">len</span>(p&#123;&#125;.deferpool)) &#123;</span><br><span class="line">		pp := gp.m.p.ptr()</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(pp.deferpool[sc]) == <span class="number">0</span> &amp;&amp; sched.deferpool[sc] != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// Take the slow path on the system stack so</span></span><br><span class="line">			<span class="comment">// we don&#x27;t grow newdefer&#x27;s stack.</span></span><br><span class="line">            <span class="comment">// 当缓存没有值了，就从全局pool中搞出来一部分</span></span><br><span class="line">			systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				lock(&amp;sched.deferlock)</span><br><span class="line">				<span class="keyword">for</span> <span class="built_in">len</span>(pp.deferpool[sc]) &lt; <span class="built_in">cap</span>(pp.deferpool[sc])/<span class="number">2</span> &amp;&amp; sched.deferpool[sc] != <span class="literal">nil</span> &#123;</span><br><span class="line">					d := sched.deferpool[sc]</span><br><span class="line">					sched.deferpool[sc] = d.link</span><br><span class="line">					d.link = <span class="literal">nil</span></span><br><span class="line">					pp.deferpool[sc] = <span class="built_in">append</span>(pp.deferpool[sc], d)</span><br><span class="line">				&#125;</span><br><span class="line">				unlock(&amp;sched.deferlock)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n := <span class="built_in">len</span>(pp.deferpool[sc]); n &gt; <span class="number">0</span> &#123;</span><br><span class="line">			d = pp.deferpool[sc][n<span class="number">-1</span>]</span><br><span class="line">			pp.deferpool[sc][n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">			pp.deferpool[sc] = pp.deferpool[sc][:n<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Allocate new defer+args.</span></span><br><span class="line">        <span class="comment">// 全局的pool不足/args过长</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			total := roundupsize(totaldefersize(<span class="type">uintptr</span>(siz)))</span><br><span class="line">			d = (*_defer)(mallocgc(total, deferType, <span class="literal">true</span>))</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">if</span> debugCachedWork &#123;</span><br><span class="line">			<span class="comment">// Duplicate the tail below so if there&#x27;s a</span></span><br><span class="line">			<span class="comment">// crash in checkPut we can tell if d was just</span></span><br><span class="line">			<span class="comment">// allocated or came from the pool.</span></span><br><span class="line">			d.siz = siz</span><br><span class="line">			d.link = gp._defer <span class="comment">// 与之前绑定的g形成链表</span></span><br><span class="line">			gp._defer = d</span><br><span class="line">			<span class="keyword">return</span> d</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	d.siz = siz</span><br><span class="line">	d.heap = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="deferprocStack"><a class="header-anchor" href="#deferprocStack">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/panic.go#L271">deferprocStack</a></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// deferprocStack queues a new deferred function with a defer record on the stack.</span></span><br><span class="line"><span class="comment">// The defer record must have its siz and fn fields initialized. siz和fn必须初始化</span></span><br><span class="line"><span class="comment">// All other fields can contain junk.</span></span><br><span class="line"><span class="comment">// The defer record must be immediately followed in memory by</span></span><br><span class="line"><span class="comment">// the arguments of the defer.</span></span><br><span class="line"><span class="comment">// Nosplit because the arguments on the stack won&#x27;t be scanned</span></span><br><span class="line"><span class="comment">// until the defer record is spliced into the gp._defer list.</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferprocStack</span><span class="params">(d *_defer)</span></span> &#123;</span><br><span class="line">	gp := getg() <span class="comment">// 获取当前的g,也说明一件事,这个defer和g是相关联的哦</span></span><br><span class="line">	<span class="keyword">if</span> gp.m.curg != gp &#123;</span><br><span class="line">		<span class="comment">// go code on the system stack can&#x27;t defer</span></span><br><span class="line">		throw(<span class="string">&quot;defer on system stack&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// siz and fn are already set.</span></span><br><span class="line">	<span class="comment">// The other fields are junk on entry to deferprocStack and</span></span><br><span class="line">	<span class="comment">// are initialized here. </span></span><br><span class="line">    <span class="comment">// 这里写的很清楚了,siz和fn必须 提前初始化,其它的变量在这初始化.</span></span><br><span class="line">	d.started = <span class="literal">false</span></span><br><span class="line">	d.heap = <span class="literal">false</span></span><br><span class="line">	d.openDefer = <span class="literal">false</span></span><br><span class="line">	d.sp = getcallersp()</span><br><span class="line">	d.pc = getcallerpc()</span><br><span class="line">	d.framepc = <span class="number">0</span></span><br><span class="line">	d.varp = <span class="number">0</span></span><br><span class="line">	<span class="comment">// The lines below implement:</span></span><br><span class="line">	<span class="comment">//   d.panic = nil</span></span><br><span class="line">	<span class="comment">//   d.fd = nil</span></span><br><span class="line">	<span class="comment">//   d.link = gp._defer</span></span><br><span class="line">	<span class="comment">//   gp._defer = d</span></span><br><span class="line">	<span class="comment">// But without write barriers. The first three are writes to</span></span><br><span class="line">	<span class="comment">// the stack so they don&#x27;t need a write barrier, and furthermore</span></span><br><span class="line">	<span class="comment">// are to uninitialized memory, so they must not use a write barrier.</span></span><br><span class="line">	<span class="comment">// The fourth write does not require a write barrier because we</span></span><br><span class="line">	<span class="comment">// explicitly mark all the defer structures, so we don&#x27;t need to</span></span><br><span class="line">	<span class="comment">// keep track of pointers to them with a write barrier.</span></span><br><span class="line">	*(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;d._panic)) = <span class="number">0</span></span><br><span class="line">	*(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;d.fd)) = <span class="number">0</span></span><br><span class="line">	*(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;d.link)) = <span class="type">uintptr</span>(unsafe.Pointer(gp._defer))</span><br><span class="line">	*(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;gp._defer)) = <span class="type">uintptr</span>(unsafe.Pointer(d))</span><br><span class="line"></span><br><span class="line">	return0()</span><br><span class="line">	<span class="comment">// No code can go here - the C return register has</span></span><br><span class="line">	<span class="comment">// been set and must not be clobbered.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="deferreturn"><a class="header-anchor" href="#deferreturn">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/panic.go#L528">deferreturn</a></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Run a deferred function if there is one.</span></span><br><span class="line"><span class="comment">// The compiler inserts a call to this at the end of any</span></span><br><span class="line"><span class="comment">// function which calls defer.</span></span><br><span class="line"><span class="comment">// If there is a deferred function, this will call runtime·jmpdefer,</span></span><br><span class="line"><span class="comment">// which will jump to the deferred function such that it appears</span></span><br><span class="line"><span class="comment">// to have been called by the caller of deferreturn at the point</span></span><br><span class="line"><span class="comment">// just before deferreturn was called. The effect is that deferreturn</span></span><br><span class="line"><span class="comment">// is called again and again until there are no more deferred functions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Declared as nosplit, because the function should not be preempted once we start</span></span><br><span class="line"><span class="comment">// modifying the caller&#x27;s frame in order to reuse the frame to call the deferred</span></span><br><span class="line"><span class="comment">// function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The single argument isn&#x27;t actually used - it just has its address</span></span><br><span class="line"><span class="comment">// taken so it can be matched against pending defers.</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferreturn</span><span class="params">(arg0 <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	d := gp._defer</span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123; <span class="comment">// 递归调用的终止条件</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	sp := getcallersp() </span><br><span class="line">	<span class="keyword">if</span> d.sp != sp &#123; <span class="comment">// 当前的调用栈和defer中是否相同</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> d.openDefer &#123;</span><br><span class="line">		done := runOpenDeferFrame(gp, d)</span><br><span class="line">		<span class="keyword">if</span> !done &#123;</span><br><span class="line">			throw(<span class="string">&quot;unfinished open-coded defers in deferreturn&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		gp._defer = d.link</span><br><span class="line">		freedefer(d)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Moving arguments around.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Everything called after this point must be recursively</span></span><br><span class="line">	<span class="comment">// nosplit because the garbage collector won&#x27;t know the form</span></span><br><span class="line">	<span class="comment">// of the arguments until the jmpdefer can flip the PC over to</span></span><br><span class="line">	<span class="comment">// fn.</span></span><br><span class="line">	<span class="keyword">switch</span> d.siz &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="comment">// Do nothing.</span></span><br><span class="line">	<span class="keyword">case</span> sys.PtrSize:</span><br><span class="line">		*(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;arg0)) = *(*<span class="type">uintptr</span>)(deferArgs(d))</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		memmove(unsafe.Pointer(&amp;arg0), deferArgs(d), <span class="type">uintptr</span>(d.siz))</span><br><span class="line">	&#125;</span><br><span class="line">	fn := d.fn</span><br><span class="line">	d.fn = <span class="literal">nil</span></span><br><span class="line">	gp._defer = d.link</span><br><span class="line">	freedefer(d) <span class="comment">// 释放d,重新放回pool中</span></span><br><span class="line">	<span class="comment">// If the defer function pointer is nil, force the seg fault to happen</span></span><br><span class="line">	<span class="comment">// here rather than in jmpdefer. gentraceback() throws an error if it is</span></span><br><span class="line">	<span class="comment">// called with a callback on an LR architecture and jmpdefer is on the</span></span><br><span class="line">	<span class="comment">// stack, because the stack trace can be incorrect in that case - see</span></span><br><span class="line">	<span class="comment">// issue #8153).</span></span><br><span class="line">	_ = fn.fn</span><br><span class="line">	jmpdefer(fn, <span class="type">uintptr</span>(unsafe.Pointer(&amp;arg0)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="panic"><a class="header-anchor" href="#panic">¶</a>panic</h3>
<h4 id="官方定义–"><a class="header-anchor" href="#官方定义–">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/runtime2.go#L903">官方定义–&gt;</a></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A _panic holds information about an active panic.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This is marked go:notinheap because _panic values must only ever</span></span><br><span class="line"><span class="comment">// live on the stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The argp and link fields are stack pointers, but don&#x27;t need special</span></span><br><span class="line"><span class="comment">// handling during stack growth: because they are pointer-typed and</span></span><br><span class="line"><span class="comment">// _panic values only live on the stack, regular stack pointer</span></span><br><span class="line"><span class="comment">// adjustment takes care of them.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:notinheap</span></span><br><span class="line"><span class="keyword">type</span> _panic <span class="keyword">struct</span> &#123;</span><br><span class="line">	argp      unsafe.Pointer <span class="comment">// pointer to arguments of deferred call run during panic; cannot move - known to liblink</span></span><br><span class="line">	arg       <span class="keyword">interface</span>&#123;&#125;    <span class="comment">// argument to panic</span></span><br><span class="line">	link      *_panic        <span class="comment">// link to earlier panic</span></span><br><span class="line">	pc        <span class="type">uintptr</span>        <span class="comment">// where to return to in runtime if this panic is bypassed</span></span><br><span class="line">	sp        unsafe.Pointer <span class="comment">// where to return to in runtime if this panic is bypassed</span></span><br><span class="line">	recovered <span class="type">bool</span>           <span class="comment">// whether this panic is over // recover标识</span></span><br><span class="line">	aborted   <span class="type">bool</span>           <span class="comment">// the panic was aborted // 终止标记</span></span><br><span class="line">	goexit    <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="gopanic"><a class="header-anchor" href="#gopanic">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/panic.go#L889">gopanic</a></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflectcallSave calls reflectcall after saving the caller&#x27;s pc and sp in the</span></span><br><span class="line"><span class="comment">// panic record. This allows the runtime to return to the Goexit defer processing</span></span><br><span class="line"><span class="comment">// loop, in the unusual case where the Goexit may be bypassed by a successful</span></span><br><span class="line"><span class="comment">// recover.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectcallSave</span><span class="params">(p *_panic, fn, arg unsafe.Pointer, argsize <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">		p.argp = unsafe.Pointer(getargp(<span class="number">0</span>))</span><br><span class="line">		p.pc = getcallerpc()</span><br><span class="line">		p.sp = unsafe.Pointer(getcallersp())</span><br><span class="line">	&#125;</span><br><span class="line">	reflectcall(<span class="literal">nil</span>, fn, arg, argsize, argsize)</span><br><span class="line">	<span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">		p.pc = <span class="number">0</span></span><br><span class="line">		p.sp = unsafe.Pointer(<span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The implementation of the predeclared function panic.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopanic</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	<span class="keyword">if</span> gp.m.curg != gp &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;panic: &quot;</span>)</span><br><span class="line">		printany(e)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		throw(<span class="string">&quot;panic on system stack&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gp.m.mallocing != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;panic: &quot;</span>)</span><br><span class="line">		printany(e)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		throw(<span class="string">&quot;panic during malloc&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gp.m.preemptoff != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;panic: &quot;</span>)</span><br><span class="line">		printany(e)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;preempt off reason: &quot;</span>)</span><br><span class="line">		<span class="built_in">print</span>(gp.m.preemptoff)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		throw(<span class="string">&quot;panic during preemptoff&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gp.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;panic: &quot;</span>)</span><br><span class="line">		printany(e)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		throw(<span class="string">&quot;panic holding locks&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> p _panic</span><br><span class="line">	p.arg = e</span><br><span class="line">	p.link = gp._panic</span><br><span class="line">	gp._panic = (*_panic)(noescape(unsafe.Pointer(&amp;p)))</span><br><span class="line"></span><br><span class="line">	atomic.Xadd(&amp;runningPanicDefers, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// By calculating getcallerpc/getcallersp here, we avoid scanning the</span></span><br><span class="line">	<span class="comment">// gopanic frame (stack scanning is slow...)</span></span><br><span class="line">	addOneOpenDeferFrame(gp, getcallerpc(), unsafe.Pointer(getcallersp()))</span><br><span class="line">	<span class="comment">//	遍历链表</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		d := gp._defer</span><br><span class="line">		<span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If defer was started by earlier panic or Goexit (and, since we&#x27;re back here, that triggered a new panic),</span></span><br><span class="line">		<span class="comment">// take defer off list. An earlier panic will not continue running, but we will make sure below that an</span></span><br><span class="line">		<span class="comment">// earlier Goexit does continue running.</span></span><br><span class="line">		<span class="keyword">if</span> d.started &#123; <span class="comment">// 已经启动</span></span><br><span class="line">			<span class="keyword">if</span> d._panic != <span class="literal">nil</span> &#123;</span><br><span class="line">				d._panic.aborted = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			d._panic = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">if</span> !d.openDefer &#123; <span class="comment">// 没有打开则跳过</span></span><br><span class="line">				<span class="comment">// For open-coded defers, we need to process the</span></span><br><span class="line">				<span class="comment">// defer again, in case there are any other defers</span></span><br><span class="line">				<span class="comment">// to call in the frame (not including the defer</span></span><br><span class="line">				<span class="comment">// call that caused the panic).</span></span><br><span class="line">				d.fn = <span class="literal">nil</span></span><br><span class="line">				gp._defer = d.link</span><br><span class="line">				freedefer(d)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Mark defer as started, but keep on list, so that traceback</span></span><br><span class="line">		<span class="comment">// can find and update the defer&#x27;s argument frame if stack growth</span></span><br><span class="line">		<span class="comment">// or a garbage collection happens before reflectcall starts executing d.fn.</span></span><br><span class="line">		d.started = <span class="literal">true</span> <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Record the panic that is running the defer.</span></span><br><span class="line">		<span class="comment">// If there is a new panic during the deferred call, that panic</span></span><br><span class="line">		<span class="comment">// will find d in the list and will mark d._panic (this panic) aborted.</span></span><br><span class="line">		<span class="comment">// 记录这个panic，如果在运行期间有了新的panic，标记这个Panic abort=true(强制终止)</span></span><br><span class="line">		d._panic = (*_panic)(noescape(unsafe.Pointer(&amp;p)))</span><br><span class="line"></span><br><span class="line">		done := <span class="literal">true</span></span><br><span class="line">		<span class="keyword">if</span> d.openDefer &#123;</span><br><span class="line">			done = runOpenDeferFrame(gp, d)</span><br><span class="line">			<span class="keyword">if</span> done &amp;&amp; !d._panic.recovered &#123;</span><br><span class="line">				addOneOpenDeferFrame(gp, <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			p.argp = unsafe.Pointer(getargp(<span class="number">0</span>))</span><br><span class="line">			<span class="comment">// 调用defer</span></span><br><span class="line">			reflectcall(<span class="literal">nil</span>, unsafe.Pointer(d.fn), deferArgs(d), <span class="type">uint32</span>(d.siz), <span class="type">uint32</span>(d.siz))</span><br><span class="line">		&#125;</span><br><span class="line">		p.argp = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// reflectcall did not panic. Remove d.</span></span><br><span class="line">		<span class="keyword">if</span> gp._defer != d &#123;</span><br><span class="line">			throw(<span class="string">&quot;bad defer entry in panic&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		d._panic = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// trigger shrinkage to test stack copy. See stack_test.go:TestStackPanic</span></span><br><span class="line">		<span class="comment">//GC()</span></span><br><span class="line"></span><br><span class="line">		pc := d.pc</span><br><span class="line">		sp := unsafe.Pointer(d.sp) <span class="comment">// must be pointer so it gets adjusted during stack copy</span></span><br><span class="line">		<span class="keyword">if</span> done &#123;</span><br><span class="line">			d.fn = <span class="literal">nil</span></span><br><span class="line">			gp._defer = d.link <span class="comment">// 遍历下一个</span></span><br><span class="line">			freedefer(d)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> p.recovered &#123; <span class="comment">// 已经有recover被调用</span></span><br><span class="line">			gp._panic = p.link</span><br><span class="line">			<span class="keyword">if</span> gp._panic != <span class="literal">nil</span> &amp;&amp; gp._panic.goexit &amp;&amp; gp._panic.aborted &#123;</span><br><span class="line">				<span class="comment">// A normal recover would bypass/abort the Goexit.  Instead,</span></span><br><span class="line">				<span class="comment">// we return to the processing loop of the Goexit.</span></span><br><span class="line">				gp.sigcode0 = <span class="type">uintptr</span>(gp._panic.sp)</span><br><span class="line">				gp.sigcode1 = <span class="type">uintptr</span>(gp._panic.pc)</span><br><span class="line">				mcall(recovery)</span><br><span class="line">				throw(<span class="string">&quot;bypassed recovery failed&quot;</span>) <span class="comment">// mcall should not return</span></span><br><span class="line">			&#125;</span><br><span class="line">			atomic.Xadd(&amp;runningPanicDefers, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> done &#123;</span><br><span class="line">				<span class="comment">// Remove any remaining non-started, open-coded</span></span><br><span class="line">				<span class="comment">// defer entries after a recover, since the</span></span><br><span class="line">				<span class="comment">// corresponding defers will be executed normally</span></span><br><span class="line">				<span class="comment">// (inline). Any such entry will become stale once</span></span><br><span class="line">				<span class="comment">// we run the corresponding defers inline and exit</span></span><br><span class="line">				<span class="comment">// the associated stack frame.</span></span><br><span class="line">				d := gp._defer</span><br><span class="line">				<span class="keyword">var</span> prev *_defer</span><br><span class="line">				<span class="keyword">for</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> d.openDefer &#123;</span><br><span class="line">						<span class="keyword">if</span> d.started &#123;</span><br><span class="line">							<span class="comment">// This defer is started but we</span></span><br><span class="line">							<span class="comment">// are in the middle of a</span></span><br><span class="line">							<span class="comment">// defer-panic-recover inside of</span></span><br><span class="line">							<span class="comment">// it, so don&#x27;t remove it or any</span></span><br><span class="line">							<span class="comment">// further defer entries</span></span><br><span class="line">							<span class="keyword">break</span></span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> prev == <span class="literal">nil</span> &#123;</span><br><span class="line">							gp._defer = d.link</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							prev.link = d.link</span><br><span class="line">						&#125;</span><br><span class="line">						newd := d.link</span><br><span class="line">						freedefer(d)</span><br><span class="line">						d = newd</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						prev = d</span><br><span class="line">						d = d.link</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			gp._panic = p.link</span><br><span class="line">			<span class="comment">// Aborted panics are marked but remain on the g.panic list.</span></span><br><span class="line">			<span class="comment">// Remove them from the list.</span></span><br><span class="line">			<span class="keyword">for</span> gp._panic != <span class="literal">nil</span> &amp;&amp; gp._panic.aborted &#123;</span><br><span class="line">				gp._panic = gp._panic.link</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> gp._panic == <span class="literal">nil</span> &#123; <span class="comment">// must be done with signal</span></span><br><span class="line">				gp.sig = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Pass information about recovering frame to recovery.</span></span><br><span class="line">			gp.sigcode0 = <span class="type">uintptr</span>(sp)</span><br><span class="line">			gp.sigcode1 = pc</span><br><span class="line">			mcall(recovery)</span><br><span class="line">			throw(<span class="string">&quot;recovery failed&quot;</span>) <span class="comment">// mcall should not return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ran out of deferred calls - old-school panic now</span></span><br><span class="line">	<span class="comment">// Because it is unsafe to call arbitrary user code after freezing</span></span><br><span class="line">	<span class="comment">// the world, we call preprintpanics to invoke all necessary Error</span></span><br><span class="line">	<span class="comment">// and String methods to prepare the panic strings before startpanic.</span></span><br><span class="line">	preprintpanics(gp._panic)</span><br><span class="line"></span><br><span class="line">	fatalpanic(gp._panic) <span class="comment">// should not return</span></span><br><span class="line">	*(*<span class="type">int</span>)(<span class="literal">nil</span>) = <span class="number">0</span>      <span class="comment">// not reached</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="recover"><a class="header-anchor" href="#recover">¶</a>recover</h3>
<h4 id="官方定义"><a class="header-anchor" href="#官方定义">¶</a>官方定义</h4>
<blockquote>
<p>panic中的一个bool型<br>
recovered bool           // whether this panic is over // recover标识</p>
</blockquote>
<h4 id="实现"><a class="header-anchor" href="#实现">¶</a>实现</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The implementation of the predeclared function recover.</span></span><br><span class="line"><span class="comment">// Cannot split the stack because it needs to reliably</span></span><br><span class="line"><span class="comment">// find the stack segment of its caller.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// TODO(rsc): Once we commit to CopyStackAlways,</span></span><br><span class="line"><span class="comment">// this doesn&#x27;t need to be nosplit.</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gorecover</span><span class="params">(argp <span class="type">uintptr</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="comment">// Must be in a function running as part of a deferred call during the panic.</span></span><br><span class="line">	<span class="comment">// Must be called from the topmost function of the call</span></span><br><span class="line">	<span class="comment">// (the function used in the defer statement).</span></span><br><span class="line">	<span class="comment">// p.argp is the argument pointer of that topmost deferred function call.</span></span><br><span class="line">	<span class="comment">// Compare against argp reported by caller.</span></span><br><span class="line">	<span class="comment">// If they match, the caller is the one who can recover.</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	p := gp._panic</span><br><span class="line">	<span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; !p.goexit &amp;&amp; !p.recovered &amp;&amp; argp == <span class="type">uintptr</span>(p.argp) &#123;</span><br><span class="line">		p.recovered = <span class="literal">true</span> <span class="comment">// revover标识为true</span></span><br><span class="line">		<span class="keyword">return</span> p.arg</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="拓展-「下面程序会输出什么值」"><a class="header-anchor" href="#拓展-「下面程序会输出什么值」">¶</a>拓展:「下面程序会输出什么值」</h3>
<h4 id="eg-1"><a class="header-anchor" href="#eg-1">¶</a>eg-1:</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!= <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;===&gt;&quot;</span>,err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	f()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!= <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;===&quot;</span>,err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">		<span class="built_in">panic</span>(<span class="number">1</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="output"><a class="header-anchor" href="#output">¶</a>output:</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">goroutine <span class="number">18</span> [running]:</span><br><span class="line">main.f.func2()</span><br><span class="line">        /Users/k/learn/<span class="keyword">go</span>-memory/src/main/ssp.<span class="keyword">go</span>:<span class="number">26</span> +<span class="number">0x6d</span></span><br><span class="line">created by main.f</span><br><span class="line">        /Users/k/learn/<span class="keyword">go</span>-memory/src/main/ssp.<span class="keyword">go</span>:<span class="number">24</span> +<span class="number">0x57</span></span><br></pre></td></tr></table></figure>
<h4 id="eg-2"><a class="header-anchor" href="#eg-2">¶</a>eg-2:</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!= <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;===&gt;&quot;</span>,err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	f()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!= <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;===&quot;</span>,err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="built_in">panic</span>(<span class="number">1</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="output-v2"><a class="header-anchor" href="#output-v2">¶</a>output:</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">=== <span class="number">1</span></span><br><span class="line">fatal <span class="type">error</span>: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">select</span> (no cases)]:</span><br><span class="line">main.main()</span><br><span class="line">        /Users/k/learn/<span class="keyword">go</span>-memory/src/main/ssp.<span class="keyword">go</span>:<span class="number">13</span> +<span class="number">0x4a</span></span><br></pre></td></tr></table></figure>
<h4 id="eg-3"><a class="header-anchor" href="#eg-3">¶</a>eg-3:</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!= <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;===&gt;&quot;</span>,err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	f()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!= <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;panic--f ===&quot;</span>,err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!= <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;===&quot;</span>,err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="built_in">panic</span>(<span class="number">1</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="output-v3"><a class="header-anchor" href="#output-v3">¶</a>output:</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">=== <span class="number">1</span></span><br><span class="line">fatal <span class="type">error</span>: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">select</span> (no cases)]:</span><br><span class="line">main.main()</span><br><span class="line">        /Users/k/learn/<span class="keyword">go</span>-memory/src/main/ssp.<span class="keyword">go</span>:<span class="number">13</span> +<span class="number">0x4a</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>源码</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>「35」runtime:recover not correctly recover from panic</title>
    <url>/archives/d586b949.html</url>
    <content><![CDATA[<p>接着上面的继续看看v1.16更新,runtime包改动的:</p>
<p><a href="https://github.com/golang/go/issues/43921">runtime: recover does not correctly recover from panic</a></p>
<p>简单的说原因,你认为下面程序的输出结果为what?</p>
<span id="more"></span>
<h3 id="eg"><a class="header-anchor" href="#eg">¶</a>eg</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		expect(<span class="number">1</span>, <span class="built_in">recover</span>())</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				expect(<span class="number">4</span>, <span class="built_in">recover</span>())</span><br><span class="line">			&#125;()</span><br><span class="line">			<span class="built_in">panic</span>(<span class="number">4</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="built_in">panic</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prevent open-coded defers; not executed.</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="built_in">panic</span>(<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">expect</span><span class="params">(n <span class="type">int</span>, err <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;expect&quot;</span>, n)</span><br><span class="line">	<span class="keyword">if</span> n != err &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;have %v, want %v&quot;</span>, err, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="理想型"><a class="header-anchor" href="#理想型">¶</a>理想型:</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expect 4</span><br><span class="line">expect 1</span><br></pre></td></tr></table></figure>
<h4 id="现实-「base-v1-14-15」"><a class="header-anchor" href="#现实-「base-v1-14-15」">¶</a>现实:「base v1.14.15」</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">./prog.<span class="keyword">go</span>:<span class="number">19</span>:<span class="number">3</span>: unreachable code</span><br><span class="line">Go vet exited.</span><br><span class="line"></span><br><span class="line">expect <span class="number">4</span></span><br><span class="line"><span class="built_in">panic</span>: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.main.func2()</span><br><span class="line">	/tmp/sandbox701237149/prog.<span class="keyword">go</span>:<span class="number">16</span> +<span class="number">0x65</span></span><br><span class="line">main.main()</span><br><span class="line">	/tmp/sandbox701237149/prog.<span class="keyword">go</span>:<span class="number">23</span> +<span class="number">0x45</span></span><br></pre></td></tr></table></figure>
<h3 id="why-发生了what"><a class="header-anchor" href="#why-发生了what">¶</a>why?发生了what?</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210217_110058.png" alt=""></p>
<blockquote>
<p>从上面的修改可以看出,是没有遍历现有的整个defer链表结构导致的.</p>
</blockquote>
<h3 id="defer、panic、recover是如何的结构连接在一起的呢"><a class="header-anchor" href="#defer、panic、recover是如何的结构连接在一起的呢">¶</a>defer、panic、recover是如何的结构连接在一起的呢?</h3>
<p><a href="https://blog.imrcrab.com/archives/b630d910.html#more">Next–&gt;</a></p>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>Runtime</tag>
        <tag>v1.14</tag>
      </tags>
  </entry>
  <entry>
    <title>「34」Go memory leak about RSS</title>
    <url>/archives/c0e329b8.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序:</h3>
<p>今天收到了封邮件 Go 1.16 release:</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210217_094336.webp" alt=""></p>
<p>进去了看了看全部的特性,发现有个关于memory  leak「RSS」相关的issues,去看看关于Go的RSS到底是怎么计算的,<br>
顺带也看看这个老哥为何会问内存泄露的问题.</p>
<span id="more"></span>
<h3 id="问题"><a class="header-anchor" href="#问题">¶</a>问题:</h3>
<p><a href="https://github.com/golang/go/issues/40448">runtime: memory leaked observed in go program #40448</a></p>
<h4 id="简述起因"><a class="header-anchor" href="#简述起因">¶</a>简述起因:</h4>
<blockquote>
<p>一个tcp接受程序导致RSS不断上升.<br>
这个起了5个goroutine协程来处理请求,但是请求处理结束后,RAM并没有趋于稳定或者降低.导致了看似的memory leak.</p>
</blockquote>
<ul>
<li>描述:</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210217_095036.png" alt=""></p>
<h4 id="关于RSS解释"><a class="header-anchor" href="#关于RSS解释">¶</a><a href="https://github.com/golang/go/issues/40448#issuecomment-666350046">关于RSS解释</a></h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The current minimum heap size of a Go program is 4mb. In addition to this the operating system threads that back goroutines should be added to that as well as some non heap memory used by the runtime. In your case this may be somewhere between 7 and 9mb.</span><br><span class="line"></span><br><span class="line">// 下面的解释划重点,简单的说就是RSS受很多值的影响:swap,avaliability values等</span><br><span class="line">Please remember that RSS is not how much memory is a program using, it is the resident segment size. Many things influence the value reported in RSS including the availability of swap and how much of the process may be swapped, if the system has reclaimed pages which we have madvise(DONTNEED) as part of the scavenger. A high RSS value does not necessarily mean that memory is not available for other processes, and so on.</span><br><span class="line"></span><br><span class="line">If memory consumption is your primary objective I would suggest investigating https://tinygo.org/ who may (I cannot confirm) have a different approach to memory allocation.</span><br><span class="line"></span><br><span class="line">I&#x27;ll defer to @randall77 and @mknyszek on the question of if the minimum heap size can be reduced.</span><br></pre></td></tr></table></figure>
<h3 id="解决办法"><a class="header-anchor" href="#解决办法">¶</a><a href="https://github.com/golang/go/issues/40448#issuecomment-667196117">解决办法</a></h3>
<ul>
<li>runtime/debug.SetGCPercent (设置gc的百分比,-1为不GC)</li>
<li>runtime.GC (调用系统GC)</li>
<li>runtime/debug.FreeOSMemory (accelerate the pace of returning unused pages to the OS)</li>
</ul>
<h3 id="其它方面的问题"><a class="header-anchor" href="#其它方面的问题">¶</a>其它方面的问题</h3>
<blockquote>
<p>从这里看的话,其实这个哥们的问题并不属于go的bug,只是说对于内存使用的理解有偏差,<br>
觉得go运行时环境很像是unix系统,内存有多少用多少,不会是用完就释放给系统.</p>
</blockquote>
<p>毕竟有句话: <em><strong>空间换时间</strong></em></p>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>Runtime</tag>
        <tag>v1.16</tag>
      </tags>
  </entry>
  <entry>
    <title>「33」Float IEEE标准</title>
    <url>/archives/257c4ce2.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p>前几天踩坑Float类型的计算问题,今天来系统的总结下float相关的知识点.</p>
<h3 id="掌握关键点"><a class="header-anchor" href="#掌握关键点">¶</a>掌握关键点:</h3>
<ul>
<li>float的标准是什么?</li>
<li>float的位计算规则</li>
<li>float场景</li>
<li>float计算改进</li>
</ul>
<span id="more"></span>
<h3 id="Float的标准"><a class="header-anchor" href="#Float的标准">¶</a>Float的标准?</h3>
<h4 id="国际组织定义"><a class="header-anchor" href="#国际组织定义">¶</a>国际组织定义</h4>
<p><a href="https://zh.wikipedia.org/wiki/IEEE_754">wiki–&gt;float定义</a></p>
<h4 id="表示方法"><a class="header-anchor" href="#表示方法">¶</a>表示方法</h4>
<p style=""><img data-src="https://math.now.sh?from=value%20%3D%20%20sign%20*%20exponent%20*%20fraction%20%0A" /></p><ul>
<li>value: 实际值</li>
<li>sign bit: 符号位</li>
<li>exponent bit: 指数便宜位</li>
<li>fraction: 分数值</li>
</ul>
<p>具体表示:</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210206_104959.webp" alt=""></p>
<h4 id="单精度和双精度"><a class="header-anchor" href="#单精度和双精度">¶</a>单精度和双精度</h4>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210206_110116.png" alt=""></p>
<h4 id="特殊值"><a class="header-anchor" href="#特殊值">¶</a>特殊值:</h4>
<ul>
<li>无穷: Inf</li>
<li>非数值: NaN</li>
</ul>
<h3 id="Float位计算规则"><a class="header-anchor" href="#Float位计算规则">¶</a>Float位计算规则</h3>
<h4 id="原码"><a class="header-anchor" href="#原码">¶</a>原码</h4>
<ul>
<li>高位表示符号位,其余为值; ⚠️:不能直接参与计算</li>
</ul>
<h4 id="反码"><a class="header-anchor" href="#反码">¶</a>反码</h4>
<ul>
<li>正数反码为本身</li>
<li>负数保留符号位,其它位按位取反.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如 :</span><br><span class="line">[+7]原 = 00000111 [+7]反 = 00000111 </span><br><span class="line">[-7]原 = 10000111 [-7]反 = 11111000</span><br></pre></td></tr></table></figure>
<h4 id="补码"><a class="header-anchor" href="#补码">¶</a>补码</h4>
<ul>
<li>正数的补码==原码==补码</li>
<li>负数补码=反码+1</li>
</ul>
<h4 id="计算形式"><a class="header-anchor" href="#计算形式">¶</a>计算形式:</h4>
<p style=""><img data-src="https://math.now.sh?from=v%20%3D%20%28-1%29%5Es%20*%20M%20*%202%5EE%20%0A" /></p><h5 id="说明"><a class="header-anchor" href="#说明">¶</a>说明:</h5>
<ul>
<li><img data-src="https://math.now.sh?inline=%28-1%29%5Es" style="display:inline-block;margin: 0;"/>表示符号位</li>
<li>M表示有效数字</li>
<li><img data-src="https://math.now.sh?inline=2%5EE" style="display:inline-block;margin: 0;"/>表示指数位</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="number">-0.5</span> =&gt; <span class="number">-0.1</span>[二进制]</span><br><span class="line">=&gt; <span class="number">-1.0</span> * <span class="number">2</span>^<span class="number">-1</span></span><br><span class="line">=&gt; (<span class="number">-1</span>)^<span class="number">1</span> * <span class="number">1.0</span> * <span class="number">2</span>^<span class="number">-1</span></span><br><span class="line">=&gt; s=<span class="number">1</span>，M=<span class="number">1.0</span>，E=<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h4 id="float类型的加法"><a class="header-anchor" href="#float类型的加法">¶</a>float类型的加法:</h4>
<ul>
<li>对阶</li>
<li>尾数</li>
<li>规格化</li>
<li>舍入处理</li>
<li>溢出判断</li>
</ul>
<h4 id="0-3-1-6"><a class="header-anchor" href="#0-3-1-6">¶</a><img data-src="https://math.now.sh?inline=0.3%2B1.6%3D%3F" style="display:inline-block;margin: 0;"/></h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=(0.3)10=(0011 1110 1001 1001 1001 1001 1001 1010)2    Sa=0    Ea=011 1110 1    Ma=1.001 1001 1001 1001 1001 1010</span><br><span class="line"></span><br><span class="line">b=(1.6)10=(0011 1111 1100 1100 1100 1100 1100 1101)2      Sb=0    Eb=011 1111 1     Mb=1.100 1100 1100 1100 1100 1101</span><br></pre></td></tr></table></figure>
<h5 id="对阶"><a class="header-anchor" href="#对阶">¶</a>对阶</h5>
<blockquote>
<p>简单的说就是需要阶码对齐,使其尾数可以进行加减运算,即:</p>
</blockquote>
<p>$ ⊿E = E_b -E_a $</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Ea&lt;Eb   Eb-Ea=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">Ma要调整为 <span class="number">0.0</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">10</span>       <span class="number">10</span></span><br><span class="line"></span><br><span class="line">E=<span class="number">011</span> <span class="number">1111</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h5 id="尾数"><a class="header-anchor" href="#尾数">¶</a>尾数</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="number">0.01001100110011001100110</span></span><br><span class="line">+ <span class="number">1.10011001100110011001101</span></span><br><span class="line">----------------------------</span><br><span class="line">  <span class="number">1.11100110011001100110011</span></span><br></pre></td></tr></table></figure>
<h5 id="规格化"><a class="header-anchor" href="#规格化">¶</a>规格化</h5>
<p>尾数的格式 $ 1.M $,尾数可能是非规格化的,所以需要左规和右规操作:</p>
<ul>
<li>左规操作: 尾数左移,阶码减值</li>
<li>右规操作: 尾数右移,阶码+值</li>
</ul>
<p>$ 目的: 1 \leq M &lt; 2 $</p>
<ul>
<li><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0">1.11100110011001100110011‬</label></li>
</ul>
<h5 id="舍入处理"><a class="header-anchor" href="#舍入处理">¶</a>舍入处理</h5>
<blockquote>
<p>四种舍入方式:</p>
</blockquote>
<ul>
<li>就近舍入: 四舍五入</li>
<li>朝+∞舍入</li>
<li>朝-∞舍入</li>
<li>朝0舍入</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">在对阶时，Ma有右移，且第一次最高为<span class="number">1</span>，第二次为<span class="number">0</span>，</span><br><span class="line">所以按<span class="string">&quot;0舍1入&quot;</span>， ==&gt; 精度丢失的关键, </span><br><span class="line">尾数运算结果调整为 <span class="number">1.11100110011001100110100</span></span><br></pre></td></tr></table></figure>
<h5 id="溢出判断"><a class="header-anchor" href="#溢出判断">¶</a>溢出判断</h5>
<blockquote>
<p>判断结果标准: 运算结果的阶码</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a+b=(<span class="number">0</span>  <span class="number">01111111</span>  <span class="number">11100110011001100110100</span>)<span class="number">2</span></span><br><span class="line">=(<span class="number">0011</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0100</span>)<span class="number">2</span>=(<span class="number">3</span>FF33334)<span class="number">16</span></span><br><span class="line"></span><br><span class="line">转为<span class="number">10</span>进制</span><br><span class="line"></span><br><span class="line">a+b=<span class="number">1.90000010</span></span><br></pre></td></tr></table></figure>
<h3 id="float计算改进"><a class="header-anchor" href="#float计算改进">¶</a>float计算改进</h3>
<h4 id="尽量避免使用高精度且重要的数据计算-如-¥"><a class="header-anchor" href="#尽量避免使用高精度且重要的数据计算-如-¥">¶</a>尽量避免使用高精度且重要的数据计算: 如: ¥</h4>
<h4 id="统一取舍位数"><a class="header-anchor" href="#统一取舍位数">¶</a>统一取舍位数</h4>
<ul>
<li>统一保留</li>
<li>统一取舍算法</li>
</ul>
<h4 id="建议用int-string类型"><a class="header-anchor" href="#建议用int-string类型">¶</a>建议用int/string类型</h4>
<ul>
<li>缺点:
<ul>
<li>牺牲性能</li>
<li>转换复杂</li>
</ul>
</li>
<li>优点:
<ul>
<li>提高准确度</li>
<li>处理可多元化</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>Float</tag>
        <tag>IEEE</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>「32」Go  Ticker 内存泄露</title>
    <url>/archives/53e1932f.html</url>
    <content><![CDATA[<h3 id="前序："><a class="header-anchor" href="#前序：">¶</a>前序：</h3>
<p>不知道你们有没有经历过这种情况：</p>
<blockquote>
<p>测试示例图片：</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210204_051425.webp" alt=""></p>
<span id="more"></span>
<blockquote>
<p>说的简单点：内存炸了呗…OOM</p>
</blockquote>
<h3 id="引言"><a class="header-anchor" href="#引言">¶</a>引言</h3>
<blockquote>
<p>go version go1.14.14 darwin/amd64</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">最近的坑是真的多，当然这种坑在大项目中，一不小心就写出来了,</span><br><span class="line"></span><br><span class="line">人多，项目大，各种各样的花式操作都出来了,在所难免，</span><br><span class="line">能做的就是分析问题，总结，记录，防止下次自己犯错，同时也可以加深理解。</span><br></pre></td></tr></table></figure>
<h3 id="起因："><a class="header-anchor" href="#起因：">¶</a>起因：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">XXX</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 业务代码 几十行...</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++&#123;</span><br><span class="line">	    ticker := time.NewTicker(<span class="number">10</span> * time.Second)</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">//模拟业务代码</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;defer close&quot;</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">                <span class="comment">// 业务代码.....</span></span><br><span class="line">                    fmt.Println(<span class="string">&quot;time 5&quot;</span>)</span><br><span class="line">                <span class="keyword">case</span> &lt;-doneChan:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 业务代码 几十行...</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="发生了什么？"><a class="header-anchor" href="#发生了什么？">¶</a>发生了什么？</h4>
<blockquote>
<p>上面的代码，不晓得看出来什么问题了么…</p>
</blockquote>
<h3 id="关键点："><a class="header-anchor" href="#关键点：">¶</a>关键点：</h3>
<p>ticker没有stop</p>
<p><a href="https://github.com/golang/go/blob/master/src/time/tick.go#L62">官方解释</a></p>
<h4 id="Ticker不能被回收导致"><a class="header-anchor" href="#Ticker不能被回收导致">¶</a>Ticker不能被回收导致</h4>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210204_053201.webp" alt=""></p>
<h4 id="为何不能被回收？"><a class="header-anchor" href="#为何不能被回收？">¶</a>为何不能被回收？</h4>
<h5 id="NewTicker实现："><a class="header-anchor" href="#NewTicker实现：">¶</a>NewTicker实现：</h5>
<p><a href="https://github.com/golang/go/blob/master/src/time/tick.go#L39">NewTicker官方实现</a></p>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/time.go#L203">startTimer底层实现</a></p>
<h6 id="addtimer"><a class="header-anchor" href="#addtimer">¶</a>addtimer</h6>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// addtimer adds a timer to the current P.</span></span><br><span class="line"><span class="comment">// This should only be called with a newly created timer.</span></span><br><span class="line"><span class="comment">// That avoids the risk of changing the when field of a timer in some P&#x27;s heap,</span></span><br><span class="line"><span class="comment">// which could cause the heap to become unsorted.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addtimer</span><span class="params">(t *timer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// when must never be negative; otherwise runtimer will overflow</span></span><br><span class="line">	<span class="comment">// during its delta calculation and never expire other runtime timers.</span></span><br><span class="line">	<span class="keyword">if</span> t.when &lt; <span class="number">0</span> &#123;</span><br><span class="line">		t.when = maxWhen</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.status != timerNoStatus &#123;</span><br><span class="line">		throw(<span class="string">&quot;addtimer called with initialized timer&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	t.status = timerWaiting</span><br><span class="line"></span><br><span class="line">	when := t.when</span><br><span class="line"></span><br><span class="line">	pp := getg().m.p.ptr() <span class="comment">// 获取当前的P</span></span><br><span class="line">	lock(&amp;pp.timersLock) <span class="comment">// 加锁</span></span><br><span class="line">	cleantimers(pp) <span class="comment">// 调整p.timers栈顶元素</span></span><br><span class="line">	doaddtimer(pp, t) <span class="comment">// t绑定下p</span></span><br><span class="line">	unlock(&amp;pp.timersLock) </span><br><span class="line"></span><br><span class="line">	wakeNetPoller(when)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="doaddtimer"><a class="header-anchor" href="#doaddtimer">¶</a>doaddtimer</h6>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// doaddtimer adds t to the current P&#x27;s heap.</span></span><br><span class="line"><span class="comment">// The caller must have locked the timers for pp.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doaddtimer</span><span class="params">(pp *p, t *timer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Timers rely on the network poller, so make sure the poller</span></span><br><span class="line">	<span class="comment">// has started.</span></span><br><span class="line">	<span class="keyword">if</span> netpollInited == <span class="number">0</span> &#123;</span><br><span class="line">		netpollGenericInit()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> t.pp != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;doaddtimer: P already set in timer&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	t.pp.set(pp)</span><br><span class="line">	i := <span class="built_in">len</span>(pp.timers)</span><br><span class="line">	pp.timers = <span class="built_in">append</span>(pp.timers, t) <span class="comment">// p上添加一个timer</span></span><br><span class="line">	siftupTimer(pp.timers, i) <span class="comment">// 堆调整算法</span></span><br><span class="line">	<span class="keyword">if</span> t == pp.timers[<span class="number">0</span>] &#123;</span><br><span class="line">		atomic.Store64(&amp;pp.timer0When, <span class="type">uint64</span>(t.when))</span><br><span class="line">	&#125;</span><br><span class="line">	atomic.Xadd(&amp;pp.numTimers, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展："><a class="header-anchor" href="#拓展：">¶</a>拓展：</h3>
<h4 id="cleantimers过程："><a class="header-anchor" href="#cleantimers过程：">¶</a>cleantimers过程：</h4>
<ul>
<li>判断长度</li>
<li>判断上一个timer状态</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cleantimers cleans up the head of the timer queue. This speeds up</span></span><br><span class="line"><span class="comment">// programs that create and delete timers; leaving them in the heap</span></span><br><span class="line"><span class="comment">// slows down addtimer. Reports whether no timer problems were found.</span></span><br><span class="line"><span class="comment">// The caller must have locked the timers for pp.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cleantimers</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(pp.timers) == <span class="number">0</span> &#123; <span class="comment">// 判断长度</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		t := pp.timers[<span class="number">0</span>] <span class="comment">//取第一个</span></span><br><span class="line">		<span class="keyword">if</span> t.pp.ptr() != pp &#123;</span><br><span class="line">			throw(<span class="string">&quot;cleantimers: bad p&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> s := atomic.Load(&amp;t.status); s &#123; <span class="comment">//需要判断状态</span></span><br><span class="line">		<span class="keyword">case</span> timerDeleted:</span><br><span class="line">			<span class="keyword">if</span> !atomic.Cas(&amp;t.status, s, timerRemoving) &#123; <span class="comment">//非删除中</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			dodeltimer0(pp) <span class="comment">//移除timer0</span></span><br><span class="line">			<span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerRemoving, timerRemoved) &#123;</span><br><span class="line">				badTimer()</span><br><span class="line">			&#125;</span><br><span class="line">			atomic.Xadd(&amp;pp.deletedTimers, <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">case</span> timerModifiedEarlier, timerModifiedLater: <span class="comment">// 修改前或者修改后的状态</span></span><br><span class="line">			<span class="keyword">if</span> !atomic.Cas(&amp;t.status, s, timerMoving) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Now we can change the when field.</span></span><br><span class="line">			t.when = t.nextwhen <span class="comment">// 指针后移</span></span><br><span class="line">			<span class="comment">// Move t to the right position.</span></span><br><span class="line">			dodeltimer0(pp) <span class="comment">// 删除最底下的元素</span></span><br><span class="line">			doaddtimer(pp, t) <span class="comment">// 重新绑定P和t的关系</span></span><br><span class="line">			<span class="keyword">if</span> s == timerModifiedEarlier &#123;</span><br><span class="line">				atomic.Xadd(&amp;pp.adjustTimers, <span class="number">-1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerMoving, timerWaiting) &#123;</span><br><span class="line">				badTimer()</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// Head of timers does not need adjustment.</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="dodeltimer0"><a class="header-anchor" href="#dodeltimer0">¶</a>dodeltimer0</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dodeltimer0 removes timer 0 from the current P&#x27;s heap.</span></span><br><span class="line"><span class="comment">// We are locked on the P when this is called.</span></span><br><span class="line"><span class="comment">// It reports whether it saw no problems due to races.</span></span><br><span class="line"><span class="comment">// The caller must have locked the timers for pp.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dodeltimer0</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t := pp.timers[<span class="number">0</span>]; t.pp.ptr() != pp &#123;</span><br><span class="line">		throw(<span class="string">&quot;dodeltimer0: wrong P&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		t.pp = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	last := <span class="built_in">len</span>(pp.timers) - <span class="number">1</span> <span class="comment">// 获取第一个timers</span></span><br><span class="line">	<span class="keyword">if</span> last &gt; <span class="number">0</span> &#123;</span><br><span class="line">		pp.timers[<span class="number">0</span>] = pp.timers[last] <span class="comment">// 栈底---&gt;栈顶</span></span><br><span class="line">	&#125;</span><br><span class="line">	pp.timers[last] = <span class="literal">nil</span> <span class="comment">// 置空</span></span><br><span class="line">	pp.timers = pp.timers[:last] <span class="comment">//重新赋值</span></span><br><span class="line">	<span class="keyword">if</span> last &gt; <span class="number">0</span> &#123;</span><br><span class="line">		siftdownTimer(pp.timers, <span class="number">0</span>)  <span class="comment">// 重新排序</span></span><br><span class="line">	&#125;</span><br><span class="line">	updateTimer0When(pp) <span class="comment">// 更新P中的when</span></span><br><span class="line">	atomic.Xadd(&amp;pp.numTimers, <span class="number">-1</span>) <span class="comment">// 更新数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h3>
<ul>
<li>
<p><a href="https://github.com/golang/go/blob/master/src/time/tick.go#L39">NewTicker官方实现</a></p>
</li>
<li>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/time.go#L203">StartTimer底层实现</a></p>
</li>
<li>
<p>atomic</p>
<ul>
<li>atomic.Store64</li>
<li>atomic.Xadd</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>ticker</tag>
        <tag>defer</tag>
      </tags>
  </entry>
  <entry>
    <title>「31」Float类型易踩的坑</title>
    <url>/archives/cb90ed2a.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p>最近快过年了吧，但是有很多需求要搞，，，，</p>
<p>突然来了个锅，被人投诉说数据统计的有问题，打开电脑一看，float类型的统计，「我慌了，float在统计中一直都很头疼。」</p>
<h3 id="触发点"><a class="header-anchor" href="#触发点">¶</a>触发点</h3>
<h4 id="先来看问题吧「写了个例子」："><a class="header-anchor" href="#先来看问题吧「写了个例子」：">¶</a>先来看问题吧「写了个例子」：</h4>
<blockquote>
<p>下面的结果，a应该是什么值？why？</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>go version go1.14.14 darwin/amd64</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> floatNumber <span class="type">float64</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	a := floatNumber / <span class="number">0</span></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="输出结果："><a class="header-anchor" href="#输出结果：">¶</a>输出结果：</h5>
<p>NAN</p>
<h5 id="why-「究其根源」"><a class="header-anchor" href="#why-「究其根源」">¶</a>why?「究其根源」</h5>
<p><a href="https://golang.google.cn/ref/spec#Representability">官方解释</a></p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210204_030335.png" alt=""></p>
<blockquote>
<p>简单的说就是 0/0 为负无穷大，所以为 NAN.</p>
</blockquote>
<h3 id="如何规避？"><a class="header-anchor" href="#如何规避？">¶</a>如何规避？</h3>
<ul>
<li>提前判断分母，为0，不计算「根源解决」</li>
<li>利用math.IsNaN(xxx)，选择性跳过。 「治标」</li>
</ul>
<h3 id="拓展："><a class="header-anchor" href="#拓展：">¶</a>拓展：</h3>
<h4 id="下面这个输出什么？"><a class="header-anchor" href="#下面这个输出什么？">¶</a>下面这个输出什么？</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> number <span class="type">int</span></span><br><span class="line">	fmt.Println(number / <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="输出结果：-v2"><a class="header-anchor" href="#输出结果：-v2">¶</a>输出结果：</h5>
<blockquote>
<p>division by zero</p>
</blockquote>
<h5 id="why"><a class="header-anchor" href="#why">¶</a>why?</h5>
<ul>
<li>除数不能为0.</li>
</ul>
<h4 id="关于float类型"><a class="header-anchor" href="#关于float类型">¶</a>关于float类型</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">这么简单，估计会被说很菜，，，，</span><br><span class="line"></span><br><span class="line">关于float类型的使用和注意事项「和语言无关」，一直都很零散，下来整理下，系统性的学习学习。</span><br></pre></td></tr></table></figure>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
<p>快过年了，提前预祝大家新年快乐。。。。</p>
<p>🧨🧨🧨🧨🧨🧨🧨🧨🧨🧨🧨🧨🧨🧨🧨</p>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>Golang</tag>
        <tag>Float</tag>
        <tag>IEEE</tag>
      </tags>
  </entry>
  <entry>
    <title>「30」redis rdb源码-1</title>
    <url>/archives/44b34745.html</url>
    <content><![CDATA[<blockquote>
<p>RDB和AOF常常被提起,好奇RDB这个到底是怎么实现的,这样才能运用的更加灵活和精准.</p>
</blockquote>
<h3 id="学完预期的目标"><a class="header-anchor" href="#学完预期的目标">¶</a>学完预期的目标:</h3>
<ul>
<li>学习数据异步处理流程</li>
<li>RDB持久化数据的关键过程</li>
<li>RDB的缺点</li>
<li>RDB适用的场景</li>
<li>RDB改进点或bug?</li>
<li>数据持久化,应该是个什么过程?</li>
</ul>
<span id="more"></span>
<h3 id="Version"><a class="header-anchor" href="#Version">¶</a>Version</h3>
<blockquote>
<p>Redis 6.0.9</p>
</blockquote>
<h3 id="实现流程"><a class="header-anchor" href="#实现流程">¶</a>实现流程:</h3>
<ul>
<li>这里罗列了几个比较重要的过程:</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/redis-rdb-1.png" alt=""></p>
<h4 id="rdbSaveBackground"><a class="header-anchor" href="#rdbSaveBackground">¶</a>rdbSaveBackground</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rdbSaveBackground</span><span class="params">(<span class="type">char</span> *filename, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> childpid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">hasActiveChildProcess</span>()) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    server.dirty_before_bgsave = server.dirty;</span><br><span class="line">    server.lastbgsave_try = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">openChildInfoPipe</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((childpid = <span class="built_in">redisFork</span>(CHILD_TYPE_RDB)) == <span class="number">0</span>) &#123; <span class="comment">// fork一个子进程</span></span><br><span class="line">        <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        <span class="built_in">redisSetProcTitle</span>(<span class="string">&quot;redis-rdb-bgsave&quot;</span>); <span class="comment">// 设置标题</span></span><br><span class="line">        <span class="built_in">redisSetCpuAffinity</span>(server.bgsave_cpulist); <span class="comment">// 设置cpu亲和力</span></span><br><span class="line">        retval = <span class="built_in">rdbSave</span>(filename,rsi); <span class="comment">// rdb保存</span></span><br><span class="line">        <span class="keyword">if</span> (retval == C_OK) &#123;</span><br><span class="line">            <span class="built_in">sendChildCOWInfo</span>(CHILD_TYPE_RDB, <span class="string">&quot;RDB&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exitFromChild</span>((retval == C_OK) ? <span class="number">0</span> : <span class="number">1</span>); <span class="comment">// 子进程退出</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123; <span class="comment">// -1 发生错误了</span></span><br><span class="line">            <span class="built_in">closeChildInfoPipe</span>();</span><br><span class="line">            server.lastbgsave_status = C_ERR;</span><br><span class="line">            <span class="built_in">serverLog</span>(LL_WARNING,<span class="string">&quot;Can&#x27;t save in background: fork: %s&quot;</span>,</span><br><span class="line">                <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">serverLog</span>(LL_NOTICE,<span class="string">&quot;Background saving started by pid %d&quot;</span>,childpid); <span class="comment">// 下面是一些重新初始化的部分</span></span><br><span class="line">        server.rdb_save_time_start = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">        server.rdb_child_pid = childpid;</span><br><span class="line">        server.rdb_child_type = RDB_CHILD_TYPE_DISK;</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK; <span class="comment">/* unreached */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="rdbSaveInfo「struct」"><a class="header-anchor" href="#rdbSaveInfo「struct」">¶</a>rdbSaveInfo「struct」</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This structure can be optionally passed to RDB save/load functions in</span></span><br><span class="line"><span class="comment"> * order to implement additional functionalities, by storing and loading</span></span><br><span class="line"><span class="comment"> * metadata to the RDB file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Currently the only use is to select a DB at load time, useful in</span></span><br><span class="line"><span class="comment"> * replication in order to make sure that chained slaves (slaves of slaves)</span></span><br><span class="line"><span class="comment"> * select the correct DB and are able to accept the stream coming from the</span></span><br><span class="line"><span class="comment"> * top-level master. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">rdbSaveInfo</span> &#123;</span><br><span class="line">    <span class="comment">/* Used saving and loading. */</span></span><br><span class="line">    <span class="type">int</span> repl_stream_db;  <span class="comment">/* DB to select in server.master client. */</span> <span class="comment">// 选中复制的db</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Used only loading. */</span></span><br><span class="line">    <span class="type">int</span> repl_id_is_set;  <span class="comment">/* True if repl_id field is set. */</span></span><br><span class="line">    <span class="type">char</span> repl_id[CONFIG_RUN_ID_SIZE+<span class="number">1</span>];     <span class="comment">/* Replication ID. */</span> 副本ID</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_offset;                  <span class="comment">/* Replication offset. */</span> 偏移量</span><br><span class="line">&#125; rdbSaveInfo;</span><br></pre></td></tr></table></figure>
<h4 id="rdbSave"><a class="header-anchor" href="#rdbSave">¶</a>rdbSave</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Save the DB on disk. Return C_ERR on error, C_OK on success. */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rdbSave</span><span class="params">(<span class="type">char</span> *filename, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line">    <span class="type">char</span> cwd[MAXPATHLEN]; <span class="comment">/* Current working dir path for error messages. */</span></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    rio rdb;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-%d.rdb&quot;</span>, (<span class="type">int</span>) <span class="built_in">getpid</span>()); <span class="comment">// 临时文件命名 pid</span></span><br><span class="line">    fp = <span class="built_in">fopen</span>(tmpfile,<span class="string">&quot;w&quot;</span>); <span class="comment">// 只读模式</span></span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        <span class="type">char</span> *cwdp = <span class="built_in">getcwd</span>(cwd,MAXPATHLEN);</span><br><span class="line">        <span class="built_in">serverLog</span>(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Failed opening the RDB file %s (in server root dir %s) &quot;</span></span><br><span class="line">            <span class="string">&quot;for saving: %s&quot;</span>,</span><br><span class="line">            filename,</span><br><span class="line">            cwdp ? cwdp : <span class="string">&quot;unknown&quot;</span>,</span><br><span class="line">            <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rioInitWithFile</span>(&amp;rdb,fp); <span class="comment">// rdb初始化</span></span><br><span class="line">    <span class="built_in">startSaving</span>(RDBFLAGS_NONE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_save_incremental_fsync)</span><br><span class="line">        <span class="built_in">rioSetAutoSync</span>(&amp;rdb,REDIS_AUTOSYNC_BYTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">rdbSaveRio</span>(&amp;rdb,&amp;error,RDBFLAGS_NONE,rsi) == C_ERR) &#123; <span class="comment">// rdb保存「重点」</span></span><br><span class="line">        errno = error;</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure data will not remain on the OS&#x27;s output buffers */</span> <span class="comment">// 刷新fp文件中内容</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fflush</span>(fp)) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fsync</span>(<span class="built_in">fileno</span>(fp))) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fclose</span>(fp)) &#123; fp = <span class="literal">NULL</span>; <span class="keyword">goto</span> werr; &#125;</span><br><span class="line">    fp = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Use RENAME to make sure the DB file is changed atomically only</span></span><br><span class="line"><span class="comment">     * if the generate DB file is ok. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">rename</span>(tmpfile,filename) == <span class="number">-1</span>) &#123; <span class="comment">// 临时文件重新命名</span></span><br><span class="line">        <span class="type">char</span> *cwdp = <span class="built_in">getcwd</span>(cwd,MAXPATHLEN);</span><br><span class="line">        <span class="built_in">serverLog</span>(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Error moving temp DB file %s on the final &quot;</span></span><br><span class="line">            <span class="string">&quot;destination %s (in server root dir %s): %s&quot;</span>,</span><br><span class="line">            tmpfile,</span><br><span class="line">            filename,</span><br><span class="line">            cwdp ? cwdp : <span class="string">&quot;unknown&quot;</span>,</span><br><span class="line">            <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">unlink</span>(tmpfile);</span><br><span class="line">        <span class="built_in">stopSaving</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">serverLog</span>(LL_NOTICE,<span class="string">&quot;DB saved on disk&quot;</span>); <span class="comment">// 日志保存</span></span><br><span class="line">    server.dirty = <span class="number">0</span>; <span class="comment">// 最后的变量该置空&amp;该保存状态的</span></span><br><span class="line">    server.lastsave = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    server.lastbgsave_status = C_OK;</span><br><span class="line">    <span class="built_in">stopSaving</span>(<span class="number">1</span>); <span class="comment">// 停止保存</span></span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    <span class="built_in">serverLog</span>(LL_WARNING,<span class="string">&quot;Write error saving DB on disk: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    <span class="keyword">if</span> (fp) <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="built_in">unlink</span>(tmpfile);</span><br><span class="line">    <span class="built_in">stopSaving</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="rdbSaveRio"><a class="header-anchor" href="#rdbSaveRio">¶</a>rdbSaveRio</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Produces a dump of the database in RDB format sending it to the specified</span></span><br><span class="line"><span class="comment"> * Redis I/O channel. On success C_OK is returned, otherwise C_ERR</span></span><br><span class="line"><span class="comment"> * is returned and part of the output, or all the output, can be</span></span><br><span class="line"><span class="comment"> * missing because of I/O errors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When the function returns C_ERR and if &#x27;error&#x27; is not NULL, the</span></span><br><span class="line"><span class="comment"> * integer pointed by &#x27;error&#x27; is set to the value of errno just after the I/O</span></span><br><span class="line"><span class="comment"> * error. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rdbSaveRio</span><span class="params">(rio *rdb, <span class="type">int</span> *error, <span class="type">int</span> rdbflags, rdbSaveInfo *rsi)</span> &#123;</span><br><span class="line">    dictIterator *di = <span class="literal">NULL</span>;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="type">char</span> magic[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">uint64_t</span> cksum;</span><br><span class="line">    <span class="type">size_t</span> processed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_checksum)</span><br><span class="line">        rdb-&gt;update_cksum = rioGenericUpdateChecksum;</span><br><span class="line">    <span class="built_in">snprintf</span>(magic,<span class="keyword">sizeof</span>(magic),<span class="string">&quot;REDIS%04d&quot;</span>,RDB_VERSION); <span class="comment">// 04指的是版本号</span></span><br><span class="line">    <span class="keyword">if</span> (rdbWriteRaw(rdb,magic,<span class="number">9</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveInfoAuxFields(rdb,rdbflags,rsi) == <span class="number">-1</span>) <span class="keyword">goto</span> werr; <span class="comment">// redis辅助信息，返回了-1，代表还是比较重要的</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveModulesAux(rdb, REDISMODULE_AUX_BEFORE_RDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr; <span class="comment">// 模块化信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">        redisDb *db = server.db+j;</span><br><span class="line">        dict *d = db-&gt;dict;</span><br><span class="line">        <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 大小为0，则跳过</span></span><br><span class="line">        di = dictGetSafeIterator(d); <span class="comment">// 分配内存，返回迭代器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Write the SELECT DB opcode */</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,j) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Write the RESIZE DB opcode. */</span></span><br><span class="line">        <span class="type">uint64_t</span> db_size, expires_size;</span><br><span class="line">        db_size = dictSize(db-&gt;dict);</span><br><span class="line">        expires_size = dictSize(db-&gt;expires);</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,db_size) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,expires_size) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Iterate this DB writing every entry */</span> <span class="comment">// 遍历每一个entry</span></span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123; <span class="comment">// dictNext为函数取值的方式</span></span><br><span class="line">            sds keystr = dictGetKey(de); <span class="comment">// 获取key</span></span><br><span class="line">            robj key, *o = dictGetVal(de); <span class="comment">//获取value</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> expire;</span><br><span class="line"></span><br><span class="line">            initStaticStringObject(key,keystr); <span class="comment">// 初始化obj，「类型，数量，指针指向的地址」</span></span><br><span class="line">            expire = getExpire(db,&amp;key); <span class="comment">// 通过key来找过期时间</span></span><br><span class="line">            <span class="keyword">if</span> (rdbSaveKeyValuePair(rdb,&amp;key,o,expire) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When this RDB is produced as part of an AOF rewrite, move</span></span><br><span class="line"><span class="comment">             * accumulated diff from parent to child while rewriting in</span></span><br><span class="line"><span class="comment">             * order to have a smaller final write. */</span>  <span class="comment">// 把父级别的积累缓冲到缓冲区，在重写完成后串联在一起。</span></span><br><span class="line">            <span class="keyword">if</span> (rdbflags &amp; RDBFLAGS_AOF_PREAMBLE &amp;&amp;</span><br><span class="line">                rdb-&gt;processed_bytes &gt; processed+AOF_READ_DIFF_INTERVAL_BYTES)</span><br><span class="line">            &#123;</span><br><span class="line">                processed = rdb-&gt;processed_bytes;</span><br><span class="line">                aofReadDiffFromParent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di); <span class="comment">// 内存释放，在每一次循环中，用完就释放，「内存周期管理」</span></span><br><span class="line">        di = <span class="literal">NULL</span>; <span class="comment">/* So that we don&#x27;t release it again on error. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are storing the replication information on disk, persist</span></span><br><span class="line"><span class="comment">     * the script cache as well: on successful PSYNC after a restart, we need</span></span><br><span class="line"><span class="comment">     * to be able to process any EVALSHA inside the replication backlog the</span></span><br><span class="line"><span class="comment">     * master will send us. */</span></span><br><span class="line">    <span class="keyword">if</span> (rsi &amp;&amp; dictSize(server.lua_scripts)) &#123;</span><br><span class="line">        di = dictGetIterator(server.lua_scripts);</span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            robj *body = dictGetVal(de);</span><br><span class="line">            <span class="keyword">if</span> (rdbSaveAuxField(rdb,<span class="string">&quot;lua&quot;</span>,<span class="number">3</span>,body-&gt;ptr,sdslen(body-&gt;ptr)) == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">goto</span> werr;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        di = <span class="literal">NULL</span>; <span class="comment">/* So that we don&#x27;t release it again on error. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveModulesAux(rdb, REDISMODULE_AUX_AFTER_RDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr; <span class="comment">// 再次保存辅助的信息，「上一步可能会改变」</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* EOF opcode */</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_EOF) == <span class="number">-1</span>) <span class="keyword">goto</span> werr; <span class="comment">// 保存文件类型，结束位置的标志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CRC64 checksum. It will be zero if checksum computation is disabled, the</span></span><br><span class="line"><span class="comment">     * loading code skips the check in this case. */</span></span><br><span class="line">    cksum = rdb-&gt;cksum;</span><br><span class="line">    memrev64ifbe(&amp;cksum);</span><br><span class="line">    <span class="keyword">if</span> (rioWrite(rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr; <span class="comment">// checksum 校验位插入文件最后</span></span><br><span class="line">    <span class="keyword">return</span> C_OK; <span class="comment">// 返回0，一切ok</span></span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    <span class="keyword">if</span> (error) *error = errno;</span><br><span class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di); <span class="comment">// 一旦错误发生后，及时释放内存</span></span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="rdbSaveKeyValuePair实现"><a class="header-anchor" href="#rdbSaveKeyValuePair实现">¶</a>rdbSaveKeyValuePair实现</h4>
<ul>
<li>错误返回-1,正常返回1,其它返回0</li>
<li>主逻辑只需负责入参和返回值「抽象」</li>
<li>优先级: expire &gt; lru &gt; lfu &gt; [&lt;key,values&gt;]</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Save a key-value pair, with expire time, type, key, value.</span></span><br><span class="line"><span class="comment"> * On error -1 is returned.</span></span><br><span class="line"><span class="comment"> * On success if the key was actually saved 1 is returned, otherwise 0</span></span><br><span class="line"><span class="comment"> * is returned (the key was already expired). */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rdbSaveKeyValuePair</span><span class="params">(rio *rdb, robj *key, robj *val, <span class="type">long</span> <span class="type">long</span> expiretime)</span> &#123;</span><br><span class="line">    <span class="type">int</span> savelru = server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU;</span><br><span class="line">    <span class="type">int</span> savelfu = server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  保存过期时间</span></span><br><span class="line">    <span class="comment">/* Save the expire time */</span></span><br><span class="line">    <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_EXPIRETIME_MS) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveMillisecondTime(rdb,expiretime) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LRU方式保存</span></span><br><span class="line">    <span class="comment">/* Save the LRU info. */</span></span><br><span class="line">    <span class="keyword">if</span> (savelru) &#123;</span><br><span class="line">        <span class="type">uint64_t</span> idletime = estimateObjectIdleTime(val);</span><br><span class="line">        idletime /= <span class="number">1000</span>; <span class="comment">/* Using seconds is enough and requires less space.*/</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_IDLE) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,idletime) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LFU方式保存</span></span><br><span class="line">    <span class="comment">/* Save the LFU info. */</span></span><br><span class="line">    <span class="keyword">if</span> (savelfu) &#123;</span><br><span class="line">        <span class="type">uint8_t</span> buf[<span class="number">1</span>];</span><br><span class="line">        buf[<span class="number">0</span>] = LFUDecrAndReturn(val);</span><br><span class="line">        <span class="comment">/* We can encode this in exactly two bytes: the opcode and an 8</span></span><br><span class="line"><span class="comment">         * bit counter, since the frequency is logarithmic with a 0-255 range.</span></span><br><span class="line"><span class="comment">         * Note that we do not store the halving time because to reset it</span></span><br><span class="line"><span class="comment">         * a single time when loading does not affect the frequency much. */</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_FREQ) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,buf,<span class="number">1</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存类型、key、value等</span></span><br><span class="line">    <span class="comment">/* Save type, key, value */</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveObjectType(rdb,val) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveStringObject(rdb,key) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveObject(rdb,val,key) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟请求</span></span><br><span class="line">    <span class="comment">/* Delay return if required (for testing) */</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_key_save_delay)</span><br><span class="line">        usleep(server.rdb_key_save_delay);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="使用场景-「2021-03-16」"><a class="header-anchor" href="#使用场景-「2021-03-16」">¶</a>使用场景:「2021-03-16」</h3>
<ul>
<li>执行command</li>
<li>条件命令 conf配置</li>
<li>shutdown时</li>
</ul>
<h4 id="rdbSave-usage-location"><a class="header-anchor" href="#rdbSave-usage-location">¶</a>rdbSave usage location:</h4>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210316_083902.png" alt=""></p>
<blockquote>
<p>关于rdbSaveBackgroud的使用地方:</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210316_085205.png" alt=""></p>
<h3 id="关于rdbsave和redis如何联系的？"><a class="header-anchor" href="#关于rdbsave和redis如何联系的？">¶</a>关于rdbsave和redis如何联系的？</h3>
<blockquote>
<p>写到这里的才慢慢理解这个里面的关系，如果你问我为啥不在前面就列出来关系图呢？</p>
</blockquote>
<blockquote>
<p>那我只能说这是一个学习的正常流程，抓住其中的关键点，先看实现，然后再向外扩散，由内而外.</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/redis-2021-03-16-13-48-23.png" alt=""></p>
<p><strong>如果区分下redis的上下层面的关系，那就可以大致分为三层：command+底层实现+最底层的IO操作等.</strong></p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/redis-2021-03-16-13-58-41.png" alt=""></p>
<p><strong>再细分下中间的过程</strong><br>
<img data-src="https://raw.githubusercontent.com/crab21/Images/master/redis-2021-03-16-14-13-35.png" alt=""></p>
<h3 id="Todo"><a class="header-anchor" href="#Todo">¶</a>Todo</h3>
<ul>
<li><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0">rdb快速备份原因: fork主进程</label></li>
<li><input type="checkbox" id="checkbox1"><label for="checkbox1">故障「断电」等恢复机制</label></li>
<li><input type="checkbox" id="checkbox2"><label for="checkbox2">cluster复制怎么进行的？</label></li>
</ul>
<h3 id="End"><a class="header-anchor" href="#End">¶</a>End</h3>
]]></content>
      <tags>
        <tag>Day</tag>
        <tag>Redis</tag>
        <tag>RDB</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>「29」map delete Mem不释放问题</title>
    <url>/archives/2de36dd7.html</url>
    <content><![CDATA[<h3 id="Go-version"><a class="header-anchor" href="#Go-version">¶</a>Go version:</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">7384</span> ◯  <span class="keyword">go</span> version</span><br><span class="line"><span class="keyword">go</span> version go1<span class="number">.14</span><span class="number">.9</span> darwin/amd64</span><br></pre></td></tr></table></figure>
<h3 id="最近有这么个坑"><a class="header-anchor" href="#最近有这么个坑">¶</a>最近有这么个坑:</h3>
<blockquote>
<p>碰到内存泄露问题，大致是这样的：</p>
</blockquote>
<ul>
<li>1、定义一个全局map</li>
<li>2、给里面放值</li>
<li>3、用完之后删除Key/value</li>
</ul>
<h3 id="问题：map删除完key后，Mem有没有被释放？"><a class="header-anchor" href="#问题：map删除完key后，Mem有没有被释放？">¶</a>问题：map删除完key后，Mem有没有被释放？</h3>
<span id="more"></span>
<h3 id="观察内存变化："><a class="header-anchor" href="#观察内存变化：">¶</a>观察内存变化：</h3>
<h4 id="情景1-只删除Map的k-v"><a class="header-anchor" href="#情景1-只删除Map的k-v">¶</a>情景1: 只删除Map的k/v</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> cnt = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	printMemStats()</span><br><span class="line">	initMap()</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		<span class="built_in">delete</span>(intMap, i)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	<span class="comment">//intMap = nil</span></span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	intMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, cnt)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		intMap[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMemStats</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m runtime.MemStats</span><br><span class="line">	runtime.ReadMemStats(&amp;m)</span><br><span class="line">	log.Printf(<span class="string">&quot;Alloc = %v TotalAlloc = %v Sys = %v NumGC = %v\n&quot;</span>, m.Alloc/<span class="number">1024</span>, m.TotalAlloc/<span class="number">1024</span>, m.Sys/<span class="number">1024</span>, m.NumGC)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="输出："><a class="header-anchor" href="#输出：">¶</a>输出：</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">26</span> Alloc = <span class="number">162</span> TotalAlloc = <span class="number">162</span> Sys = <span class="number">69714</span> NumGC = <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">26</span> Alloc = <span class="number">471</span> TotalAlloc = <span class="number">487</span> Sys = <span class="number">70290</span> NumGC = <span class="number">1</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">26</span> <span class="number">8192</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">26</span> <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">26</span> Alloc = <span class="number">473</span> TotalAlloc = <span class="number">490</span> Sys = <span class="number">70610</span> NumGC = <span class="number">2</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">26</span> Alloc = <span class="number">475</span> TotalAlloc = <span class="number">494</span> Sys = <span class="number">70610</span> NumGC = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="情景2-删除map的k-v-并置map为nil"><a class="header-anchor" href="#情景2-删除map的k-v-并置map为nil">¶</a>情景2: 删除map的k/v,并置map为nil</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> cnt = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	printMemStats()</span><br><span class="line">	initMap()</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		<span class="built_in">delete</span>(intMap, i)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	intMap = <span class="literal">nil</span></span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	intMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, cnt)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		intMap[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMemStats</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m runtime.MemStats</span><br><span class="line">	runtime.ReadMemStats(&amp;m)</span><br><span class="line">	log.Printf(<span class="string">&quot;Alloc = %v TotalAlloc = %v Sys = %v NumGC = %v\n&quot;</span>, m.Alloc/<span class="number">1024</span>, m.TotalAlloc/<span class="number">1024</span>, m.Sys/<span class="number">1024</span>, m.NumGC)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="输出：-v2"><a class="header-anchor" href="#输出：-v2">¶</a>输出：</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">40</span> Alloc = <span class="number">161</span> TotalAlloc = <span class="number">161</span> Sys = <span class="number">69714</span> NumGC = <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">40</span> Alloc = <span class="number">469</span> TotalAlloc = <span class="number">484</span> Sys = <span class="number">71696</span> NumGC = <span class="number">1</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">40</span> <span class="number">8192</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">40</span> <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">40</span> Alloc = <span class="number">471</span> TotalAlloc = <span class="number">488</span> Sys = <span class="number">71760</span> NumGC = <span class="number">2</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">40</span> Alloc = <span class="number">160</span> TotalAlloc = <span class="number">492</span> Sys = <span class="number">71760</span> NumGC = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="情景3-map放在函数中，并删除map的k-v-不置nil"><a class="header-anchor" href="#情景3-map放在函数中，并删除map的k-v-不置nil">¶</a>情景3: map放在函数中，并删除map的k/v,不置nil</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> intMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> cnt = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	printMemStats()</span><br><span class="line">	other()</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">other</span><span class="params">()</span></span>&#123;</span><br><span class="line">	initMap()</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		<span class="built_in">delete</span>(intMap, i)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	<span class="comment">//intMap = nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	intMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, cnt)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		intMap[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMemStats</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m runtime.MemStats</span><br><span class="line">	runtime.ReadMemStats(&amp;m)</span><br><span class="line">	log.Printf(<span class="string">&quot;Alloc = %v TotalAlloc = %v Sys = %v NumGC = %v\n&quot;</span>, m.Alloc/<span class="number">1024</span>, m.TotalAlloc/<span class="number">1024</span>, m.Sys/<span class="number">1024</span>, m.NumGC)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="输出：-v3"><a class="header-anchor" href="#输出：-v3">¶</a>输出：</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">35</span> Alloc = <span class="number">161</span> TotalAlloc = <span class="number">161</span> Sys = <span class="number">69458</span> NumGC = <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">35</span> Alloc = <span class="number">469</span> TotalAlloc = <span class="number">484</span> Sys = <span class="number">71440</span> NumGC = <span class="number">1</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">35</span> <span class="number">8192</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">35</span> <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">35</span> Alloc = <span class="number">471</span> TotalAlloc = <span class="number">488</span> Sys = <span class="number">71504</span> NumGC = <span class="number">2</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">35</span> Alloc = <span class="number">473</span> TotalAlloc = <span class="number">492</span> Sys = <span class="number">71504</span> NumGC = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="情景4-map放在函数中，并删除map的k-v-map置为nil"><a class="header-anchor" href="#情景4-map放在函数中，并删除map的k-v-map置为nil">¶</a>情景4: map放在函数中，并删除map的k/v,map置为nil</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> intMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> cnt = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	printMemStats()</span><br><span class="line">	other()</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">other</span><span class="params">()</span></span>&#123;</span><br><span class="line">	initMap()</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		<span class="built_in">delete</span>(intMap, i)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	intMap = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	intMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, cnt)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		intMap[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMemStats</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m runtime.MemStats</span><br><span class="line">	runtime.ReadMemStats(&amp;m)</span><br><span class="line">	log.Printf(<span class="string">&quot;Alloc = %v TotalAlloc = %v Sys = %v NumGC = %v\n&quot;</span>, m.Alloc/<span class="number">1024</span>, m.TotalAlloc/<span class="number">1024</span>, m.Sys/<span class="number">1024</span>, m.NumGC)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="输出：-v4"><a class="header-anchor" href="#输出：-v4">¶</a>输出：</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">02</span> Alloc = <span class="number">161</span> TotalAlloc = <span class="number">161</span> Sys = <span class="number">69714</span> NumGC = <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">02</span> Alloc = <span class="number">469</span> TotalAlloc = <span class="number">484</span> Sys = <span class="number">70034</span> NumGC = <span class="number">1</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">02</span> <span class="number">8192</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">02</span> <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">02</span> Alloc = <span class="number">471</span> TotalAlloc = <span class="number">488</span> Sys = <span class="number">70098</span> NumGC = <span class="number">2</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">02</span> Alloc = <span class="number">160</span> TotalAlloc = <span class="number">492</span> Sys = <span class="number">70098</span> NumGC = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="情景5-map定义放在局部变量中："><a class="header-anchor" href="#情景5-map定义放在局部变量中：">¶</a>情景5: map定义放在局部变量中：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cnt = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	printMemStats()</span><br><span class="line">	other()</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">other</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> intMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">	intMap = initMap(intMap)</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		<span class="built_in">delete</span>(intMap, i)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	<span class="comment">//intMap = nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMap</span><span class="params">(intMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span></span> <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span> &#123;</span><br><span class="line">	intMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, cnt)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		intMap[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> intMap</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMemStats</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m runtime.MemStats</span><br><span class="line">	runtime.ReadMemStats(&amp;m)</span><br><span class="line">	log.Printf(<span class="string">&quot;Alloc = %v TotalAlloc = %v Sys = %v NumGC = %v\n&quot;</span>, m.Alloc/<span class="number">1024</span>, m.TotalAlloc/<span class="number">1024</span>, m.Sys/<span class="number">1024</span>, m.NumGC)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="输出：-v5"><a class="header-anchor" href="#输出：-v5">¶</a>输出：</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">29</span>:<span class="number">54</span> Alloc = <span class="number">161</span> TotalAlloc = <span class="number">161</span> Sys = <span class="number">69458</span> NumGC = <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">29</span>:<span class="number">54</span> Alloc = <span class="number">469</span> TotalAlloc = <span class="number">484</span> Sys = <span class="number">71440</span> NumGC = <span class="number">1</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">29</span>:<span class="number">54</span> <span class="number">8192</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">29</span>:<span class="number">54</span> <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">29</span>:<span class="number">54</span> Alloc = <span class="number">158</span> TotalAlloc = <span class="number">488</span> Sys = <span class="number">71504</span> NumGC = <span class="number">2</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">29</span>:<span class="number">54</span> Alloc = <span class="number">160</span> TotalAlloc = <span class="number">491</span> Sys = <span class="number">71504</span> NumGC = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h5 id="汇编输出："><a class="header-anchor" href="#汇编输出：">¶</a>汇编输出：</h5>
<p>比较有意思的一行：</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210106_051000.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XORL 异或运算符 </span><br><span class="line"></span><br><span class="line">XORL AX,AX ---&gt;将AX置0值</span><br></pre></td></tr></table></figure>
<h4 id="delete函数："><a class="header-anchor" href="#delete函数：">¶</a>delete函数：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0125</span> <span class="number">00293</span> (../<span class="number">1126</span>/main.<span class="keyword">go</span>:<span class="number">26</span>)	CALL	runtime.mapdelete_fast64(SB)</span><br></pre></td></tr></table></figure>
<h5 id="mapdelete-fast64函数作用："><a class="header-anchor" href="#mapdelete-fast64函数作用：">¶</a>mapdelete_fast64函数作用：</h5>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/map_fast64.go#L272">点击Github查看</a></p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210106_052140.png" alt=""></p>
<blockquote>
<p>有意思的是：map的设计就是这样，删除key，只是把这个槽位置empty，并没有释放内存.</p>
</blockquote>
<h3 id="Others"><a class="header-anchor" href="#Others">¶</a>Others:</h3>
<h4 id="其它场景："><a class="header-anchor" href="#其它场景：">¶</a>其它场景：</h4>
<blockquote>
<p>场景有很多，这里只是逻列最简单的，至于用指针之类的，有兴趣了再研究研究，方法都是一样的。</p>
</blockquote>
<h4 id="汇编代码生成"><a class="header-anchor" href="#汇编代码生成">¶</a>汇编代码生成</h4>
<ul>
<li>详细见此文：<a href="https://blog.imrcrab.com/archives/2ce846ed.html">「15」Plan9 汇编小记</a></li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>Map</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>「28」sync-mutex传参复制问题</title>
    <url>/archives/a82ae489.html</url>
    <content><![CDATA[<h3 id="Go-version"><a class="header-anchor" href="#Go-version">¶</a>Go version:</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">7384</span> ◯  <span class="keyword">go</span> version</span><br><span class="line"><span class="keyword">go</span> version go1<span class="number">.14</span><span class="number">.9</span> darwin/amd64</span><br></pre></td></tr></table></figure>
<h3 id="起因"><a class="header-anchor" href="#起因">¶</a>起因:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sync.Mutex当参数,值传递后出错.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="现象"><a class="header-anchor" href="#现象">¶</a>现象:</h3>
<blockquote>
<p>不废话,上代码:</p>
</blockquote>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> AddAge() &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	p.mux.Lock()</span><br><span class="line">	age++</span><br><span class="line">	<span class="keyword">defer</span> p.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := Person&#123;</span><br><span class="line">		mux: sync.Mutex&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Add(<span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> p1.AddAge()</span><br><span class="line">	&#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    </span><br><span class="line">	fmt.Println(age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="这个age的输出应该是多少"><a class="header-anchor" href="#这个age的输出应该是多少">¶</a>这个age的输出应该是多少?</h4>
<h4 id="不妨可以多尝试几次-结果"><a class="header-anchor" href="#不妨可以多尝试几次-结果">¶</a>不妨可以多尝试几次,结果:</h4>
<blockquote>
<p>100/99/98都有可能.</p>
</blockquote>
<h3 id="What-Lock难道不是加锁的么"><a class="header-anchor" href="#What-Lock难道不是加锁的么">¶</a>What? Lock难道不是加锁的么</h3>
<blockquote>
<p>Lock加锁难道不是这么用的么,颠覆认知!</p>
</blockquote>
<h4 id="Lock源码"><a class="header-anchor" href="#Lock源码">¶</a>Lock源码:</h4>
<p><em>A Mutex must not be copied after first use</em></p>
<h3 id="根源"><a class="header-anchor" href="#根源">¶</a>根源:</h3>
<ul>
<li>Go参数传递属于值传递</li>
<li>Mutex复制后中的state属于前一状态,没有改变</li>
<li>Mutex中的Lock和Unlock「方法」属于指针类型<sup>图1</sup></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210102_102753.png" alt=""><br>
<strong><center>图<sup>1</sup></center></strong></p>
<h3 id="解决办法"><a class="header-anchor" href="#解决办法">¶</a>解决办法</h3>
<ul>
<li>当然是参考源码,「图1」</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">缺点:</span><br><span class="line">    每次使用之前需要初始化,毕竟是指针类型的</span><br><span class="line"></span><br><span class="line">优点:</span><br><span class="line">    设计源于源码,追随Go的设计.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>加锁的地方尽量是全局的</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">这个就不分析了,毕竟不适用所有场景.</span><br><span class="line"></span><br><span class="line">不适用的场景:</span><br><span class="line">    临时的Map需要加锁,如果用全局锁,则效率降低.</span><br></pre></td></tr></table></figure>
<h3 id="Sync包不可复制性"><a class="header-anchor" href="#Sync包不可复制性">¶</a>Sync包不可复制性</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">使用sync包下的功能,可能得注意了,都是不可复制的.</span><br></pre></td></tr></table></figure>
<h3 id="End"><a class="header-anchor" href="#End">¶</a>End</h3>
<blockquote>
<p>每次看源码,都会有不一样的收获.「也许是我理解能力差哈」</p>
</blockquote>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>sync</tag>
        <tag>Mutex</tag>
      </tags>
  </entry>
  <entry>
    <title>「27」Time Zone时区详解</title>
    <url>/archives/513dbeba.html</url>
    <content><![CDATA[<p>时区，无关语言，在任何一个系统中都会用到：</p>
<ul>
<li>time「时间」</li>
<li>timeID「时间作为唯一标识」</li>
<li>time to unix</li>
<li>unix to time string</li>
<li>…</li>
</ul>
<blockquote>
<p>很多场景都会看到这个时间的重要性，这次看到16的特性中有一个修改项，觉得自己对time和zone了解的太少了，以此记录，以便积累。</p>
</blockquote>
<span id="more"></span>
<h3 id="Go-version"><a class="header-anchor" href="#Go-version">¶</a>Go version:</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">7384</span> ◯  <span class="keyword">go</span> version</span><br><span class="line"><span class="keyword">go</span> version go1<span class="number">.14</span><span class="number">.9</span> darwin/amd64</span><br></pre></td></tr></table></figure>
<h3 id="时区-UTC-GMT-MDT-CST"><a class="header-anchor" href="#时区-UTC-GMT-MDT-CST">¶</a>时区 UTC\GMT\MDT\CST</h3>
<blockquote>
<p>说到时间，肯定得想到时区问题，咱们国家还好，只有一个Beijing时区，美国本土。。。。四个时区「晕了」</p>
</blockquote>
<p>Ps: <a href="https://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9C%8B%E6%99%82%E5%8D%80">点击查看四个时区</a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">GMT (Greenwich Mean Time)的缩写，指的是皇家格林威治天文台的标准时间，称作格林威治时间，因为本初子午线通过此地区，因此也称为世界标准时间。然而地球的自转不是完全规律的，而且正逐渐减慢，因此自1924年开始，格林威治时间(GMT)已经不再被视为标准时间，取而代之的是&quot;世界协调时间&quot; (UTC: Coordinated Universal Time)</span><br><span class="line"></span><br><span class="line">UTC 协调世界时（Coordinated Universal Time）是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间。UTC 是一个标准，而不是一个时区</span><br><span class="line"></span><br><span class="line">CST</span><br><span class="line"> 北京时间，China Standard Time，中国标准时间，是中国的标准时间。在时区划分上，属东八区，比协调世界时早8小时，记为UTC+8</span><br></pre></td></tr></table></figure>
<h3 id="Go中的时区问题"><a class="header-anchor" href="#Go中的时区问题">¶</a>Go中的时区问题</h3>
<p>有一个函数可以说明这个时区问题：</p>
<ul>
<li>time.LoadLocation</li>
</ul>
<blockquote>
<p>如果你查查源码，就会发现这个函数上面写着时区的问题，也跟不用百度时区，有的自然支持，没有的写了就是乱写了。</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20201228_112003.png" alt=""></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">查询的时区一直就在你goroot路径下的一个压缩文件中。</span><br></pre></td></tr></table></figure>
<p>具体的有兴趣可以去看看所有的时区，后续也就有一个全面的了解了：</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20201228_112408.png" alt=""></p>
<h3 id="Go-中对于时间的使用"><a class="header-anchor" href="#Go-中对于时间的使用">¶</a>Go 中对于时间的使用</h3>
<blockquote>
<p>待更新…</p>
</blockquote>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title>「26」Go 1.16 特性</title>
    <url>/archives/4f05d45d.html</url>
    <content><![CDATA[<p><a href="https://golang.org/doc/go1.16">Go 1.16特性：</a></p>
<span id="more"></span>
<h2 id="json自定义「issues-5901」"><a class="header-anchor" href="#json自定义「issues-5901」">¶</a>json自定义<a href="https://github.com/golang/go/issues/5901">「issues 5901」</a></h2>
<h3 id="「Feat」"><a class="header-anchor" href="#「Feat」">¶</a>「Feat」</h3>
<h3 id="起源："><a class="header-anchor" href="#起源：">¶</a>起源：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For example, if a user wants to marshal net.IP with custom code, we should provide a way</span><br><span class="line">to do that, probably a method on *Encoder. Similarly for *Decoder.</span><br><span class="line"></span><br><span class="line">Same for encoding/xml</span><br></pre></td></tr></table></figure>
<h3 id="变更："><a class="header-anchor" href="#变更：">¶</a>变更：</h3>
<p><a href="https://go-review.googlesource.com/c/go/+/31091">coding:</a></p>
<h3 id="使用教程："><a class="header-anchor" href="#使用教程：">¶</a><a href="https://github.com/golang/go/issues/5901#issuecomment-566269861">使用教程：</a></h3>
<h2 id="GMT和MDT时区问题「issues-43354」"><a class="header-anchor" href="#GMT和MDT时区问题「issues-43354」">¶</a>GMT和MDT时区问题<a href="https://github.com/golang/go/issues/43354">「issues 43354」</a></h2>
<h3 id="「Fix」"><a class="header-anchor" href="#「Fix」">¶</a>「Fix」</h3>
<h3 id="问题："><a class="header-anchor" href="#问题：">¶</a>问题：</h3>
<blockquote>
<p>主要修复一个时区问题 MDT or GMT ？</p>
</blockquote>
<p><a href="https://github.com/golang/go/issues/43354#issuecomment-750490418">官方reply</a><br>
<a href="https://go-review.googlesource.com/c/go/+/280072/">go-review</a></p>
<h2 id="go-get-d「issues-43131」"><a class="header-anchor" href="#go-get-d「issues-43131」">¶</a>go get -d<a href="https://github.com/golang/go/issues/43131">「issues 43131」</a></h2>
<h3 id="「Feat」-v2"><a class="header-anchor" href="#「Feat」-v2">¶</a>「Feat」</h3>
<h3 id="变更：-v2"><a class="header-anchor" href="#变更：-v2">¶</a>变更：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cmd/<span class="keyword">go</span>新增：「仅下载，不使用此依赖」</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> get -d</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="go-mod-download无法指定版本「issues-42524」"><a class="header-anchor" href="#go-mod-download无法指定版本「issues-42524」">¶</a>go mod download无法指定版本<a href="https://github.com/golang/go/issues/42524">「issues 42524」</a></h2>
<h3 id="「Fix」-v2"><a class="header-anchor" href="#「Fix」-v2">¶</a>「Fix」</h3>
<h3 id="变更：-v3"><a class="header-anchor" href="#变更：-v3">¶</a>变更：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">modify 指定版本可以download</span><br></pre></td></tr></table></figure>
<h3 id="review"><a class="header-anchor" href="#review">¶</a><a href="https://go-review.googlesource.com/c/go/+/270520/">review</a></h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20201228_011910.png" alt=""></p>
<h2 id="ParseDir-指定-go作为后缀的bug「issues-42951」"><a class="header-anchor" href="#ParseDir-指定-go作为后缀的bug「issues-42951」">¶</a>ParseDir 指定.go作为后缀的bug<a href="https://github.com/golang/go/issues/42951">「issues 42951」</a></h2>
<h3 id="「Fix」-v3"><a class="header-anchor" href="#「Fix」-v3">¶</a>「Fix」</h3>
<h3 id="变更：-v4"><a class="header-anchor" href="#变更：-v4">¶</a>变更：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">以.<span class="keyword">go</span>结尾的文件夹，ParseDir无法转换</span><br></pre></td></tr></table></figure>
<h3 id="review-v2"><a class="header-anchor" href="#review-v2">¶</a><a href="https://github.com/golang/go/commit/48838c35dc7c8e938a83db66faabf3a51f4adc3d">review</a></h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20201228_013355.png" alt=""></p>
<h2 id="strconv-ParseComplex未处理32位数字「issues-40706」"><a class="header-anchor" href="#strconv-ParseComplex未处理32位数字「issues-40706」">¶</a>strconv:ParseComplex未处理32位数字<a href="https://github.com/golang/go/issues/40706">「issues 40706」</a></h2>
<h3 id="「Fix」-v4"><a class="header-anchor" href="#「Fix」-v4">¶</a>「Fix」</h3>
<h3 id="变更：-v5"><a class="header-anchor" href="#变更：-v5">¶</a>变更：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">处理<span class="number">32</span>bitsize，需要返回<span class="type">error</span>。</span><br></pre></td></tr></table></figure>
<h3 id="review-v3"><a class="header-anchor" href="#review-v3">¶</a><a href="https://go-review.googlesource.com/c/go/+/248219/">review</a></h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20201228_051536.png" alt=""></p>
<h2 id="runtime-getMcache-「issues-42339」"><a class="header-anchor" href="#runtime-getMcache-「issues-42339」">¶</a>runtime {getMcache} <a href="https://github.com/golang/go/issues/42339">「issues 42339」</a></h2>
<h3 id="「Fix」-v5"><a class="header-anchor" href="#「Fix」-v5">¶</a>「Fix」</h3>
<h3 id="变更"><a class="header-anchor" href="#变更">¶</a>变更</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">runtime: <span class="built_in">make</span> getMCache inlineable</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="review-v4"><a class="header-anchor" href="#review-v4">¶</a>review</h3>
<ul>
<li>
<p><a href="https://go-review.googlesource.com/c/go/+/267158/">runtime: decouple consistent stats from mcache and allow P-less update</a></p>
</li>
<li>
<p><a href="https://go-review.googlesource.com/c/go/+/267157/">runtime: make getMCache inlineable</a></p>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20201228_081048.png" alt=""></p>
<h2 id="Slice-Grow-Size-Change"><a class="header-anchor" href="#Slice-Grow-Size-Change">¶</a>Slice Grow Size Change</h2>
<h3 id="「Change」"><a class="header-anchor" href="#「Change」">¶</a>「Change」</h3>
<h3 id="变更-v2"><a class="header-anchor" href="#变更-v2">¶</a>变更</h3>
<p><a href="https://github.com/golang/go/commit/2333c6299f340a5f76a73a4fec6db23ffa388e97">👋👋commit</a></p>
<p><a href="https://go-review.googlesource.com/c/go/+/257338">👋➡️review</a></p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20210424_012848.png" alt=""></p>
<h2 id="End"><a class="header-anchor" href="#End">¶</a>End</h2>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go_1.16</tag>
        <tag>encoding/json</tag>
      </tags>
  </entry>
  <entry>
    <title>「25」GPM sysmon函数</title>
    <url>/archives/c770fe49.html</url>
    <content><![CDATA[<p>前面主要是了解newm的全过程和其中难过一些细节逻辑，，，<br>
如果没了解的，建议先去看下大概的过程，虽然不是非常详细，<br>
最起码得知道newm过程，主要完成了什么操作，有利于后续理解。</p>
<p>这次主要是来学学这个sysmon，系统监控调度的逻辑。</p>
<span id="more"></span>
<h3 id="Go-version"><a class="header-anchor" href="#Go-version">¶</a>Go version</h3>
<blockquote>
<p>go 1.14</p>
</blockquote>
<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p>在深入之前呢，先对下面这些变量有个概念，后续提到也就不陌生了。「摘抄自sysmon函数」</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	allglen    <span class="type">uintptr</span> <span class="comment">//g</span></span><br><span class="line">	allm       *m      <span class="comment">//m</span></span><br><span class="line">	allp       []*p  <span class="comment">// p     len(allp) == gomaxprocs; may change at safe points, otherwise immutable</span></span><br><span class="line">	allpLock   mutex <span class="comment">// 全局lock。   Protects P-less reads of allp and all writes</span></span><br><span class="line">	gomaxprocs <span class="type">int32</span> <span class="comment">//最大process数量</span></span><br><span class="line">	ncpu       <span class="type">int32</span> <span class="comment">//cpu个数</span></span><br><span class="line">	forcegc    forcegcstate <span class="comment">//强制GC</span></span><br><span class="line">	sched      schedt <span class="comment">//预分配的一些变量值</span></span><br><span class="line">	newprocs   <span class="type">int32</span>  <span class="comment">//新的process</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Information about what cpu features are available.</span></span><br><span class="line">	<span class="comment">// Packages outside the runtime should not use these</span></span><br><span class="line">	<span class="comment">// as they are not an external api.</span></span><br><span class="line">	<span class="comment">// Set on startup in asm_&#123;386,amd64&#125;.s</span></span><br><span class="line">	processorVersionInfo <span class="type">uint32</span></span><br><span class="line">	isIntel              <span class="type">bool</span></span><br><span class="line">	lfenceBeforeRdtsc    <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	goarm                <span class="type">uint8</span> <span class="comment">// set by cmd/link on arm systems</span></span><br><span class="line">	framepointer_enabled <span class="type">bool</span>  <span class="comment">// set by cmd/link</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="sysmon函数"><a class="header-anchor" href="#sysmon函数">¶</a>sysmon函数</h3>
<h4 id="概览"><a class="header-anchor" href="#概览">¶</a>概览</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lock(&amp;sched.lock)<span class="comment">//加锁</span></span><br><span class="line">	sched.nmsys++ <span class="comment">//数量+1</span></span><br><span class="line">	checkdead() <span class="comment">//检查是否dead</span></span><br><span class="line">	unlock(&amp;sched.lock) <span class="comment">//释放lock</span></span><br><span class="line"></span><br><span class="line">	lasttrace := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">	idle := <span class="number">0</span> <span class="comment">// how many cycles in succession we had not wokeup somebody</span></span><br><span class="line">	delay := <span class="type">uint32</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/GPM-sysmon-1.png" alt=""></p>
<h3 id="循环干什么？"><a class="header-anchor" href="#循环干什么？">¶</a>循环干什么？</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/clipboard_20201206_085755.png" alt=""></p>
<blockquote>
<p>一个个过吧</p>
</blockquote>
<h4 id="获取系统的纳秒时间"><a class="header-anchor" href="#获取系统的纳秒时间">¶</a>获取系统的纳秒时间</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := nanotime()</span><br></pre></td></tr></table></figure>
<h4 id="timeSleepUntil"><a class="header-anchor" href="#timeSleepUntil">¶</a>timeSleepUntil</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// timeSleepUntil returns the time when the next timer should fire,</span></span><br><span class="line"><span class="comment">// and the P that holds the timer heap that that timer is on.</span></span><br><span class="line"><span class="comment">// This is only called by sysmon and checkdead.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeSleepUntil</span><span class="params">()</span></span> (<span class="type">int64</span>, *p) &#123;</span><br><span class="line">	next := <span class="type">int64</span>(maxWhen)</span><br><span class="line">	<span class="keyword">var</span> pret *p</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prevent allp slice changes. This is like retake.</span></span><br><span class="line">	lock(&amp;allpLock)</span><br><span class="line">	<span class="keyword">for</span> _, pp := <span class="keyword">range</span> allp &#123;</span><br><span class="line">		<span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// This can happen if procresize has grown</span></span><br><span class="line">			<span class="comment">// allp but not yet created new Ps.</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		c := atomic.Load(&amp;pp.adjustTimers)</span><br><span class="line">		<span class="keyword">if</span> c == <span class="number">0</span> &#123;</span><br><span class="line">			w := <span class="type">int64</span>(atomic.Load64(&amp;pp.timer0When))</span><br><span class="line">			<span class="comment">//划重点</span></span><br><span class="line">			<span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; w &lt; next &#123;</span><br><span class="line">				next = w</span><br><span class="line">				pret = pp</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		lock(&amp;pp.timersLock)</span><br><span class="line">		<span class="keyword">for</span> _, t := <span class="keyword">range</span> pp.timers &#123;</span><br><span class="line">			<span class="comment">//划重点</span></span><br><span class="line">			<span class="keyword">switch</span> s := atomic.Load(&amp;t.status); s &#123;</span><br><span class="line">			<span class="keyword">case</span> timerWaiting:</span><br><span class="line">				<span class="keyword">if</span> t.when &lt; next &#123;</span><br><span class="line">					next = t.when</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">case</span> timerModifiedEarlier, timerModifiedLater:</span><br><span class="line">				<span class="keyword">if</span> t.nextwhen &lt; next &#123;</span><br><span class="line">					next = t.nextwhen</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> s == timerModifiedEarlier &#123;</span><br><span class="line">					c--</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// The timers are sorted, so we only have to check</span></span><br><span class="line">			<span class="comment">// the first timer for each P, unless there are</span></span><br><span class="line">			<span class="comment">// some timerModifiedEarlier timers. The number</span></span><br><span class="line">			<span class="comment">// of timerModifiedEarlier timers is in the adjustTimers</span></span><br><span class="line">			<span class="comment">// field, used to initialize c, above.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// We don&#x27;t worry about cases like timerModifying.</span></span><br><span class="line">			<span class="comment">// New timers can show up at any time,</span></span><br><span class="line">			<span class="comment">// so this function is necessarily imprecise.</span></span><br><span class="line">			<span class="comment">// Do a signed check here since we aren&#x27;t</span></span><br><span class="line">			<span class="comment">// synchronizing the read of pp.adjustTimers</span></span><br><span class="line">			<span class="comment">// with the check of a timer status.</span></span><br><span class="line">			<span class="keyword">if</span> <span class="type">int32</span>(c) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;pp.timersLock)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;allpLock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> next, pret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sched和gomaxprocs判断「sleep-wakeup过程」"><a class="header-anchor" href="#sched和gomaxprocs判断「sleep-wakeup过程」">¶</a>sched和gomaxprocs判断「sleep&amp;wakeup过程」</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双层判断，防止在加锁这段时间值发生变化</span></span><br><span class="line"><span class="keyword">if</span> debug.schedtrace &lt;= <span class="number">0</span> &amp;&amp; (sched.gcwaiting != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="type">uint32</span>(gomaxprocs)) &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">if</span> atomic.Load(&amp;sched.gcwaiting) != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="type">uint32</span>(gomaxprocs) &#123;</span><br><span class="line">				<span class="keyword">if</span> next &gt; now &#123;</span><br><span class="line">					atomic.Store(&amp;sched.sysmonwait, <span class="number">1</span>)</span><br><span class="line">					unlock(&amp;sched.lock)</span><br><span class="line">					<span class="comment">// Make wake-up period small enough</span></span><br><span class="line">					<span class="comment">// for the sampling to be correct.</span></span><br><span class="line">					sleep := forcegcperiod / <span class="number">2</span></span><br><span class="line">					<span class="keyword">if</span> next-now &lt; sleep &#123;</span><br><span class="line">						sleep = next - now</span><br><span class="line">					&#125;</span><br><span class="line">					shouldRelax := sleep &gt;= osRelaxMinNS</span><br><span class="line">					<span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">						osRelax(<span class="literal">true</span>)</span><br><span class="line">					&#125;</span><br><span class="line">					notetsleep(&amp;sched.sysmonnote, sleep)</span><br><span class="line">					<span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">						osRelax(<span class="literal">false</span>)</span><br><span class="line">					&#125;</span><br><span class="line">					now = nanotime()</span><br><span class="line">					next, _ = timeSleepUntil()</span><br><span class="line">					lock(&amp;sched.lock)</span><br><span class="line">					atomic.Store(&amp;sched.sysmonwait, <span class="number">0</span>)</span><br><span class="line">					noteclear(&amp;sched.sysmonnote)</span><br><span class="line">				&#125;</span><br><span class="line">				idle = <span class="number">0</span></span><br><span class="line">				delay = <span class="number">20</span></span><br><span class="line">			&#125;</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h4 id="poll-network"><a class="header-anchor" href="#poll-network">¶</a>poll network</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// poll network if not polled for more than 10ms</span></span><br><span class="line">lastpoll := <span class="type">int64</span>(atomic.Load64(&amp;sched.lastpoll))</span><br><span class="line"><span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">	atomic.Cas64(&amp;sched.lastpoll, <span class="type">uint64</span>(lastpoll), <span class="type">uint64</span>(now))</span><br><span class="line">	list := netpoll(<span class="number">0</span>) <span class="comment">// non-blocking - returns list of goroutines</span></span><br><span class="line">	<span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">		<span class="comment">// Need to decrement number of idle locked M&#x27;s</span></span><br><span class="line">		<span class="comment">// (pretending that one more is running) before injectglist.</span></span><br><span class="line">		<span class="comment">// Otherwise it can lead to the following situation:</span></span><br><span class="line">		<span class="comment">// injectglist grabs all P&#x27;s but before it starts M&#x27;s to run the P&#x27;s,</span></span><br><span class="line">		<span class="comment">// another M returns from syscall, finishes running its G,</span></span><br><span class="line">		<span class="comment">// observes that there is no work to do and no other running M&#x27;s</span></span><br><span class="line">		<span class="comment">// and reports deadlock.</span></span><br><span class="line">		incidlelocked(<span class="number">-1</span>)</span><br><span class="line">		injectglist(&amp;list)</span><br><span class="line">		incidlelocked(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> next &lt; now &#123;</span><br><span class="line">	<span class="comment">// There are timers that should have already run,</span></span><br><span class="line">	<span class="comment">// perhaps because there is an unpreemptible P.</span></span><br><span class="line">	<span class="comment">// Try to start an M to run them.</span></span><br><span class="line">	<span class="comment">//划重点</span></span><br><span class="line">	startm(<span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="wakeScavenger"><a class="header-anchor" href="#wakeScavenger">¶</a>wakeScavenger</h4>
<blockquote>
<p>判断需要唤醒请求</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.Load(&amp;scavenge.sysmonWake) != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="comment">// Kick the scavenger awake if someone requested it.</span></span><br><span class="line">	wakeScavenger()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wakeScavenger immediately unparks the scavenger if necessary.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// May run without a P, but it may allocate, so it must not be called</span></span><br><span class="line"><span class="comment">// on any allocation path.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// mheap_.lock, scavenge.lock, and sched.lock must not be held.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wakeScavenger</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lock(&amp;scavenge.lock)</span><br><span class="line">	<span class="keyword">if</span> scavenge.parked &#123;</span><br><span class="line">		<span class="comment">// Notify sysmon that it shouldn&#x27;t bother waking up the scavenger.</span></span><br><span class="line">		atomic.Store(&amp;scavenge.sysmonWake, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Try to stop the timer but we don&#x27;t really care if we succeed.</span></span><br><span class="line">		<span class="comment">// It&#x27;s possible that either a timer was never started, or that</span></span><br><span class="line">		<span class="comment">// we&#x27;re racing with it.</span></span><br><span class="line">		<span class="comment">// In the case that we&#x27;re racing with there&#x27;s the low chance that</span></span><br><span class="line">		<span class="comment">// we experience a spurious wake-up of the scavenger, but that&#x27;s</span></span><br><span class="line">		<span class="comment">// totally safe.</span></span><br><span class="line">		stopTimer(scavenge.timer)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Unpark the goroutine and tell it that there may have been a pacing</span></span><br><span class="line">		<span class="comment">// change. Note that we skip the scheduler&#x27;s runnext slot because we</span></span><br><span class="line">		<span class="comment">// want to avoid having the scavenger interfere with the fair</span></span><br><span class="line">		<span class="comment">// scheduling of user goroutines. In effect, this schedules the</span></span><br><span class="line">		<span class="comment">// scavenger at a &quot;lower priority&quot; but that&#x27;s OK because it&#x27;ll</span></span><br><span class="line">		<span class="comment">// catch up on the work it missed when it does get scheduled.</span></span><br><span class="line">		scavenge.parked = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Ready the goroutine by injecting it. We use injectglist instead</span></span><br><span class="line">		<span class="comment">// of ready or goready in order to allow us to run this function</span></span><br><span class="line">		<span class="comment">// without a P. injectglist also avoids placing the goroutine in</span></span><br><span class="line">		<span class="comment">// the current P&#x27;s runnext slot, which is desireable to prevent</span></span><br><span class="line">		<span class="comment">// the scavenger from interfering with user goroutine scheduling</span></span><br><span class="line">		<span class="comment">// too much.</span></span><br><span class="line">		<span class="keyword">var</span> list gList</span><br><span class="line">		list.push(scavenge.g)</span><br><span class="line">		injectglist(&amp;list)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;scavenge.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="retake夺取"><a class="header-anchor" href="#retake夺取">¶</a>retake夺取</h4>
<blockquote>
<p>夺取空闲的P</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// retake P&#x27;s blocked in syscalls</span></span><br><span class="line"><span class="comment">// and preempt long running G&#x27;s</span></span><br><span class="line"><span class="keyword">if</span> retake(now) != <span class="number">0</span> &#123;</span><br><span class="line">	idle = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	idle++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GC-判断"><a class="header-anchor" href="#GC-判断">¶</a>GC 判断</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// check if we need to force a GC</span></span><br><span class="line"><span class="comment">//划重点 t.test()</span></span><br><span class="line"><span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != <span class="number">0</span> &#123;</span><br><span class="line">	lock(&amp;forcegc.lock)</span><br><span class="line">	forcegc.idle = <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> list gList</span><br><span class="line">	list.push(forcegc.g)</span><br><span class="line">	injectglist(&amp;list)</span><br><span class="line">	unlock(&amp;forcegc.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结下干了什么？？"><a class="header-anchor" href="#总结下干了什么？？">¶</a>总结下干了什么？？</h3>
<ul>
<li>1、强制垃圾回收。</li>
<li>2、将长时间未处理的netpoll结果添加到任务队列。</li>
<li>3、对长时间运行G，进行retake夺P的调度。</li>
<li>4、回收syscall长时间阻塞的P。</li>
</ul>
<h3 id="关于资料参考更正："><a class="header-anchor" href="#关于资料参考更正：">¶</a>关于资料参考更正：</h3>
<h4 id="参考："><a class="header-anchor" href="#参考：">¶</a>参考：</h4>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/ico/clipboard_20210510_014127.png" alt=""></p>
<p>关于这个第一点的说法是建立在18年Go 1.11的时候，是没有问题，大家按不同的版本，变化的来看待。</p>
<h5 id="Go-1-11"><a class="header-anchor" href="#Go-1-11">¶</a>Go 1.11</h5>
<p>附上关于5分钟回收的链接<a href="https://github.com/golang/go/blob/release-branch.go1.11/src/runtime/proc.go#L4328">👉🏻👉🏻Go 1.11 proc.go</a></p>
<p>调用函数：</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/ico/clipboard_20210510_020832.png" alt=""></p>
<h5 id="Go-1-14"><a class="header-anchor" href="#Go-1-14">¶</a>Go 1.14</h5>
<blockquote>
<p>scavengeAll替代 scavenge函数</p>
</blockquote>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/mheap.go#L1424">👉🏻scavengeALL</a></p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/ico/clipboard_20210510_021037.png" alt=""></p>
<p>调用地方 <a href="https://github.com/golang/go/blob/5cf057ddedfbb149b71c85ec86050431dd6b2d9d/src/runtime/mheap.go#L1445">👉🏻runtime debug freeosMemory</a>：</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/ico/clipboard_20210510_021423.png" alt=""></p>
<h3 id="参考：-v2"><a class="header-anchor" href="#参考：-v2">¶</a>参考：</h3>
<p><a href="https://studygolang.com/articles/12112">Go学习整理笔记</a></p>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>GPM</tag>
        <tag>Go源码</tag>
      </tags>
  </entry>
  <entry>
    <title>「24」GPM newm函数</title>
    <url>/archives/b4edbd7.html</url>
    <content><![CDATA[<p>上节看了go的入口函数，，，也就是你执行main函数前后所做的准备工作。</p>
<p>继续深入学习。「newm」第一个M，到底是怎么来的？</p>
<span id="more"></span>
<blockquote>
<p>go version: 1.14.3</p>
</blockquote>
<h3 id="入口"><a class="header-anchor" href="#入口">¶</a>入口</h3>
<p>先看下主体，主要在M创建的过程中，干了what，，，，，「PS : 关键看值得学习的点」</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a new m. It will start off with a call to fn, or else the scheduler.</span></span><br><span class="line"><span class="comment">// fn needs to be static and not a heap allocated closure.</span></span><br><span class="line"><span class="comment">// May run with m.p==nil, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm</span><span class="params">(fn <span class="keyword">func</span>()</span></span>, _p_ *p) &#123;</span><br><span class="line">  <span class="comment">//分配内存</span></span><br><span class="line">	mp := allocm(_p_, fn)</span><br><span class="line">  <span class="comment">//设置p</span></span><br><span class="line">	mp.nextp.set(_p_)</span><br><span class="line">  <span class="comment">//初始化信号量</span></span><br><span class="line">	mp.sigmask = initSigmask</span><br><span class="line">  <span class="comment">//获取到gp后，判断M&amp;（系统锁定｜｜cgo执行中）；；；plan9的系统跳过下面操作....</span></span><br><span class="line">	<span class="keyword">if</span> gp := getg(); gp != <span class="literal">nil</span> &amp;&amp; gp.m != <span class="literal">nil</span> &amp;&amp; (gp.m.lockedExt != <span class="number">0</span> || gp.m.incgo) &amp;&amp; GOOS != <span class="string">&quot;plan9&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// We&#x27;re on a locked M or a thread that may have been</span></span><br><span class="line">		<span class="comment">// started by C. The kernel state of this thread may</span></span><br><span class="line">		<span class="comment">// be strange (the user may have locked it for that</span></span><br><span class="line">		<span class="comment">// purpose). We don&#x27;t want to clone that into another</span></span><br><span class="line">		<span class="comment">// thread. Instead, ask a known-good thread to create</span></span><br><span class="line">		<span class="comment">// the thread for us.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// This is disabled on Plan 9. See golang.org/issue/22227.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> This may be unnecessary on Windows, which</span></span><br><span class="line">		<span class="comment">// doesn&#x27;t model thread creation off fork.</span></span><br><span class="line">		lock(&amp;newmHandoff.lock)</span><br><span class="line">		<span class="keyword">if</span> newmHandoff.haveTemplateThread == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;on a locked thread with no template thread&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		mp.schedlink = newmHandoff.newm</span><br><span class="line">		newmHandoff.newm.set(mp)</span><br><span class="line">		<span class="keyword">if</span> newmHandoff.waiting &#123;</span><br><span class="line">			newmHandoff.waiting = <span class="literal">false</span></span><br><span class="line">			notewakeup(&amp;newmHandoff.wake)</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;newmHandoff.lock)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//new m1指第一个M的创建过程.</span></span><br><span class="line">	newm1(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="newm1"><a class="header-anchor" href="#newm1">¶</a>newm1</h3>
<blockquote>
<p>go to 「newm1」</p>
</blockquote>
<p>看起来很简短</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm1</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">  <span class="comment">//cgo程序执行中?</span></span><br><span class="line">	<span class="keyword">if</span> iscgo &#123;</span><br><span class="line">		<span class="keyword">var</span> ts cgothreadstart</span><br><span class="line">		<span class="keyword">if</span> _cgo_thread_start == <span class="literal">nil</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;_cgo_thread_start missing&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		ts.g.set(mp.g0)</span><br><span class="line">		ts.tls = (*<span class="type">uint64</span>)(unsafe.Pointer(&amp;mp.tls[<span class="number">0</span>]))</span><br><span class="line">		ts.fn = unsafe.Pointer(funcPC(mstart))</span><br><span class="line">		<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">			msanwrite(unsafe.Pointer(&amp;ts), unsafe.Sizeof(ts))</span><br><span class="line">		&#125;</span><br><span class="line">		execLock.rlock() <span class="comment">// Prevent process clone.</span></span><br><span class="line">		asmcgocall(_cgo_thread_start, unsafe.Pointer(&amp;ts))</span><br><span class="line">		execLock.runlock()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	execLock.rlock() <span class="comment">// Prevent process clone.</span></span><br><span class="line">  <span class="comment">//涉及到系统进程创建</span></span><br><span class="line">	newosproc(mp)</span><br><span class="line">	execLock.runlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="newosproc"><a class="header-anchor" href="#newosproc">¶</a>newosproc</h3>
<blockquote>
<p>M创建之前，系统的操作和相关地址的变化</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// May run with m.p==nil, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newosproc</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line"><span class="comment">//这个stk操作很奇怪，有兴趣的可以研究下....[看起来啥也没干那]</span></span><br><span class="line">	stk := unsafe.Pointer(mp.g0.stack.hi)</span><br><span class="line">	<span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;newosproc stk=&quot;</span>, stk, <span class="string">&quot; m=&quot;</span>, mp, <span class="string">&quot; g=&quot;</span>, mp.g0, <span class="string">&quot; id=&quot;</span>, mp.id, <span class="string">&quot; ostk=&quot;</span>, &amp;mp, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize an attribute object.</span></span><br><span class="line">	<span class="keyword">var</span> attr pthreadattr</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">int32</span></span><br><span class="line">  <span class="comment">//汇编，变量初始化</span></span><br><span class="line">	err = pthread_attr_init(&amp;attr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line">		write(<span class="number">2</span>, unsafe.Pointer(&amp;failthreadcreate[<span class="number">0</span>]), <span class="type">int32</span>(<span class="built_in">len</span>(failthreadcreate)))</span><br><span class="line">		exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find out OS stack size for our own stack guard.</span></span><br><span class="line">	<span class="keyword">var</span> stacksize <span class="type">uintptr</span></span><br><span class="line">	<span class="keyword">if</span> pthread_attr_getstacksize(&amp;attr, &amp;stacksize) != <span class="number">0</span> &#123;</span><br><span class="line">		write(<span class="number">2</span>, unsafe.Pointer(&amp;failthreadcreate[<span class="number">0</span>]), <span class="type">int32</span>(<span class="built_in">len</span>(failthreadcreate)))</span><br><span class="line">		exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//M对应的g0的高位空间栈地址</span></span><br><span class="line">	mp.g0.stack.hi = stacksize <span class="comment">// for mstart</span></span><br><span class="line">	<span class="comment">//mSysStatInc(&amp;memstats.stacks_sys, stacksize) //<span class="doctag">TODO:</span> do this?</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Tell the pthread library we won&#x27;t join with this thread.</span></span><br><span class="line">	<span class="keyword">if</span> pthread_attr_setdetachstate(&amp;attr, _PTHREAD_CREATE_DETACHED) != <span class="number">0</span> &#123;</span><br><span class="line">		write(<span class="number">2</span>, unsafe.Pointer(&amp;failthreadcreate[<span class="number">0</span>]), <span class="type">int32</span>(<span class="built_in">len</span>(failthreadcreate)))</span><br><span class="line">		exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Finally, create the thread. It starts at mstart_stub, which does some low-level</span></span><br><span class="line">	<span class="comment">// setup and then calls mstart.</span></span><br><span class="line">	<span class="keyword">var</span> oset sigset</span><br><span class="line">  <span class="comment">//所有的mask初始化</span></span><br><span class="line">	sigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)</span><br><span class="line">	err = pthread_create(&amp;attr, funcPC(mstart_stub), unsafe.Pointer(mp))</span><br><span class="line">  <span class="comment">// oset地址置nil</span></span><br><span class="line">	sigprocmask(_SIG_SETMASK, &amp;oset, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line">		write(<span class="number">2</span>, unsafe.Pointer(&amp;failthreadcreate[<span class="number">0</span>]), <span class="type">int32</span>(<span class="built_in">len</span>(failthreadcreate)))</span><br><span class="line">		exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pthread-attr-init细节"><a class="header-anchor" href="#pthread-attr-init细节">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/sys_darwin_arm64.s#L402">pthread_attr_init细节</a></h4>
<blockquote>
<p>汇编代码：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TEXT runtime·pthread_attr_init_trampoline(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">	MOVD	<span class="number">0</span>(R0), R0	<span class="comment">// arg 1 attr</span></span><br><span class="line">	BL	libc_pthread_attr_init(SB)</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>
<h4 id="pthread-attr-getstacksize细节"><a class="header-anchor" href="#pthread-attr-getstacksize细节">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/sys_darwin_arm64.s#L407">pthread_attr_getstacksize细节</a></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TEXT runtime·pthread_attr_getstacksize_trampoline(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">	MOVD	<span class="number">8</span>(R0), R1	<span class="comment">// arg 2 size</span></span><br><span class="line">	MOVD	<span class="number">0</span>(R0), R0	<span class="comment">// arg 1 attr</span></span><br><span class="line">	BL	libc_pthread_attr_getstacksize(SB)</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>
<h4 id="sigprocmask-trampoline细节"><a class="header-anchor" href="#sigprocmask-trampoline细节">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/sys_darwin_arm64.s#L266">sigprocmask_trampoline细节</a></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TEXT runtime·sigprocmask_trampoline(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">	MOVD	<span class="number">8</span>(R0), R1	<span class="comment">// arg 2 new</span></span><br><span class="line">	MOVD	<span class="number">16</span>(R0), R2	<span class="comment">// arg 3 old</span></span><br><span class="line">	MOVW	<span class="number">0</span>(R0), R0	<span class="comment">// arg 1 how</span></span><br><span class="line">	BL	libc_pthread_sigmask(SB)</span><br><span class="line">	CMP	$<span class="number">0</span>, R0</span><br><span class="line">	BEQ	<span class="number">2</span>(PC)</span><br><span class="line">	BL	notok&lt;&gt;(SB)</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>
<h4 id="pthread-create细节"><a class="header-anchor" href="#pthread-create细节">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/sys_darwin_arm64.s#L342">pthread_create细节</a></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mstart_stub is the first function executed on a new thread started by pthread_create.</span></span><br><span class="line"><span class="comment">// It just does some low-level setup and then calls mstart.</span></span><br><span class="line"><span class="comment">// Note: called with the C calling convention.</span></span><br><span class="line">TEXT runtime·mstart_stub(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">	<span class="comment">// DI points to the m.</span></span><br><span class="line">	<span class="comment">// We are already on m&#x27;s g0 stack.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save callee-save registers.</span></span><br><span class="line">	SUBQ	$<span class="number">40</span>, SP</span><br><span class="line">	MOVQ	BX, <span class="number">0</span>(SP)</span><br><span class="line">	MOVQ	R12, <span class="number">8</span>(SP)</span><br><span class="line">	MOVQ	R13, <span class="number">16</span>(SP)</span><br><span class="line">	MOVQ	R14, <span class="number">24</span>(SP)</span><br><span class="line">	MOVQ	R15, <span class="number">32</span>(SP)</span><br><span class="line"></span><br><span class="line">	MOVQ	m_g0(DI), DX <span class="comment">// g</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize TLS entry.</span></span><br><span class="line">	<span class="comment">// See cmd/link/internal/ld/sym.go:computeTLSOffset.</span></span><br><span class="line">	MOVQ	DX, <span class="number">0x30</span>(GS)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Someday the convention will be D is always cleared.</span></span><br><span class="line">	CLD</span><br><span class="line"></span><br><span class="line">	CALL	runtime·mstart(SB)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Restore callee-save registers.</span></span><br><span class="line">	MOVQ	<span class="number">0</span>(SP), BX</span><br><span class="line">	MOVQ	<span class="number">8</span>(SP), R12</span><br><span class="line">	MOVQ	<span class="number">16</span>(SP), R13</span><br><span class="line">	MOVQ	<span class="number">24</span>(SP), R14</span><br><span class="line">	MOVQ	<span class="number">32</span>(SP), R15</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Go is all done with this OS thread.</span></span><br><span class="line">	<span class="comment">// Tell pthread everything is ok (we never join with this thread, so</span></span><br><span class="line">	<span class="comment">// the value here doesn&#x27;t really matter).</span></span><br><span class="line">	XORL	AX, AX</span><br><span class="line"></span><br><span class="line">	ADDQ	$<span class="number">40</span>, SP</span><br><span class="line">	RET</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="execLock-rlock"><a class="header-anchor" href="#execLock-rlock">¶</a>execLock.rlock()</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// rlock locks rw for reading.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *rwmutex)</span></span> rlock() &#123;</span><br><span class="line">	<span class="comment">// The reader must not be allowed to lose its P or else other</span></span><br><span class="line">	<span class="comment">// things blocking on the lock may consume all of the Ps and</span></span><br><span class="line">	<span class="comment">// deadlock (issue #20903). Alternatively, we could drop the P</span></span><br><span class="line">	<span class="comment">// while sleeping.</span></span><br><span class="line">	acquirem()</span><br><span class="line">	<span class="keyword">if</span> <span class="type">int32</span>(atomic.Xadd(&amp;rw.readerCount, <span class="number">1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// A writer is pending. Park on the reader queue.</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			lockWithRank(&amp;rw.rLock, lockRankRwmutexR)</span><br><span class="line">			<span class="keyword">if</span> rw.readerPass &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// Writer finished.</span></span><br><span class="line">				rw.readerPass -= <span class="number">1</span></span><br><span class="line">				unlock(&amp;rw.rLock)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Queue this reader to be woken by</span></span><br><span class="line">				<span class="comment">// the writer.</span></span><br><span class="line">				m := getg().m</span><br><span class="line">				m.schedlink = rw.readers</span><br><span class="line">				rw.readers.set(m)</span><br><span class="line">				unlock(&amp;rw.rLock)</span><br><span class="line">				notesleep(&amp;m.park)</span><br><span class="line">				noteclear(&amp;m.park)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="acquirem"><a class="header-anchor" href="#acquirem">¶</a>acquirem()</h4>
<blockquote>
<p>加锁获取M</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquirem</span><span class="params">()</span></span> *m &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line">	_g_.m.locks++</span><br><span class="line">	<span class="keyword">return</span> _g_.m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="notesleep"><a class="header-anchor" href="#notesleep">¶</a>notesleep()</h4>
<blockquote>
<p>比较有趣的是sleep是用队列实现,前后加锁</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notesleep</span><span class="params">(n *note)</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Queued. Sleep.</span></span><br><span class="line">	gp.m.blocked = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">if</span> *cgo_yield == <span class="literal">nil</span> &#123;</span><br><span class="line">		semasleep(<span class="number">-1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Sleep for an arbitrary-but-moderate interval to poll libc interceptors.</span></span><br><span class="line">		<span class="keyword">const</span> ns = <span class="number">10e6</span></span><br><span class="line">		<span class="keyword">for</span> atomic.Loaduintptr(&amp;n.key) == <span class="number">0</span> &#123;</span><br><span class="line">			semasleep(ns)</span><br><span class="line">			asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	gp.m.blocked = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="execLock-runlock"><a class="header-anchor" href="#execLock-runlock">¶</a>execLock.runlock()</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// runlock undoes a single rlock call on rw.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *rwmutex)</span></span> runlock() &#123;</span><br><span class="line">	<span class="keyword">if</span> r := <span class="type">int32</span>(atomic.Xadd(&amp;rw.readerCount, <span class="number">-1</span>)); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">		....</span><br><span class="line">	&#125;</span><br><span class="line">	releasem(getg().m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="releasem"><a class="header-anchor" href="#releasem">¶</a>releasem</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">//lock数量➖1，恢复到preempt的状态.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releasem</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line">	mp.locks--</span><br><span class="line">	<span class="keyword">if</span> mp.locks == <span class="number">0</span> &amp;&amp; _g_.preempt &#123;</span><br><span class="line">		<span class="comment">// restore the preemption request in case we&#x27;ve cleared it in newstack</span></span><br><span class="line">		_g_.stackguard0 = stackPreempt</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先分析到这儿吧…关于这一节的流程图，会整理出来的，，，，</p>
<p>不然就白分析这么多了，及时学习，及时总结。</p>
<p>晚安😴…</p>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>GPM</tag>
        <tag>Go源码</tag>
      </tags>
  </entry>
  <entry>
    <title>「23」GPM main入口函数</title>
    <url>/archives/9bb71eca.html</url>
    <content><![CDATA[<p>前面g0和m0瞎扯了部分的入口和一些关键的点。</p>
<p>本来应该扯扯shedule调度方面的知识，但是这个先往后放一节吧，</p>
<p>先学习下这个「入口函数」，毕竟对于每一个项目都会有一个入口的相关逻辑，那么go源码是怎么处理的？</p>
<p>有没有什么可以借鉴的嘞？！</p>
<span id="more"></span>
<p>接下来该到main函数的相关处理。</p>
<blockquote>
<p>go version: 1.14.3</p>
</blockquote>
<h3 id="code分析"><a class="header-anchor" href="#code分析">¶</a>code分析</h3>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/proc.go#L113">main函数入口</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// The main goroutine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	g := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Racectx of m0-&gt;g0 is used only as the parent of the main goroutine.</span></span><br><span class="line">	<span class="comment">// It must not be used for anything else.</span></span><br><span class="line">	g.m.g0.racectx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.</span></span><br><span class="line">	<span class="comment">// Using decimal instead of binary GB and MB because</span></span><br><span class="line">    <span class="comment">// they look nicer in the stack overflow failure message.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最大栈空间限制</span></span><br><span class="line">	<span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">		maxstacksize = <span class="number">1000000000</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		maxstacksize = <span class="number">250000000</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow newproc to start new Ms.</span></span><br><span class="line">	mainStarted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是wasm，就不要调度程序了.</span></span><br><span class="line">    <span class="keyword">if</span> GOARCH != <span class="string">&quot;wasm&quot;</span> &#123; <span class="comment">// no threads on wasm yet, so no sysmon</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//系统栈调用</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// newm的回调函数，，，一个M一个sysmon P</span></span><br><span class="line">			newm(sysmon, <span class="literal">nil</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lock the main goroutine onto this, the main OS thread,</span></span><br><span class="line">	<span class="comment">// during initialization. Most programs won&#x27;t care, but a few</span></span><br><span class="line">	<span class="comment">// do require certain calls to be made by the main thread.</span></span><br><span class="line">	<span class="comment">// Those can arrange for main.main to run in the main thread</span></span><br><span class="line">	<span class="comment">// by calling runtime.LockOSThread during initialization</span></span><br><span class="line">	<span class="comment">// to preserve the lock.</span></span><br><span class="line">	lockOSThread()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> g.m != &amp;m0 &#123;</span><br><span class="line">		throw(<span class="string">&quot;runtime.main not on m0&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	doInit(&amp;runtime_inittask) <span class="comment">// must be before defer</span></span><br><span class="line">	<span class="keyword">if</span> nanotime() == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;nanotime returning zero&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Defer unlock so that runtime.Goexit during init does the unlock too.</span></span><br><span class="line">	needUnlock := <span class="literal">true</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> needUnlock &#123;</span><br><span class="line">			unlockOSThread()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Record when the world started.</span></span><br><span class="line">	runtimeInitTime = nanotime()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动GC</span></span><br><span class="line">	gcenable()</span><br><span class="line"></span><br><span class="line">	main_init_done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">if</span> iscgo &#123;</span><br><span class="line">		<span class="keyword">if</span> _cgo_thread_start == <span class="literal">nil</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;_cgo_thread_start missing&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> GOOS != <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> _cgo_setenv == <span class="literal">nil</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;_cgo_setenv missing&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> _cgo_unsetenv == <span class="literal">nil</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;_cgo_unsetenv missing&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> _cgo_notify_runtime_init_done == <span class="literal">nil</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;_cgo_notify_runtime_init_done missing&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Start the template thread in case we enter Go from</span></span><br><span class="line">		<span class="comment">// a C-created thread and need to create a new thread.</span></span><br><span class="line">		startTemplateThread()</span><br><span class="line">		cgocall(_cgo_notify_runtime_init_done, <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	doInit(&amp;main_inittask)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(main_init_done)</span><br><span class="line"></span><br><span class="line">	needUnlock = <span class="literal">false</span></span><br><span class="line">	unlockOSThread()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> isarchive || islibrary &#123;</span><br><span class="line">		<span class="comment">// A program compiled with -buildmode=c-archive or c-shared</span></span><br><span class="line">		<span class="comment">// has a main, but it is not executed.</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对于main函数的回调，也就是用户写的main程序</span></span><br><span class="line">	fn := main_main <span class="comment">// make an indirect call, as the linker doesn&#x27;t know the address of the main package when laying down the runtime</span></span><br><span class="line">	fn()</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		racefini()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make racy client program work: if panicking on</span></span><br><span class="line">	<span class="comment">// another goroutine at the same time as main returns,</span></span><br><span class="line">	<span class="comment">// let the other goroutine finish printing the panic trace.</span></span><br><span class="line">    <span class="comment">// Once it does, it will exit. See issues 3934 and 20018.</span></span><br><span class="line">    <span class="comment">//判断panicDefer函数，，，，，，</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;runningPanicDefers) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Running deferred functions should not take long.</span></span><br><span class="line">		<span class="keyword">for</span> c := <span class="number">0</span>; c &lt; <span class="number">1000</span>; c++ &#123;</span><br><span class="line">			<span class="keyword">if</span> atomic.Load(&amp;runningPanicDefers) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			Gosched()</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断panic</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;panicking) != <span class="number">0</span> &#123;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonPanicWait, traceEvGoStop, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//正常退出了那.....</span></span><br><span class="line">	exit(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> x *<span class="type">int32</span></span><br><span class="line">		*x = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="systemstack"><a class="header-anchor" href="#systemstack">¶</a>systemstack</h3>
<blockquote>
<p>这个函数，在整个系统中较为重要，来看看官方说明</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// systemstack runs fn on a system stack.</span></span><br><span class="line"><span class="comment">// If systemstack is called from the per-OS-thread (g0) stack, or</span></span><br><span class="line"><span class="comment">// if systemstack is called from the signal handling (gsignal) stack,</span></span><br><span class="line"><span class="comment">// systemstack calls fn directly and returns.</span></span><br><span class="line"><span class="comment">//g0 stack或者信号处理的，就直接调用并返回。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Otherwise, systemstack is being called from the limited stack</span></span><br><span class="line"><span class="comment">// of an ordinary goroutine. In this case, systemstack switches</span></span><br><span class="line"><span class="comment">// to the per-OS-thread stack, calls fn, and switches back.</span></span><br><span class="line"><span class="comment">// It is common to use a func literal as the argument, in order</span></span><br><span class="line"><span class="comment">// to share inputs and outputs with the code around the call</span></span><br><span class="line"><span class="comment">// to system stack:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	... set up y ...</span></span><br><span class="line"><span class="comment">//	systemstack(func() &#123;</span></span><br><span class="line"><span class="comment">//		x = bigcall(y)</span></span><br><span class="line"><span class="comment">//	&#125;)</span></span><br><span class="line"><span class="comment">//	... use x ...</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:noescape</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">systemstack</span><span class="params">(fn <span class="keyword">func</span>()</span></span>)</span><br></pre></td></tr></table></figure>
<h3 id="newm"><a class="header-anchor" href="#newm">¶</a>newm</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a new m. It will start off with a call to fn, or else the scheduler.</span></span><br><span class="line"><span class="comment">// fn needs to be static and not a heap allocated closure.</span></span><br><span class="line"><span class="comment">// May run with m.p==nil, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于创建新的M，fn:sysmon函数，类似于事件驱动类型的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm</span><span class="params">(fn <span class="keyword">func</span>()</span></span>, _p_ *p) &#123;</span><br><span class="line">	<span class="comment">//分配内存</span></span><br><span class="line">	mp := allocm(_p_, fn)</span><br><span class="line">	mp.nextp.set(_p_)</span><br><span class="line">	mp.sigmask = initSigmask</span><br><span class="line">	<span class="keyword">if</span> gp := getg(); gp != <span class="literal">nil</span> &amp;&amp; gp.m != <span class="literal">nil</span> &amp;&amp; (gp.m.lockedExt != <span class="number">0</span> || gp.m.incgo) &amp;&amp; GOOS != <span class="string">&quot;plan9&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// We&#x27;re on a locked M or a thread that may have been</span></span><br><span class="line">		<span class="comment">// started by C. The kernel state of this thread may</span></span><br><span class="line">		<span class="comment">// be strange (the user may have locked it for that</span></span><br><span class="line">		<span class="comment">// purpose). We don&#x27;t want to clone that into another</span></span><br><span class="line">		<span class="comment">// thread. Instead, ask a known-good thread to create</span></span><br><span class="line">		<span class="comment">// the thread for us.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// This is disabled on Plan 9. See golang.org/issue/22227.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> This may be unnecessary on Windows, which</span></span><br><span class="line">		<span class="comment">// doesn&#x27;t model thread creation off fork.</span></span><br><span class="line">		lock(&amp;newmHandoff.lock)</span><br><span class="line">		<span class="keyword">if</span> newmHandoff.haveTemplateThread == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;on a locked thread with no template thread&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		mp.schedlink = newmHandoff.newm</span><br><span class="line">		newmHandoff.newm.set(mp)</span><br><span class="line">		<span class="keyword">if</span> newmHandoff.waiting &#123;</span><br><span class="line">			newmHandoff.waiting = <span class="literal">false</span></span><br><span class="line">			notewakeup(&amp;newmHandoff.wake)</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;newmHandoff.lock)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	newm1(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主要是以下几个函数：</p>
</blockquote>
<ul>
<li>allocm</li>
<li>notewakeup</li>
<li>newm1</li>
</ul>
<h3 id="sysmon"><a class="header-anchor" href="#sysmon">¶</a>sysmon</h3>
<p>学习系统监控之前，先学下部分函数的使用和其大概含义：</p>
<ul>
<li>checkdead</li>
<li>usleep</li>
<li>timeSleepUntil</li>
<li>nanotime</li>
<li>netpollinited</li>
<li>startm</li>
<li>retake</li>
<li>gcTrigger</li>
<li>injectglist</li>
</ul>
<blockquote>
<p>先看下主体流程</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Always runs without a P, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	sched.nmsys++</span><br><span class="line">	<span class="comment">//基于running中的M，检查死锁，，，，</span></span><br><span class="line">	checkdead()</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	lasttrace := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">	idle := <span class="number">0</span> <span class="comment">// how many cycles in succession we had not wokeup somebody</span></span><br><span class="line">	delay := <span class="type">uint32</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> idle == <span class="number">0</span> &#123; <span class="comment">// start with 20us sleep...</span></span><br><span class="line">			delay = <span class="number">20</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> idle &gt; <span class="number">50</span> &#123; <span class="comment">// start doubling the sleep after 1ms...</span></span><br><span class="line">			delay *= <span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> delay &gt; <span class="number">10</span>*<span class="number">1000</span> &#123; <span class="comment">// up to 10ms</span></span><br><span class="line">			delay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//休眠时间</span></span><br><span class="line">		usleep(delay)</span><br><span class="line">		<span class="comment">//获取时间</span></span><br><span class="line">		now := nanotime()</span><br><span class="line">		<span class="comment">// 休眠等待唤醒信号</span></span><br><span class="line">		next, _ := timeSleepUntil()</span><br><span class="line">		<span class="keyword">if</span> debug.schedtrace &lt;= <span class="number">0</span> &amp;&amp; (sched.gcwaiting != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="type">uint32</span>(gomaxprocs)) &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">if</span> atomic.Load(&amp;sched.gcwaiting) != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="type">uint32</span>(gomaxprocs) &#123;</span><br><span class="line">				<span class="keyword">if</span> next &gt; now &#123;</span><br><span class="line">					atomic.Store(&amp;sched.sysmonwait, <span class="number">1</span>)</span><br><span class="line">					unlock(&amp;sched.lock)</span><br><span class="line">					<span class="comment">// Make wake-up period small enough</span></span><br><span class="line">					<span class="comment">// for the sampling to be correct.</span></span><br><span class="line">					sleep := forcegcperiod / <span class="number">2</span></span><br><span class="line">					<span class="keyword">if</span> next-now &lt; sleep &#123;</span><br><span class="line">						sleep = next - now</span><br><span class="line">					&#125;</span><br><span class="line">					shouldRelax := sleep &gt;= osRelaxMinNS</span><br><span class="line">					<span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">						osRelax(<span class="literal">true</span>)</span><br><span class="line">					&#125;</span><br><span class="line">					notetsleep(&amp;sched.sysmonnote, sleep)</span><br><span class="line">					<span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">						osRelax(<span class="literal">false</span>)</span><br><span class="line">					&#125;</span><br><span class="line">					now = nanotime()</span><br><span class="line">					next, _ = timeSleepUntil()</span><br><span class="line">					lock(&amp;sched.lock)</span><br><span class="line">					atomic.Store(&amp;sched.sysmonwait, <span class="number">0</span>)</span><br><span class="line">					noteclear(&amp;sched.sysmonnote)</span><br><span class="line">				&#125;</span><br><span class="line">				idle = <span class="number">0</span></span><br><span class="line">				delay = <span class="number">20</span></span><br><span class="line">			&#125;</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125;</span><br><span class="line">		lock(&amp;sched.sysmonlock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// If we spent a long time blocked on sysmonlock</span></span><br><span class="line">			<span class="comment">// then we want to update now and next since it&#x27;s</span></span><br><span class="line">			<span class="comment">// likely stale.</span></span><br><span class="line">			now1 := nanotime()</span><br><span class="line">			<span class="keyword">if</span> now1-now &gt; <span class="number">50</span>*<span class="number">1000</span> <span class="comment">/* 50µs */</span> &#123;</span><br><span class="line">				next, _ = timeSleepUntil()</span><br><span class="line">			&#125;</span><br><span class="line">			now = now1</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// trigger libc interceptors if needed</span></span><br><span class="line">		<span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">			asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// poll network if not polled for more than 10ms</span></span><br><span class="line">		<span class="comment">//在队列中等待调度超过10ms，就给交给global抢渡了</span></span><br><span class="line">		lastpoll := <span class="type">int64</span>(atomic.Load64(&amp;sched.lastpoll))</span><br><span class="line">		<span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">			atomic.Cas64(&amp;sched.lastpoll, <span class="type">uint64</span>(lastpoll), <span class="type">uint64</span>(now))</span><br><span class="line">			list := netpoll(<span class="number">0</span>) <span class="comment">// non-blocking - returns list of goroutines</span></span><br><span class="line">			<span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">				<span class="comment">// Need to decrement number of idle locked M&#x27;s</span></span><br><span class="line">				<span class="comment">// (pretending that one more is running) before injectglist.</span></span><br><span class="line">				<span class="comment">// Otherwise it can lead to the following situation:</span></span><br><span class="line">				<span class="comment">// injectglist grabs all P&#x27;s but before it starts M&#x27;s to run the P&#x27;s,</span></span><br><span class="line">				<span class="comment">// another M returns from syscall, finishes running its G,</span></span><br><span class="line">				<span class="comment">// observes that there is no work to do and no other running M&#x27;s</span></span><br><span class="line">				<span class="comment">// and reports deadlock.</span></span><br><span class="line">				incidlelocked(<span class="number">-1</span>)</span><br><span class="line">				<span class="comment">//注入全局g队列中</span></span><br><span class="line">				injectglist(&amp;list)</span><br><span class="line">				incidlelocked(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> next &lt; now &#123;</span><br><span class="line">			<span class="comment">// There are timers that should have already run,</span></span><br><span class="line">			<span class="comment">// perhaps because there is an unpreemptible P.</span></span><br><span class="line">			<span class="comment">// Try to start an M to run them.</span></span><br><span class="line">			<span class="comment">//需要一个新的M来跑P上面的G。</span></span><br><span class="line">			startm(<span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.Load(&amp;scavenge.sysmonWake) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Kick the scavenger awake if someone requested it.</span></span><br><span class="line">			wakeScavenger()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// retake P&#x27;s blocked in syscalls</span></span><br><span class="line">		<span class="comment">// and preempt long running G&#x27;s</span></span><br><span class="line">		<span class="comment">// 循环所有的allp，进行抢夺。</span></span><br><span class="line">		<span class="keyword">if</span> retake(now) != <span class="number">0</span> &#123;</span><br><span class="line">			idle = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			idle++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// check if we need to force a GC</span></span><br><span class="line">		<span class="comment">//强行GC</span></span><br><span class="line">		<span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != <span class="number">0</span> &#123;</span><br><span class="line">			lock(&amp;forcegc.lock)</span><br><span class="line">			forcegc.idle = <span class="number">0</span></span><br><span class="line">			<span class="keyword">var</span> list gList</span><br><span class="line">			list.push(forcegc.g)</span><br><span class="line">			injectglist(&amp;list)</span><br><span class="line">			unlock(&amp;forcegc.lock)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> debug.schedtrace &gt; <span class="number">0</span> &amp;&amp; lasttrace+<span class="type">int64</span>(debug.schedtrace)*<span class="number">1000000</span> &lt;= now &#123;</span><br><span class="line">			lasttrace = now</span><br><span class="line">			schedtrace(debug.scheddetail &gt; <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;sched.sysmonlock)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="doInit"><a class="header-anchor" href="#doInit">¶</a>doInit</h3>
<blockquote>
<p>这一部分在源码看来，没有具体的作用，，，，，，，，todo标签吧。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doInit</span><span class="params">(t *initTask)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> t.state &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// fully initialized</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// initialization in progress</span></span><br><span class="line">		throw(<span class="string">&quot;recursive call during initialization - linker skew&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">// not initialized yet</span></span><br><span class="line">		t.state = <span class="number">1</span> <span class="comment">// initialization in progress</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; t.ndeps; i++ &#123;</span><br><span class="line">			p := add(unsafe.Pointer(t), (<span class="number">3</span>+i)*sys.PtrSize)</span><br><span class="line">			t2 := *(**initTask)(p)</span><br><span class="line">			doInit(t2)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; t.nfns; i++ &#123;</span><br><span class="line">			p := add(unsafe.Pointer(t), (<span class="number">3</span>+t.ndeps+i)*sys.PtrSize)</span><br><span class="line">			f := *(*<span class="function"><span class="keyword">func</span><span class="params">()</span></span>)(unsafe.Pointer(&amp;p))</span><br><span class="line">			f()</span><br><span class="line">		&#125;</span><br><span class="line">		t.state = <span class="number">2</span> <span class="comment">// initialization done</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gcenable"><a class="header-anchor" href="#gcenable">¶</a>gcenable</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcenable is called after the bulk of the runtime initialization,</span></span><br><span class="line"><span class="comment">// just before we&#x27;re about to start letting user code run.</span></span><br><span class="line"><span class="comment">// It kicks off the background sweeper goroutine, the background</span></span><br><span class="line"><span class="comment">// scavenger goroutine, and enables GC.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcenable</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Kick off sweeping and scavenging.</span></span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> bgsweep(c)</span><br><span class="line">	<span class="keyword">go</span> bgscavenge(c)</span><br><span class="line">	&lt;-c</span><br><span class="line">	&lt;-c</span><br><span class="line">	memstats.enablegc = <span class="literal">true</span> <span class="comment">// now that runtime is initialized, GC is okay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Gosched"><a class="header-anchor" href="#Gosched">¶</a>Gosched</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Gosched yields the processor, allowing other goroutines to run. It does not</span></span><br><span class="line"><span class="comment">// suspend the current goroutine, so execution resumes automatically.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Gosched</span><span class="params">()</span></span> &#123;</span><br><span class="line">	checkTimeouts()</span><br><span class="line">	mcall(gosched_m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gopark"><a class="header-anchor" href="#gopark">¶</a>gopark</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Puts the current goroutine into a waiting state and calls unlockf.</span></span><br><span class="line"><span class="comment">// If unlockf returns false, the goroutine is resumed.</span></span><br><span class="line"><span class="comment">// unlockf must not access this G&#x27;s stack, as it may be moved between</span></span><br><span class="line"><span class="comment">// the call to gopark and the call to unlockf.</span></span><br><span class="line"><span class="comment">// Reason explains why the goroutine has been parked.</span></span><br><span class="line"><span class="comment">// It is displayed in stack traces and heap dumps.</span></span><br><span class="line"><span class="comment">// Reasons should be unique and descriptive.</span></span><br><span class="line"><span class="comment">// Do not re-use reasons, add new ones.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopark</span><span class="params">(unlockf <span class="keyword">func</span>(*g, unsafe.Pointer)</span></span> <span class="type">bool</span>, lock unsafe.Pointer, reason waitReason, traceEv <span class="type">byte</span>, traceskip <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> reason != waitReasonSleep &#123;</span><br><span class="line">		checkTimeouts() <span class="comment">// timeouts may expire while two goroutines keep the scheduler busy</span></span><br><span class="line">	&#125;</span><br><span class="line">	mp := acquirem()</span><br><span class="line">	gp := mp.curg</span><br><span class="line">	status := readgstatus(gp)</span><br><span class="line">	<span class="keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;</span><br><span class="line">		throw(<span class="string">&quot;gopark: bad g status&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mp.waitlock = lock</span><br><span class="line">	mp.waitunlockf = unlockf</span><br><span class="line">	gp.waitreason = reason</span><br><span class="line">	mp.waittraceev = traceEv</span><br><span class="line">	mp.waittraceskip = traceskip</span><br><span class="line">	<span class="comment">//mp解绑</span></span><br><span class="line">	releasem(mp)</span><br><span class="line">	<span class="comment">// can&#x27;t do anything that might move the G between Ms here.</span></span><br><span class="line">	mcall(park_m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后续"><a class="header-anchor" href="#后续">¶</a>后续</h3>
<blockquote>
<p>关于里面的重要部分实现细节，不是本次关注的重点，，，，</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">这次主要看到的是Go围绕main函数，为了程序的正常启动，所做的工作.</span><br><span class="line"></span><br><span class="line">无论是g的启动还是调度监控方面，也就是从整个生命周期来考虑，，，，，，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">还有一个就是关于panic的处理，采用事件驱动的方式，很好的获取到panic,进行后续的处理。</span><br><span class="line"></span><br><span class="line">最后还有一个关于全局locktrhead，，，，，，粒度尽量细小，有利于提高性能。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>GPM</tag>
        <tag>Go源码</tag>
      </tags>
  </entry>
  <entry>
    <title>「22」GPM g0和m0</title>
    <url>/archives/392d66f0.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p>GPM算是经典的调度模型，但是每个程序都需要一个启动的函数或者入口；<br>
GPM也不例外。<br>
直接分析源码，显得很枯燥，如果说要你设计GPM中的G和M的执行关系，你应该怎么设计呢？</p>
<span id="more"></span>
<blockquote>
<p>go version: 1.14.3</p>
</blockquote>
<h3 id="尝试设计"><a class="header-anchor" href="#尝试设计">¶</a>尝试设计</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/GPM202011182201.png" alt=""><br>
如果只是这样的话，那总体的G和M是否需要管理者，毕竟在1.1版本之前只有GM模型，，，<br>
那么为了好管理M和G，就需要第一个M和G成为管理者，类似于大总管这样的存在。</p>
<h3 id="再次设计"><a class="header-anchor" href="#再次设计">¶</a>再次设计</h3>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/GPM202011182219.png" alt=""></p>
<h3 id="关键点："><a class="header-anchor" href="#关键点：">¶</a>关键点：</h3>
<ul>
<li>p先启动</li>
<li>g0的创建；用于创建新的G</li>
<li>m0的创建；用于创建新的M</li>
<li>启动main调度整个系统</li>
</ul>
<blockquote>
<p>上述这样比较合理点。</p>
</blockquote>
<h3 id="Go源码的如何实现？"><a class="header-anchor" href="#Go源码的如何实现？">¶</a>Go源码的如何实现？</h3>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/proc.go#L524">bootstrap sequence</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The bootstrap sequence is:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	call osinit</span></span><br><span class="line"><span class="comment">//	call schedinit</span></span><br><span class="line"><span class="comment">//	make &amp; queue new G</span></span><br><span class="line"><span class="comment">//	call runtime·mstart</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The new G calls runtime·main.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/asm_amd64.s#L194">g0和m0初始化过程</a></p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set the per-goroutine and per-mach &quot;registers&quot;</span></span><br><span class="line">	get_tls(BX)</span><br><span class="line">	LEAQ	runtime·g0(SB), CX</span><br><span class="line">	MOVQ	CX, g(BX)</span><br><span class="line">	LEAQ	runtime·m0(SB), AX</span><br><span class="line"></span><br><span class="line">	<span class="comment">// save m-&gt;g0 = g0</span></span><br><span class="line">	MOVQ	CX, m_g0(AX)</span><br><span class="line">	<span class="comment">// save m0 to g0-&gt;m</span></span><br><span class="line">	MOVQ	AX, g_m(CX)</span><br><span class="line"></span><br><span class="line">	CLD				<span class="comment">// convention is D is always left cleared</span></span><br><span class="line">	CALL	runtime·check(SB)</span><br><span class="line"></span><br><span class="line">	MOVL	<span class="number">16</span>(SP), AX		<span class="comment">// copy argc</span></span><br><span class="line">	MOVL	AX, <span class="number">0</span>(SP)</span><br><span class="line">	MOVQ	<span class="number">24</span>(SP), AX		<span class="comment">// copy argv</span></span><br><span class="line">	MOVQ	AX, <span class="number">8</span>(SP)</span><br><span class="line">	CALL	runtime·args(SB)</span><br><span class="line">	CALL	runtime·osinit(SB)</span><br><span class="line">	CALL	runtime·schedinit(SB)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a new goroutine to start program</span></span><br><span class="line">	MOVQ	$runtime·mainPC(SB), AX		<span class="comment">// entry</span></span><br><span class="line">	PUSHQ	AX</span><br><span class="line">	PUSHQ	$<span class="number">0</span>			<span class="comment">// arg size</span></span><br><span class="line">	CALL	runtime·newproc(SB)</span><br><span class="line">	POPQ	AX</span><br><span class="line">	POPQ	AX</span><br><span class="line"></span><br><span class="line">	<span class="comment">// start this M</span></span><br><span class="line">	CALL	runtime·mstart(SB)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>到这里了，初始化思路基本确定了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、initP</span><br><span class="line">2、m0和g0的绑定</span><br><span class="line">3、new groutine for main主线程启动</span><br><span class="line">4、mstart</span><br></pre></td></tr></table></figure>
<h3 id="m-init涉及到的函数"><a class="header-anchor" href="#m-init涉及到的函数">¶</a>m init涉及到的函数</h3>
<ul>
<li>mstart</li>
<li>mstart1</li>
<li>mstartm0</li>
</ul>
<h4 id="mstart"><a class="header-anchor" href="#mstart">¶</a>mstart</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mstart is the entry-point for new Ms.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This must not split the stack because we may not even have stack</span></span><br><span class="line"><span class="comment">// bounds set up yet.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// May run during STW (because it doesn&#x27;t have a P yet), so write</span></span><br><span class="line"><span class="comment">// barriers are not allowed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//低位判断</span></span><br><span class="line">	osStack := _g_.stack.lo == <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> osStack &#123;</span><br><span class="line">		<span class="comment">// Initialize stack bounds from system stack.</span></span><br><span class="line">		<span class="comment">// Cgo may have left stack size in stack.hi.</span></span><br><span class="line">		<span class="comment">// minit may update the stack bounds.</span></span><br><span class="line">		size := _g_.stack.hi</span><br><span class="line">		<span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">			size = <span class="number">8192</span> * sys.StackGuardMultiplier</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//g0的stack空间是真的大</span></span><br><span class="line">		_g_.stack.hi = <span class="type">uintptr</span>(noescape(unsafe.Pointer(&amp;size)))</span><br><span class="line">		_g_.stack.lo = _g_.stack.hi - size + <span class="number">1024</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Initialize stack guard so that we can start calling regular</span></span><br><span class="line">	<span class="comment">// Go code.</span></span><br><span class="line">	_g_.stackguard0 = _g_.stack.lo + _StackGuard</span><br><span class="line">	<span class="comment">// This is the g0, so we can also call go:systemstack</span></span><br><span class="line">	<span class="comment">// functions, which check stackguard1.</span></span><br><span class="line">	_g_.stackguard1 = _g_.stackguard0</span><br><span class="line">	mstart1()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Exit this thread.</span></span><br><span class="line">	<span class="keyword">switch</span> GOOS &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;windows&quot;</span>, <span class="string">&quot;solaris&quot;</span>, <span class="string">&quot;illumos&quot;</span>, <span class="string">&quot;plan9&quot;</span>, <span class="string">&quot;darwin&quot;</span>, <span class="string">&quot;aix&quot;</span>:</span><br><span class="line">		<span class="comment">// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate</span></span><br><span class="line">		<span class="comment">// the stack, but put it in _g_.stack before mstart,</span></span><br><span class="line">		<span class="comment">// so the logic above hasn&#x27;t set osStack yet.</span></span><br><span class="line">		osStack = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	mexit(osStack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mstart1"><a class="header-anchor" href="#mstart1">¶</a>mstart1</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动非g0就崩盘了</span></span><br><span class="line">	<span class="keyword">if</span> _g_ != _g_.m.g0 &#123;</span><br><span class="line">		throw(<span class="string">&quot;bad runtime·mstart&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">	<span class="comment">// Record the caller for use as the top of stack in mcall and</span></span><br><span class="line">	<span class="comment">// for terminating the thread.</span></span><br><span class="line">	<span class="comment">// We&#x27;re never coming back to mstart1 after we call schedule,</span></span><br><span class="line">	<span class="comment">// so other calls can reuse the current frame.</span></span><br><span class="line">	save(getcallerpc(), getcallersp())</span><br><span class="line">	asminit()</span><br><span class="line">	minit()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Install signal handlers; after minit so that minit can</span></span><br><span class="line">    <span class="comment">// prepare the thread to be able to handle the signals.</span></span><br><span class="line">    <span class="comment">//m0启动</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m == &amp;m0 &#123;</span><br><span class="line">		mstartm0()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fn := _g_.m.mstartfn; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">		fn()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m != &amp;m0 &#123;</span><br><span class="line">		acquirep(_g_.m.nextp.ptr())</span><br><span class="line">		_g_.m.nextp = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始调度</span></span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mstartm0"><a class="header-anchor" href="#mstartm0">¶</a>mstartm0</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mstart1的具体实现，仅run在m0上</span></span><br><span class="line"><span class="comment">// mstartm0 implements part of mstart1 that only runs on the m0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write barriers are allowed here because we know the GC can&#x27;t be</span></span><br><span class="line"><span class="comment">// running yet, so they&#x27;ll be no-ops.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:yeswritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstartm0</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Create an extra M for callbacks on threads not created by Go.</span></span><br><span class="line">	<span class="comment">// An extra M is also needed on Windows for callbacks created by</span></span><br><span class="line">    <span class="comment">// syscall.NewCallback. See issue #6751 for details.</span></span><br><span class="line">    <span class="comment">//windows下需要一个额外的M</span></span><br><span class="line">	<span class="keyword">if</span> (iscgo || GOOS == <span class="string">&quot;windows&quot;</span>) &amp;&amp; !cgoHasExtraM &#123;</span><br><span class="line">		cgoHasExtraM = <span class="literal">true</span></span><br><span class="line">		newextram()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化信号量,用于后续调度</span></span><br><span class="line">	initsig(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后续schedule函数"><a class="header-anchor" href="#后续schedule函数">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/proc.go#L1119">后续schedule函数</a></h4>
<blockquote>
<p>管家有了，那么开始调度吧…。</p>
</blockquote>
<h3 id="下节："><a class="header-anchor" href="#下节：">¶</a>下节：</h3>
<ul>
<li>schedule</li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>GPM</tag>
        <tag>Go源码</tag>
      </tags>
  </entry>
  <entry>
    <title>「21」linux select源码</title>
    <url>/archives/ba7b70bf.html</url>
    <content><![CDATA[<blockquote>
<p>select poll epoll三个老生长谈的问题.这次不是来讲区别的，后续会更新一篇关于三者区别的。</p>
</blockquote>
<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p>select属于linux系列的文件系统「fs」的范畴，每次的系统调用、打开软件、启动程序等等都会涉及到文件的读写，<br>
这个是在所难免的。</p>
<p>那么I/O事件的基本思路：文件准备ok，开始读写，等函数返回，根据结果继续运行.</p>
<p>如果是自己实现，大体上无非以下思路：</p>
<span id="more"></span>
<ul>
<li>创建多个进程/线程来监听</li>
<li>Non-blocking读写监听的轮询</li>
<li>异步I/O与Unix Signal事件机制</li>
</ul>
<p>先来学习下linux源码是怎么处理select机制的：</p>
<blockquote>
<p>linux version: 5.10-r5</p>
</blockquote>
<h3 id="概览图"><a class="header-anchor" href="#概览图">¶</a>概览图</h3>
<p>梳理了下，大概整理成了流程图：</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/linux%E6%BA%90%E7%A0%81-select-1.png" alt=""></p>
<h3 id="select切入点"><a class="header-anchor" href="#select切入点">¶</a>select切入点</h3>
<p>既然知道了select属于fs系列的，那就很容易找到:[fs/select.c]</p>
<p>查看select命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man 2 select</span><br></pre></td></tr></table></figure>
<p>下面按照以下顺序来解读，一起学习：</p>
<ul>
<li>入口 SYSCALL_DEFINE5</li>
<li>核心函数 do_select</li>
<li>设备驱动的操作函数</li>
<li>poll_wait与设备的等待队列</li>
<li>fd数量限制「why」</li>
<li>select与poll</li>
</ul>
<h3 id="SYSCALL-DEFINE5"><a class="header-anchor" href="#SYSCALL-DEFINE5">¶</a>SYSCALL_DEFINE5</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SYSCALL_DEFINE5</span>(select, <span class="type">int</span>, n, fd_set __user *, inp, fd_set __user *, outp,</span><br><span class="line">		fd_set __user *, exp, <span class="keyword">struct</span> __kernel_old_timeval __user *, tvp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">kern_select</span>(n, inp, outp, exp, tvp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数：core_sys_select中主要的do_select处理其中的逻辑</p>
<h3 id="do-select"><a class="header-anchor" href="#do-select">¶</a>do_select</h3>
<p>关键性的结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *in, *out, *ex; <span class="comment">//输出 、输入、异常</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *res_in, *res_out, *res_ex;</span><br><span class="line">&#125; fd_set_bits;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">do_select</span><span class="params">(<span class="type">int</span> n, fd_set_bits *fds, <span class="keyword">struct</span> timespec64 *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">ktime_t</span> expire, *to = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">poll_wqueues</span> table;</span><br><span class="line">	poll_table *wait;</span><br><span class="line">	<span class="type">int</span> retval, i, timed_out = <span class="number">0</span>;</span><br><span class="line">	u64 slack = <span class="number">0</span>;</span><br><span class="line">	<span class="type">__poll_t</span> busy_flag = <span class="built_in">net_busy_loop_on</span>() ? POLL_BUSY_LOOP : <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> busy_start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">rcu_read_lock</span>();</span><br><span class="line">    <span class="comment">//找出文件的最大描述符</span></span><br><span class="line">	retval = <span class="built_in">max_select_fd</span>(n, fds);</span><br><span class="line">	<span class="built_in">rcu_read_unlock</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	n = retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">	<span class="built_in">poll_initwait</span>(&amp;table);</span><br><span class="line">	wait = &amp;table.pt;</span><br><span class="line">	<span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;</span><br><span class="line">		wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">		timed_out = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (end_time &amp;&amp; !timed_out)</span><br><span class="line">		slack = <span class="built_in">select_estimate_accuracy</span>(end_time);</span><br><span class="line"></span><br><span class="line">	retval = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> *rinp, *routp, *rexp, *inp, *outp, *exp;</span><br><span class="line">		<span class="type">bool</span> can_busy_loop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		inp = fds-&gt;in; outp = fds-&gt;out; exp = fds-&gt;ex;</span><br><span class="line">		rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历所有的fd.......同步等.....</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> in, out, ex, all_bits, bit = <span class="number">1</span>, j;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line">			<span class="type">__poll_t</span> mask;</span><br><span class="line"></span><br><span class="line">			in = *inp++; out = *outp++; ex = *exp++;</span><br><span class="line">			all_bits = in | out | ex;</span><br><span class="line">            <span class="comment">//没有任何注册事件</span></span><br><span class="line">			<span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;</span><br><span class="line">				i += BITS_PER_LONG;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BITS_PER_LONG; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">struct</span> <span class="title class_">fd</span> f;</span><br><span class="line">				<span class="keyword">if</span> (i &gt;= n)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//跳过未注册的</span></span><br><span class="line">				<span class="keyword">if</span> (!(bit &amp; all_bits))</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				f = <span class="built_in">fdget</span>(i);</span><br><span class="line">				<span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">					<span class="built_in">wait_key_set</span>(wait, in, out, bit,</span><br><span class="line">						     busy_flag);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//对每一个fd进行检测</span></span><br><span class="line">					mask = <span class="built_in">vfs_poll</span>(f.file, wait);</span><br><span class="line"></span><br><span class="line">					<span class="built_in">fdput</span>(f);</span><br><span class="line">					<span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</span><br><span class="line">						res_in |= bit;</span><br><span class="line">						retval++;</span><br><span class="line">						wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;</span><br><span class="line">						res_out |= bit;</span><br><span class="line">						retval++;</span><br><span class="line">						wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;</span><br><span class="line">						res_ex |= bit;</span><br><span class="line">						retval++;</span><br><span class="line">						wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">/* got something, stop busy polling */</span></span><br><span class="line">					<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">						can_busy_loop = <span class="literal">false</span>;</span><br><span class="line">						busy_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					 * only remember a returned</span></span><br><span class="line"><span class="comment">					 * POLL_BUSY_LOOP if we asked for it</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> (busy_flag &amp; mask)</span><br><span class="line">						can_busy_loop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (res_in)</span><br><span class="line">				*rinp = res_in;</span><br><span class="line">			<span class="keyword">if</span> (res_out)</span><br><span class="line">				*routp = res_out;</span><br><span class="line">			<span class="keyword">if</span> (res_ex)</span><br><span class="line">				*rexp = res_ex;</span><br><span class="line">			<span class="built_in">cond_resched</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//退出循环，条件： 事件就绪/超时/收到信号</span></span><br><span class="line">		<span class="keyword">if</span> (retval || timed_out || <span class="built_in">signal_pending</span>(current))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (table.error) &#123;</span><br><span class="line">			retval = table.error;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* only if found POLL_BUSY_LOOP sockets &amp;&amp; not out of time */</span></span><br><span class="line">		<span class="keyword">if</span> (can_busy_loop &amp;&amp; !<span class="built_in">need_resched</span>()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!busy_start) &#123;</span><br><span class="line">				busy_start = <span class="built_in">busy_loop_current_time</span>();</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">busy_loop_timeout</span>(busy_start))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		busy_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If this is the first loop and we have a timeout</span></span><br><span class="line"><span class="comment">		 * given, then we convert to ktime_t and set the to</span></span><br><span class="line"><span class="comment">		 * pointer to the expiry value.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;</span><br><span class="line">			expire = <span class="built_in">timespec64_to_ktime</span>(*end_time);</span><br><span class="line">			to = &amp;expire;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//超时就休眠一会儿「中断会儿」</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">poll_schedule_timeout</span>(&amp;table, TASK_INTERRUPTIBLE,</span><br><span class="line">					   to, slack))</span><br><span class="line">			timed_out = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">poll_freewait</span>(&amp;table);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">poll_schedule_timeout</span><span class="params">(<span class="keyword">struct</span> poll_wqueues *pwq, <span class="type">int</span> state,</span></span></span><br><span class="line"><span class="params"><span class="function">			  <span class="type">ktime_t</span> *expires, <span class="type">unsigned</span> <span class="type">long</span> slack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> rc = -EINTR;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">set_current_state</span>(state);</span><br><span class="line">	<span class="keyword">if</span> (!pwq-&gt;triggered)</span><br><span class="line">		rc = <span class="built_in">schedule_hrtimeout_range</span>(expires, slack, HRTIMER_MODE_ABS);</span><br><span class="line">	__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Prepare for the next iteration.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The following smp_store_mb() serves two purposes.  First, it&#x27;s</span></span><br><span class="line"><span class="comment">	 * the counterpart rmb of the wmb in pollwake() such that data</span></span><br><span class="line"><span class="comment">	 * written before wake up is always visible after wake up.</span></span><br><span class="line"><span class="comment">	 * Second, the full barrier guarantees that triggered clearing</span></span><br><span class="line"><span class="comment">	 * doesn&#x27;t pass event check of the next iteration.  Note that</span></span><br><span class="line"><span class="comment">	 * this problem doesn&#x27;t exist for the first iteration as</span></span><br><span class="line"><span class="comment">	 * add_wait_queue() has full barrier semantics.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">smp_store_mb</span>(pwq-&gt;triggered, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="poll-wait"><a class="header-anchor" href="#poll-wait">¶</a>poll_wait</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * structures and helpers for f_op-&gt;poll implementations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//类似一个回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*poll_queue_proc)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">wait_queue_head_t</span> *, <span class="keyword">struct</span> poll_table_struct *)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">poll_table_struct</span> &#123;</span><br><span class="line">	poll_queue_proc _qproc; <span class="comment">//callback机制</span></span><br><span class="line">	<span class="type">__poll_t</span> _key;</span><br><span class="line">&#125; poll_table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">poll_wait</span><span class="params">(<span class="keyword">struct</span> file * filp, <span class="type">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p &amp;&amp; p-&gt;_qproc &amp;&amp; wait_address)</span><br><span class="line">		p-&gt;_qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fd数量问题"><a class="header-anchor" href="#fd数量问题">¶</a>fd数量问题</h3>
<blockquote>
<p>include/uapi/linux/posix_types.h</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __FD_SETSIZE	1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">//__FD_SETSIZE当下标使？？？what！</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> fds_bits[__FD_SETSIZE / (<span class="number">8</span> * <span class="built_in">sizeof</span>(<span class="type">long</span>))];</span><br><span class="line">&#125; __kernel_fd_set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fd</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file</span> *file;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面看来文件描述符只是一个整数值，用来操作下标的，主要是每一个进程file数组的下标。理解do_select是核心。</p>
</blockquote>
<h3 id="select-与poll"><a class="header-anchor" href="#select-与poll">¶</a>select 与poll</h3>
<blockquote>
<p>poll取消了最大数量的限制,返回结果还是需要轮询来获取就绪的描述符。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">short</span> events; <span class="comment">//request</span></span><br><span class="line">	<span class="type">short</span> revents; <span class="comment">// return</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>具体见后续更新「poll源码」</p>
<h3 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h3>
<p><a href="https://www.oreilly.com/openbook/linuxdrive3/book/">Linux Device Drivers, Third Edition</a><br>
<a href="https://stackoverflow.com/questions/11496059/how-do-system-calls-like-select-or-poll-work-under-the-hood">How do system calls like select() or poll() work under the hood?</a></p>
]]></content>
      <tags>
        <tag>Day</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>「20」博客诡异事件</title>
    <url>/archives/5ce14ff5.html</url>
    <content><![CDATA[<h3 id="博客CI-CD崩了"><a class="header-anchor" href="#博客CI-CD崩了">¶</a>博客CI CD崩了</h3>
<blockquote>
<p>就在刚才修改了部分的config配置，后打了tag push了上去,</p>
</blockquote>
<blockquote>
<p>oh…GG了</p>
</blockquote>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">err: FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line">err: TypeError: Cannot read property &#x27;enable&#x27; of undefined</span><br><span class="line">err:     at ***/themes/nextTheme/scripts/filters/comment/disqus.js:11:21</span><br><span class="line">err:     at Filter.execSync (/***/node_modules/hexo/lib/extend/filter.js:74:28)</span><br><span class="line">err:     at Hexo.execFilterSync (/***/node_modules/hexo/lib/hexo/index.js:432:29)</span><br><span class="line">err:     at module.exports (***/themes/nextTheme/scripts/events/lib/injects.js:58:8)</span><br><span class="line">err:     at Hexo.&lt;anonymous&gt; (***/themes/nextTheme/scripts/events/index.js:9:27)</span><br><span class="line">err:     at Hexo.emit (events.js:314:20)</span><br><span class="line">err:     at Hexo._generate (/***/node_modules/hexo/lib/hexo/index.js:399:8)</span><br><span class="line">err:     at /***/node_modules/hexo/lib/hexo/index.js:249:***</span><br><span class="line">err:     at tryCatcher (/***/node_modules/bluebird/js/release/util.js:16:23)</span><br><span class="line">err:     at Promise._settlePromiseFromHandler (/***/node_modules/bluebird/js/release/promise.js:547:31)</span><br><span class="line">err:     at Promise._settlePromise (/***/node_modules/bluebird/js/release/promise.js:604:18)</span><br><span class="line">err:     at Promise._settlePromise0 (/***/node_modules/bluebird/js/release/promise.js:649:10)</span><br><span class="line">err:     at Promise._settlePromises (/***/node_modules/bluebird/js/release/promise.js:729:18)</span><br><span class="line">err:     at Promise._fulfill (/***/node_modules/bluebird/js/release/promise.js:673:18)</span><br><span class="line">err:     at PromiseArray._resolve (/***/node_modules/bluebird/js/release/promise_array.js:127:19)</span><br><span class="line">err:     at PromiseArray._promiseFulfilled (/***/node_modules/bluebird/js/release/promise_array.js:145:14)</span><br><span class="line">err:     at Promise._settlePromise (/***/node_modules/bluebird/js/release/promise.js:609:26)</span><br><span class="line">err:     at Promise._settlePromise0 (/***/node_modules/bluebird/js/release/promise.js:649:10)</span><br><span class="line">err:     at Promise._settlePromises (/***/node_modules/bluebird/js/release/promise.js:729:18)</span><br><span class="line">err:     at Promise._fulfill (/***/node_modules/bluebird/js/release/promise.js:673:18)</span><br><span class="line">err:     at Promise._resolveCallback (/***/node_modules/bluebird/js/release/promise.js:466:57)</span><br><span class="line">err:     at Promise._settlePromiseFromHandler (/***/node_modules/bluebird/js/release/promise.js:559:17)</span><br><span class="line">out: INFO  Start processing</span><br><span class="line">err: FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line">err: TypeError: Cannot read property &#x27;enable&#x27; of undefined</span><br><span class="line">err:     at ***/themes/nextTheme/scripts/filters/comment/disqus.js:11:21</span><br><span class="line">err:     at Filter.execSync (/***/node_modules/hexo/lib/extend/filter.js:74:28)</span><br><span class="line">err:     at Hexo.execFilterSync (/***/node_modules/hexo/lib/hexo/index.js:432:29)</span><br><span class="line">err:     at module.exports (***/themes/nextTheme/scripts/events/lib/injects.js:58:8)</span><br><span class="line">err:     at Hexo.&lt;anonymous&gt; (***/themes/nextTheme/scripts/events/index.js:9:27)</span><br><span class="line">err:     at Hexo.emit (events.js:314:20)</span><br><span class="line">err:     at Hexo._generate (/***/node_modules/hexo/lib/hexo/index.js:399:8)</span><br><span class="line">err:     at /***/node_modules/hexo/lib/hexo/index.js:249:***</span><br><span class="line">err:     at tryCatcher (/***/node_modules/bluebird/js/release/util.js:16:23)</span><br><span class="line">err:     at Promise._settlePromiseFromHandler (/***/node_modules/bluebird/js/release/promise.js:547:31)</span><br><span class="line">err:     at Promise._settlePromise (/***/node_modules/bluebird/js/release/promise.js:604:18)</span><br><span class="line">err:     at Promise._settlePromise0 (/***/node_modules/bluebird/js/release/promise.js:649:10)</span><br><span class="line">err:     at Promise._settlePromises (/***/node_modules/bluebird/js/release/promise.js:729:18)</span><br><span class="line">err:     at Promise._fulfill (/***/node_modules/bluebird/js/release/promise.js:673:18)</span><br><span class="line">err:     at PromiseArray._resolve (/***/node_modules/bluebird/js/release/promise_array.js:127:19)</span><br><span class="line">err:     at PromiseArray._promiseFulfilled (/***/node_modules/bluebird/js/release/promise_array.js:145:14)</span><br><span class="line">err:     at Promise._settlePromise (/***/node_modules/bluebird/js/release/promise.js:609:26)</span><br><span class="line">err:     at Promise._settlePromise0 (/***/node_modules/bluebird/js/release/promise.js:649:10)</span><br><span class="line">err:     at Promise._settlePromises (/***/node_modules/bluebird/js/release/promise.js:729:18)</span><br><span class="line">err:     at Promise._fulfill (/***/node_modules/bluebird/js/release/promise.js:673:18)</span><br><span class="line">err:     at Promise._resolveCallback (/***/node_modules/bluebird/js/release/promise.js:466:57)</span><br><span class="line">err:     at Promise._settlePromiseFromHandler (/***/node_modules/bluebird/js/release/promise.js:559:17)</span><br></pre></td></tr></table></figure>
<p>简单点，显示没有enable这个属性，，，，我懵了，这部署了多少次了，没有出现这么个错误啊。</p>
<p>先删了js，本地跑ok了，远端挂了，又提示另一个js错误。<br>
再删一个错误的js,再跑…又挂了!</p>
<h3 id="排查…"><a class="header-anchor" href="#排查…">¶</a>排查…</h3>
<blockquote>
<p>初步定位为文件没有更到最新</p>
</blockquote>
<p>本地ok,服务器部署不起来…</p>
<p>查下文件scp copy的工作流</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120201117-000817@2x.png" alt=""></p>
<p>看起来很简单，也很好用，但是呢，大坑来了…<br>
当时没有选择是否选择覆盖文件：</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120201117-001054@2x.png" alt=""></p>
<h3 id="问题点"><a class="header-anchor" href="#问题点">¶</a>问题点</h3>
<p>没有覆盖配置文件，导致残留或者修改不彻底，同名的始终不修改，导致的问题。</p>
<p>PS：花了半个小时定位这么个rewrite的问题！ 记着吧，提醒自己…</p>
<h3 id="参考："><a class="header-anchor" href="#参考：">¶</a>参考：</h3>
<p><a href="https://github.com/appleboy/scp-action/blob/master/action.yml#L44">copy workflow Github</a><br>
<a href="https://github.com/marketplace/actions/scp-files">scp copy workflow</a></p>
]]></content>
      <tags>
        <tag>Day</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>「19」GPM 调度流程</title>
    <url>/archives/5c6a362f.html</url>
    <content><![CDATA[<p>工欲善其事，必先知其所以然…<br>
学习GPM调度之前，先看下源码部分的准备工作吧，不然一脸茫然的看源码，基本不会有太多的收获.</p>
<h3 id="函数-变量初识"><a class="header-anchor" href="#函数-变量初识">¶</a>函数&amp; 变量初识</h3>
<blockquote></blockquote>
<span id="more"></span>
<blockquote>
<p>go version: 1.14.3</p>
</blockquote>
<h4 id="函数"><a class="header-anchor" href="#函数">¶</a>函数</h4>
<blockquote>
<p>/proc.go</p>
</blockquote>
<ul>
<li>main</li>
<li>sysmon</li>
<li>findrunnable</li>
<li>gopark「1.1」</li>
<li>gosched 「1.2」</li>
<li>mstart</li>
<li>wakep</li>
<li>schedule</li>
<li>cpuinit</li>
<li>schedinit</li>
<li>ready</li>
<li>readgstatus</li>
<li>startm</li>
<li>pollWork</li>
<li>injectglist</li>
<li>park_m</li>
<li>goyield</li>
<li>retake</li>
<li>globrunqput</li>
<li>globrunqputbatch</li>
<li>globrunqputhead</li>
</ul>
<h4 id="变量"><a class="header-anchor" href="#变量">¶</a>变量</h4>
<blockquote>
<p>/proc.go</p>
</blockquote>
<ul>
<li>m0</li>
<li>g0</li>
<li>allgs</li>
<li>allglock</li>
</ul>
<blockquote>
<p>/runtime2.go</p>
</blockquote>
<ul>
<li>g</li>
<li>p</li>
<li>m</li>
<li>allglen</li>
<li>allm</li>
<li>allp</li>
<li>allpLock</li>
<li>gomaxprocs</li>
<li>sched</li>
</ul>
<blockquote>
<p>/runtime2.go 常量</p>
</blockquote>
<ul>
<li>_Grunnable/_Grunning/_Gwaiting…</li>
</ul>
<h3 id="上述这些函数-变量-常量-what？"><a class="header-anchor" href="#上述这些函数-变量-常量-what？">¶</a>上述这些函数/变量/常量 what？</h3>
<p>写这么多，肯定不是简单的从源码仓库里面超出来，这些是一些比较重要的函数，当然还有很多没有罗列，这里主要想记录，也是思考的点：</p>
<ul>
<li>GPM为何会有这么多的状态</li>
<li>这些状态之间是如何配合和协调的</li>
<li>著名的工作偷取「P」是怎么操作的</li>
<li>如果让你设计，你应该会怎么设计GPM这个调度的过程「🏁重点」</li>
</ul>
<h3 id="切入点"><a class="header-anchor" href="#切入点">¶</a>切入点</h3>
<ul>
<li>main:入口函数</li>
<li>sysmon：监控调度线程</li>
<li>schedule：真实的调度器逻辑</li>
<li>m0/g0：特殊的存在体</li>
</ul>
<h3 id="如何开始？"><a class="header-anchor" href="#如何开始？">¶</a>如何开始？</h3>
<blockquote>
<p>简单点，从main开始.</p>
</blockquote>
<h3 id="瞎扯"><a class="header-anchor" href="#瞎扯">¶</a>瞎扯</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">看了很长时间的go源码了，觉得一个好的设计，从来不是简单的学习别人的源码，</span><br><span class="line">更多的是学习源码的设计思路和当时设计时是基于哪种场景下的。</span><br><span class="line"></span><br><span class="line">考虑更多的场景，有没有其它的设计思路，可能没有现有的设计更出色，但更加适合别的场景。</span><br></pre></td></tr></table></figure>
<h3 id="未完待续"><a class="header-anchor" href="#未完待续">¶</a>未完待续.</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>GPM</tag>
        <tag>Go源码</tag>
      </tags>
  </entry>
  <entry>
    <title>「18」GPM 初识/设计</title>
    <url>/archives/b885f9f7.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p>学go有一段时间了，最近总感觉忙碌无为，也该总结下前段时间读源码的一些心得和体会了。</p>
<p>GPM调度算是在Go中比较经典的了，有必要深入学习下。</p>
<blockquote>
<p><a href="https://golang.org/s/go11sched">Go GPM设计文档</a></p>
</blockquote>
<h3 id="GPM设计的由来"><a class="header-anchor" href="#GPM设计的由来">¶</a>GPM设计的由来</h3>
<p>一个好的设计，总会伴随发现现有的问题，在解决的基础上考虑场景并提高扩展性，先来了解下Go为何要重新设计GPM这个模型：</p>
<span id="more"></span>
<h4 id="现有的问题："><a class="header-anchor" href="#现有的问题：">¶</a>现有的问题：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Single global mutex (Sched.Lock) and centralized state. The mutex protects all goroutine-related operations (creation, completion, rescheduling, etc).</span><br><span class="line">2. Goroutine (G) hand-off (G.nextg). Worker threads (M&#x27;s) frequently hand-off runnable goroutines between each other, this may lead to increased latencies and additional overheads. Every M must be able to execute any runnable G, in particular the M that just created the G.</span><br><span class="line">3. Per-M memory cache (M.mcache). Memory cache and other caches (stack alloc) are associated with all M&#x27;s, while they need to be associated only with M&#x27;s running Go code (an M blocked inside of syscall does not need mcache). A ratio between M&#x27;s running Go code and all M&#x27;s can be as high as 1:100. This leads to excessive resource consumption (each MCache can suck up up to 2M) and poor data locality.</span><br><span class="line">4. Aggressive thread blocking/unblocking. In presence of syscalls worker threads are frequently blocked and unblocked. This adds a lot of overhead.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、单一的全局锁和集中的状态.此锁所有g的操作。</span><br><span class="line">2、g退出。工作中的M频繁的交出正在running的g，导致延迟增加和额外的负载。每个M执行任何g，尤其是M自身创建的g。</span><br><span class="line">3、M的内存缓存问题。   内存缓存和其它的缓存关联这所有的M，当他们需要关联M来running code时。比率显示M运行的code和所有M的呈1:100。导致很多资源的浪费和内存的贫瘠。</span><br><span class="line">4、侵略性的加锁，在系统线程频繁的加锁和解锁。这样会造成很大的负载。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="设计改变"><a class="header-anchor" href="#设计改变">¶</a>设计改变</h3>
<blockquote>
<p>以前的设计：<br>
<img data-src="https://raw.githubusercontent.com/crab21/Images/master/GPM-1.png" alt=""></p>
</blockquote>
<blockquote>
<p>新增Processor</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/GPM-2.png" alt=""></p>
<h3 id="实现计划"><a class="header-anchor" href="#实现计划">¶</a>实现计划</h3>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Introduce the P struct (empty for now); implement allp/idlep containers (idlep is mutex-protected for starters); associate a P with M running Go code. Global mutex and atomic state is still preserved.</span><br><span class="line">2. Move G freelist to P.</span><br><span class="line">3. Move mcache to P.</span><br><span class="line">4. Move stackalloc to P.</span><br><span class="line">5. Move ncgocall/gcstats to P.</span><br><span class="line">// work-steal工作窃取模式,仍然在全局锁下。</span><br><span class="line">6. Decentralize run queue, implement work-stealing. Eliminate G hand off. Still under global mutex.</span><br><span class="line"></span><br><span class="line">// 移除全局锁，实现分散的检测。</span><br><span class="line">7. Remove global mutex, implement distributed termination detection, LockOSThread.</span><br><span class="line"></span><br><span class="line">// 实现自旋替代提示锁「普通锁」。</span><br><span class="line">8. Implement spinning instead of prompt blocking/unblocking.</span><br><span class="line">The plan may turn out to not work, there are a lot of unexplored details.</span><br></pre></td></tr></table></figure>
<h3 id="Potential-Improvement"><a class="header-anchor" href="#Potential-Improvement">¶</a>Potential Improvement</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 后进先出计划。提供公平和优雅的处理g。</span><br><span class="line">1. Try out LIFO scheduling, this will improve locality. However, it still must provide some degree of fairness and gracefully handle yielding goroutines.</span><br><span class="line"></span><br><span class="line"># 不分配内存和栈空间，直到g跑起来。对于一个新创建的g，需要下面几个函数。 这将创建to完成伴随着较低内存的负载。</span><br><span class="line">2. Do not allocate G and stack until the goroutine first runs. For a newly created goroutine we need just callerpc, fn, narg, nret and args, that is, about 6 words. This will allow to create a lot of running-to-completion goroutines with significantly lower memory overhead.</span><br><span class="line"></span><br><span class="line"># 更好的G-P。尝试入队未锁定的G到P，从上一次运行。</span><br><span class="line">4. Better locality of G-to-P. Try to enqueue an unblocked G to a P on which it was last running.</span><br><span class="line"></span><br><span class="line"># 更好的P-M。尝试执行p，在同样的M最后一次运行。</span><br><span class="line">5. Better locality of P-to-M. Try to execute P on the same M it was last running.</span><br><span class="line"></span><br><span class="line"># M限流创建。调度器创建上千哥M在毫秒之间，直到OS拒绝创建更多的thread。M必须立刻创建，最多创建k*GOMAXPROCS,后续新的M会通过定时器创建。</span><br><span class="line">6. Throttling of M creation. The scheduler can be easily forced to create thousands of M&#x27;s per second until OS refuses to create more threads. M’s must be created promptly up to k*GOMAXPROCS, after that new M’s may added by a timer.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="参考："><a class="header-anchor" href="#参考：">¶</a>参考：</h3>
<ul>
<li>
<p><a href="https://golang.org/s/go11scheds">GPM g11设计文档</a></p>
</li>
<li>
<p><a href="http://supertech.csail.mit.edu/papers/steal.pdf">work steal模式</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>GPM</tag>
        <tag>Go源码</tag>
      </tags>
  </entry>
  <entry>
    <title>「17」chrome headless「截图/PDF/DOM...」</title>
    <url>/archives/5544baea.html</url>
    <content><![CDATA[<blockquote>
<p>最近在搞一个需求：html「文件」渲染成png/jpg；chrome不能装在服务器中，可以打成docker镜像。<br>
说到这个，很多人肯定说很容易啊，chrome headless有现成的，直接用，它是不香么。<br>
然而事情并没有这么简单；</p>
</blockquote>
<h3 id="难点："><a class="header-anchor" href="#难点：">¶</a>难点：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、服务器中不能装chrome</span><br><span class="line"><span class="number">2</span>、chrome必须打在docker里面</span><br><span class="line"><span class="number">3</span>、渲染效果要和在本地效果一样：图片不能丢失字体，不能失真。</span><br><span class="line"><span class="number">4</span>、不能启动新的服务</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="切入点："><a class="header-anchor" href="#切入点：">¶</a>切入点：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">docker &amp;&amp; chrome</span><br></pre></td></tr></table></figure>
<blockquote>
<p>so先去搜一把有没有现成的可用？</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/20201110-193745.png" alt=""></p>
<p>分析分析吧：</p>
<ul>
<li><a href="https://github.com/browserless/chrome">browserless</a></li>
<li><a href="https://github.com/puppeteer/puppeteer">puppeteer</a></li>
<li><a href="https://github.com/prisma-archive/chromeless">prisma-archive</a><br>
…
<ul>
<li>适合启动服务，然后进行测试或者跑服务</li>
<li>入参数为url</li>
</ul>
</li>
</ul>
<blockquote>
<p>所以上述的基本不符合需求，再寻找…</p>
</blockquote>
<h3 id="Zenika-alpine-chrome"><a class="header-anchor" href="#Zenika-alpine-chrome">¶</a><a href="https://github.com/Zenika/alpine-chrome">Zenika/alpine-chrome</a></h3>
<blockquote>
<p>看起来可行：</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/20201110-194452.png" alt=""></p>
<p>这个经过验证总会有一个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1110/031547.366909:ERROR:bus.cc(393)] Failed to connect to the bus: Failed to connect to socket /var/run/dbus/system_bus_socket: No such file or directory</span><br><span class="line">[1110/031547.367451:WARNING:dns_config_service_posix.cc(342)] Failed to read DnsConfig.</span><br><span class="line">[1110/031547.437879:WARNING:dns_config_service_posix.cc(342)] Failed to read DnsConfig.</span><br><span class="line">[1110/031549.073431:ERROR:headless_shell.cc(591)] Writing to file code/ss.png was unsuccessful, could not open file: FILE_ERROR_ACCESS_DENIED</span><br></pre></td></tr></table></figure>
<p>文件没权限哦，尴尬了,再修正：</p>
<blockquote>
<p>发现源码有一段添加了用户，汗，太搞了.</p>
</blockquote>
<p><a href="https://github.com/Zenika/alpine-chrome/blob/master/Dockerfile#L38">点击查看</a></p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/20201110-194711.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">很郁闷这个chrome用户干嘛的，如果真用这个，那得确定你跑的环境要允许你添加一个user出来，很明显不行,</span><br><span class="line">这样导致整个alpine-chrome服务权限都是乱的「chrome用户的」,最明显的是无法读写文件，因为你这个add chrome没权限。</span><br><span class="line"></span><br><span class="line">最直接的，去掉就好了。</span><br><span class="line"></span><br><span class="line">果然去掉后，跑docker就可以了</span><br></pre></td></tr></table></figure>
<p><a href="https://hub.docker.com/r/zenika/alpine-chrome">docker镜像地址</a></p>
<p>这个是可以了，但是有一个新的问题，图像失真了，再去查github源码，坑那，压根没有装全文字库，只简单装了lib***的库。</p>
<h3 id="再尝试「自己搞个docker-images」"><a class="header-anchor" href="#再尝试「自己搞个docker-images」">¶</a>再尝试「自己搞个docker images」</h3>
<blockquote>
<p>别人都能搞，为何我不可以勒</p>
</blockquote>
<h3 id="分析："><a class="header-anchor" href="#分析：">¶</a>分析：</h3>
<ul>
<li>本地跑这个服务是ok的，那chrome就是依赖macos/linux系统的</li>
<li>那可以搞个linux系统，再装个chrome</li>
<li>最后把字体装完就ok了</li>
<li>最后的最后，想办法直接可以用这个docker，不用启动服务，也就是说docker run之后有了结果，直接rm掉。</li>
</ul>
<h3 id="思路："><a class="header-anchor" href="#思路：">¶</a>思路：</h3>
<ul>
<li>1、搞个docker debain系统</li>
<li>2、想办法把chrome装上</li>
<li>3、在里面跑一个测试，看能否生成图片</li>
<li>4、安装缺失的字体</li>
<li>5、container跑起来</li>
<li>6、导出container，再导入到本地的images；让container变成images</li>
<li>7、自己搞个Dockerfile，把「RUN」接口留出来，方便可以直接跑起来</li>
<li>8、再把搞好的images导出来用就可以了。</li>
</ul>
<h3 id="步骤："><a class="header-anchor" href="#步骤：">¶</a>步骤：</h3>
<h4 id="1"><a class="header-anchor" href="#1">¶</a>1</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull debian</span><br></pre></td></tr></table></figure>
<h4 id="2-3-4-5"><a class="header-anchor" href="#2-3-4-5">¶</a>2/3/4/5</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、进入系统</span><br><span class="line">docker exec -it XXXXX /bin/bash</span><br><span class="line">2、更新源</span><br><span class="line">apt-get update</span><br><span class="line">3、下载wget</span><br><span class="line">apt-get install wget</span><br><span class="line">4、下载chrome linux版本的</span><br><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</span><br><span class="line">5、安装chrome</span><br><span class="line"> dpkg -i ******.deb</span><br><span class="line"> 解决依赖关系：</span><br><span class="line">    apt-get -f install</span><br><span class="line">6、跑一把发现汉字变问好「？」了</span><br><span class="line">7、安装缺失的字体</span><br><span class="line">apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy</span><br></pre></td></tr></table></figure>
<h4 id="6导出container"><a class="header-anchor" href="#6导出container">¶</a>6导出container</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、导出container</span><br><span class="line">docker export container_name &gt; chrome.tar</span><br><span class="line">2、导入到images中</span><br><span class="line">docker load &lt; chrome.tar</span><br></pre></td></tr></table></figure>
<h4 id="7自己搞Dockerfile-预留「RUN」接口"><a class="header-anchor" href="#7自己搞Dockerfile-预留「RUN」接口">¶</a>7自己搞Dockerfile,预留「RUN」接口</h4>
<p>Dockerfile文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#这个是上一步导入的images</span><br><span class="line">FROM gogoowang/chrome:v1</span><br><span class="line">RUN mkdir -p /home</span><br><span class="line">WORKDIR /home</span><br><span class="line">ENTRYPOINT [&quot;chrome&quot;,&quot;--headless&quot;,&quot;--disable-gpu&quot;]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>构建成镜像：docker build -t gogoo/chrome:v2 .</p>
</blockquote>
<p>PS:「/home」的含义就是这个images的工作目录是/home文件夹下面</p>
<h4 id="8跑一把，收工"><a class="header-anchor" href="#8跑一把，收工">¶</a>8跑一把，收工</h4>
<h3 id="注意点："><a class="header-anchor" href="#注意点：">¶</a>注意点：</h3>
<h4 id="PS-1"><a class="header-anchor" href="#PS-1">¶</a>PS-1</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、错误❌</span><br><span class="line">docker container run -it --rm -v /tmp:/home gogoowang/chrome:v1 --no-sandbox --screenshot --hide-scrollbars /XXXX/XXXX.html</span><br><span class="line">2、正确</span><br><span class="line">docker container run -i --rm -v /tmp:/home gogoowang/chrome:v1 --no-sandbox --screenshot=/home/xx.png --hide-scrollbars /XXXX/XXXX.html</span><br><span class="line"></span><br><span class="line">少一个 -t，这个 -t：再搞一个临时的TTy来跑程序，既然是后台跑的，那就没必要了</span><br></pre></td></tr></table></figure>
<h4 id="PS-2"><a class="header-anchor" href="#PS-2">¶</a>PS-2</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker container run -i --rm -v /tmp:/home gogoowang/chrome:v1 --no-sandbox --screenshot=/home/xx.png --hide-scrollbars /XXXX/XXXX.html</span><br><span class="line"></span><br><span class="line">1、关于这个-v的问题,后面就固定了，具体见Dockerfile中</span><br><span class="line">2、--screenshot路径问题，既然是docker镜像，那就得填个docker镜像中的地址，那就是/home下面了</span><br></pre></td></tr></table></figure>
<h3 id="优化后一键脚本"><a class="header-anchor" href="#优化后一键脚本">¶</a>优化后一键脚本</h3>
<p>Dockerfile文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM debian</span><br><span class="line">RUN apt-get update </span><br><span class="line">RUN apt-get install -y wget </span><br><span class="line">RUN wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb </span><br><span class="line">RUN dpkg -i google-chrome-stable_current_amd64.deb || true</span><br><span class="line">RUN apt-get -f -y install</span><br><span class="line">RUN apt-get install -y ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy</span><br><span class="line">RUN mkdir -p /home</span><br><span class="line">WORKDIR /home</span><br><span class="line">ENTRYPOINT [&quot;/opt/google/chrome/chrome&quot;,&quot;--headless&quot;,&quot;--disable-gpu&quot;]</span><br></pre></td></tr></table></figure>
<p>构建：</p>
<blockquote>
<p>docker build -t google-chrome:latest .</p>
</blockquote>
]]></content>
      <tags>
        <tag>Day</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>「16」go源码words归纳</title>
    <url>/archives/425d5e80.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p>好久没有更新了，不是不更新，最近感冒严重，一直没好，太影响身体了…「身体还是很重要的!」</p>
<p>当然了，在生病期间也看了很多东西，更多的思考了许多：人生规划的、如何学习技术、后续的生涯发展之类的。「思考的方式很多种，不建议去生病了才去思考.」</p>
<blockquote>
<p>后续会更新一篇，主要是结合之前的成长和技术的壁垒来说说后续想怎么学，怎么发展，生涯规划吧。</p>
</blockquote>
<p>不扯了，这篇主要想记录一些词汇，主要还是在阅读Go源码中的一些词汇，毕竟英文有点差，再不积累就更差了。</p>
<h3 id="Words"><a class="header-anchor" href="#Words">¶</a>Words</h3>
<h4 id="全称"><a class="header-anchor" href="#全称">¶</a>全称</h4>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">「<span class="number">11</span>/<span class="number">3</span>」</span><br><span class="line">Preempt  v 抢占、掠夺                                   --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">retake   v 重新获取「重新分配」                           --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">syscall  v 系统调用                                     --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">decrement v 递减                                       --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">pretending  v 假装、伪装                                --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">contended  v 竞争                                      --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">procresize  v 扩大                                     --&gt; /proc.<span class="keyword">go</span> </span><br><span class="line">corruption  n 腐败，译：损坏</span><br><span class="line">infinite  adj 无限的  </span><br><span class="line">reproduce v  复制</span><br><span class="line">consists  v 组成</span><br><span class="line">reproducer  v 复制</span><br><span class="line">allocating v 分配</span><br><span class="line">embed   v 嵌入 </span><br><span class="line"></span><br><span class="line">「<span class="number">11</span>/<span class="number">5</span>」</span><br><span class="line">assembly  n  装配                                      --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">amortizes  v  缓冲                                     --&gt; /proc.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">「<span class="number">11</span>/<span class="number">25</span>」</span><br><span class="line">guard  v. 看守																				 --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">Alternatively  或者																		--&gt;  /runtime/rwmutex.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">「later」</span><br><span class="line">demonstrate  v 演示</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">instructions v  指示  ----&gt; (<span class="keyword">go</span> github memory leak)[https:<span class="comment">//github.com/golang/go/issues/40448]</span></span><br><span class="line">reiterate    v  重申</span><br><span class="line">procedure    n 程序</span><br><span class="line">hypothesis   n 假设</span><br></pre></td></tr></table></figure>
<h4 id="简写"><a class="header-anchor" href="#简写">¶</a>简写</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">「<span class="number">11</span>/<span class="number">3</span>」</span><br><span class="line">sysmon -&gt; system monitor 系统监控                                               /proc.<span class="keyword">go</span></span><br><span class="line">incidlelocked  --&gt; increment idle locked   增加空闲锁                           /proc.<span class="keyword">go</span></span><br><span class="line">sysmontick  --&gt; system monitor ticket   系统监控数量                            /proc.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<h3 id="持续更新…"><a class="header-anchor" href="#持续更新…">¶</a>持续更新…</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
      </tags>
  </entry>
  <entry>
    <title>「15」Plan9 汇编小记</title>
    <url>/archives/2ce846ed.html</url>
    <content><![CDATA[<h4 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h4>
<blockquote>
<p>平常coding时，偶尔会查看计算机的具体执行过程，那最基本的就是汇编了，了解汇编是调试过程中必不可少的，尤其是一些细节的处理方面.Go的汇编是Plan 9(贝尔实验室的产物)，和汇编很类似。</p>
</blockquote>
<h4 id="如何得到汇编结果？"><a class="header-anchor" href="#如何得到汇编结果？">¶</a>如何得到汇编结果？</h4>
<ul>
<li>官网文档</li>
<li>Google</li>
</ul>
<h5 id="3种方式："><a class="header-anchor" href="#3种方式：">¶</a>3种方式：</h5>
<blockquote>
<p>第一种</p>
</blockquote>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> tool compile -N -l -S ***.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>第二种</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、先编译：</span><br><span class="line">    <span class="keyword">go</span> tool compile -N -l ***.<span class="keyword">go</span></span><br><span class="line"><span class="number">2</span>、再反编译：</span><br><span class="line">    <span class="keyword">go</span> tool objdump ***.o</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三种</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> build -gcflags -S ***.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<h4 id="常用寄存器"><a class="header-anchor" href="#常用寄存器">¶</a>常用寄存器</h4>
<blockquote>
<p>plan9 指令格式:  指令 源操作数 目标操作数</p>
</blockquote>
<h5 id="AX-BX-CX-DX-BP-SI-SP-IP"><a class="header-anchor" href="#AX-BX-CX-DX-BP-SI-SP-IP">¶</a>AX BX CX DX BP SI SP IP</h5>
<table>
<thead>
<tr>
<th style="text-align:left">寄存器</th>
<th style="text-align:left">16位</th>
<th style="text-align:left">32位</th>
<th style="text-align:left">64位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">累加寄存器</td>
<td style="text-align:left">AX</td>
<td style="text-align:left">EAX</td>
<td style="text-align:left">RAX</td>
</tr>
<tr>
<td style="text-align:left">基址寄存器</td>
<td style="text-align:left">BX</td>
<td style="text-align:left">EBX</td>
<td style="text-align:left">RBX</td>
</tr>
<tr>
<td style="text-align:left">计数寄存器</td>
<td style="text-align:left">CX</td>
<td style="text-align:left">ECX</td>
<td style="text-align:left">RCX</td>
</tr>
<tr>
<td style="text-align:left">数据寄存器</td>
<td style="text-align:left">DX</td>
<td style="text-align:left">EDX</td>
<td style="text-align:left">RDX</td>
</tr>
<tr>
<td style="text-align:left">堆栈基指针</td>
<td style="text-align:left">BP</td>
<td style="text-align:left">EBP</td>
<td style="text-align:left">RBP</td>
</tr>
<tr>
<td style="text-align:left">变址寄存器</td>
<td style="text-align:left">SI</td>
<td style="text-align:left">ESI</td>
<td style="text-align:left">RSI</td>
</tr>
<tr>
<td style="text-align:left">堆栈顶指针</td>
<td style="text-align:left">SP</td>
<td style="text-align:left">ESP</td>
<td style="text-align:left">RSP</td>
</tr>
<tr>
<td style="text-align:left">指令寄存器</td>
<td style="text-align:left">IP</td>
<td style="text-align:left">EIP</td>
<td style="text-align:left">RIP</td>
</tr>
</tbody>
</table>
<h5 id="4个伪寄存器"><a class="header-anchor" href="#4个伪寄存器">¶</a>4个伪寄存器:</h5>
<ul>
<li>FP: 指向栈底位置,一般用来引用函数的输入参数,用于函数参数的访问「frame pointer」</li>
<li>PC: 程序计数器,用于分支与跳转.「program counter」</li>
<li>SB: 函数声明和全局变量.「static base pointer」</li>
<li>SP: 指向当前栈帧的局部变量的开始位置「栈顶位置」,用于局部变量的引用.</li>
</ul>
<p>更新：</p>
<ul>
<li>SB Static base pointer: global symbols. 全局静态基指针，程序地址空间的开始地址。所有用户定义的符号都可以作为偏移量写入伪寄存器 FP（参数和局部变量）和 SB（全局变量）。SB 伪寄存器可以被认为是内存的起始位置 0x0，例如 runtime.newobject(SB) 就是函数 runtime.newobject 位于内存中的地址。</li>
<li>SP Stack pointer: the highest address within the local stack frame. 栈顶，指向当前栈帧的开始位置。使用形如 symbol+offset(SP) 的方式，引用函数的局部变量，例如 a+8(SP) 指相对于 SP，offset 为 +8 的地址，假如 SP 指向 0x000f0, 那么 a+8(SP) 指向 0x000f8。a 是 symbol，变量名称，用于提升代码可读性。</li>
<li>FP Frame pointer: arguments and locals. 类似 SP，实际使用非常少。</li>
<li>PC Program counter: jumps and branches. 存放 CPU 下一个执行指令的位置地址，PC 是一个抽象的概念，在 x86 上，通过 CS 段寄存器和 IP 寄存器共同计算出指令的地址，也就是PC的值。具体使用示例JMP 2(PC) 以当前指令为基础，向后跳转 2 行</li>
<li>TLS thread local storage 存放了当前正在执行的 g 的结构体。例如 0(TLS) 表示 g.stack.lo，8(TLS) 表示 g.stack.hi</li>
</ul>
<h5 id="MOV"><a class="header-anchor" href="#MOV">¶</a>MOV</h5>
<blockquote>
<p>movb（8位）、movw（16位）、movl（32位）、movq（64位）</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MOVSS: 移动单精度浮点数</span><br></pre></td></tr></table></figure>
<h4 id="LEA和MOV"><a class="header-anchor" href="#LEA和MOV">¶</a>LEA和MOV</h4>
<p>LEA：操作地址<br>
MOV：操作数据</p>
<p>例子：<br>
LEAQ 8(SP), SI // argv 把 8(SP)地址放入 SI 寄存器中<br>
MOVQ 0(SP), DI // argc 把0(SP)内容放入 DI 寄存器中</p>
<h4 id="Reference"><a class="header-anchor" href="#Reference">¶</a>Reference</h4>
<ul>
<li><a href="https://blog.thinkhp.site/plan9/#%E6%9F%A5%E7%9C%8B%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95">☞ Plan 9汇编常见</a></li>
<li><a href="https://c9x.me/x86/html/file_module_x86_id_205.html">☞ MOVSS</a></li>
<li><a href="https://www.felixcloutier.com/x86/index.html">☞ Intel汇编指令查询</a></li>
<li><a href="https://plan9.io/sources/contrib/ericvh/go-plan9/src/pkg/runtime/slice.c">☞ Plan9查询</a></li>
<li><a href="http://68k.hax.com/">☞ 指令查询</a></li>
<li><a href="https://9p.io/sys/doc/">☞ plan9 doc</a></li>
</ul>
<h4 id="持续更新…"><a class="header-anchor" href="#持续更新…">¶</a>持续更新…</h4>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>Plan9</tag>
      </tags>
  </entry>
  <entry>
    <title>「14」hexo-安装&amp;插件</title>
    <url>/archives/ae4aba0d.html</url>
    <content><![CDATA[<p>hexo安装及其第三方插件包下载总结，以便后续CI一次到位。</p>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> npm install -g hexo-cli</span><br><span class="line"> npm install hexo-renderer-sass --save</span><br><span class="line"> npm install hexo-generator-searchdb --save</span><br><span class="line"> npm install hexo-generator-sitemap --save</span><br><span class="line"> npm install hexo-generator-baidu-sitemap --save</span><br><span class="line"> npm install request --save</span><br><span class="line"> npm install xml-parser --save</span><br><span class="line"> npm install yamljs --save</span><br><span class="line"> npm install md5 --save</span><br><span class="line"> npm install request --save</span><br><span class="line"> npm install xml-parser --save</span><br><span class="line"> npm install yamljs --save</span><br><span class="line"> npm install cheerio --save</span><br><span class="line"> npm install blueimp-md5 --save</span><br><span class="line"> npm install hexo-abbrlink --save</span><br><span class="line"> npm audit fix</span><br><span class="line"></span><br><span class="line"> npm uninstall hexo-generator-index --save</span><br><span class="line"> npm install hexo-generator-index-pin-top --save</span><br><span class="line"> npm audit fix</span><br><span class="line"> </span><br><span class="line"> npm install hexo-neat --save</span><br><span class="line"> npm audit fix</span><br><span class="line"> npm install --save hexo-admin</span><br><span class="line"> npm audit fix</span><br><span class="line"> npm install hexo-deployer-git --save</span><br><span class="line"> npm audit fix</span><br><span class="line"></span><br><span class="line"> sudo npm install hexo-toc --save</span><br><span class="line"> npm audit fix</span><br><span class="line"></span><br><span class="line"><span class="comment">//猫咪模型</span></span><br><span class="line"> sudo npm install --save hexo-helper-live2d </span><br><span class="line"> npm audit fix</span><br><span class="line"> sudo npm install --save live2d-widget-model-z16</span><br><span class="line"></span><br><span class="line"> <span class="comment">//pdf:</span></span><br><span class="line">npm install --save hexo-pdf</span><br><span class="line">npm audit fix</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>update: 2021-02-05 19:25:42</p>
</blockquote>
<p>hexo next解析插件更换：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked -S</span><br><span class="line"></span><br><span class="line"> npm uninstall hexo-renderer-marked --save</span><br><span class="line"></span><br><span class="line">再安装下面插件：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">npm install --save markdown-it-abbr</span><br><span class="line">npm install --save markdown-it-footnote</span><br><span class="line">npm install --save markdown-it-ins</span><br><span class="line">npm install --save markdown-it-sub</span><br><span class="line">npm install --save markdown-it-sup</span><br><span class="line">npm install --save markdown-it-anchor</span><br><span class="line">npm install --save markdown-it-deflist</span><br><span class="line">npm install --save markdown-it-mark</span><br><span class="line">npm install --save markdown-it-container</span><br><span class="line"></span><br><span class="line">npm install --save markdown-it-emoji</span><br><span class="line">npm install --save markdown-it-attrs</span><br><span class="line">npm install --save markdown-it-task-lists</span><br><span class="line">npm install --save markdown-it<span class="number">-68</span>tygbv </span><br><span class="line"></span><br><span class="line">npm install markdown-it-mathjax --save</span><br><span class="line">npm audit fix</span><br><span class="line">npm i markdown-it-latex2img --save</span><br><span class="line">npm audit fix</span><br><span class="line">npm install markdown-it-texmath</span><br><span class="line">npm audit fix</span><br><span class="line"></span><br><span class="line">最后更新下hexo更目录下的_config.yaml</span><br><span class="line"></span><br><span class="line"># Markdown-it config</span><br><span class="line">## Docs: https:<span class="comment">//github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class="line">markdown:</span><br><span class="line">  render:</span><br><span class="line">    # Enable HTML tags in source</span><br><span class="line">    html: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    # Use <span class="string">&#x27;/&#x27;</span> to <span class="built_in">close</span> single tags (&lt;br /&gt;). This is only <span class="keyword">for</span> full CommonMark compatibility.</span><br><span class="line">    xhtmlOut: <span class="literal">true</span>        </span><br><span class="line"></span><br><span class="line">    # Convert <span class="string">&#x27;\n&#x27;</span> in paragraphs into &lt;br&gt; </span><br><span class="line">    breaks: <span class="literal">true</span>      </span><br><span class="line"></span><br><span class="line">    # CSS language prefix <span class="keyword">for</span> fenced blocks. Can be useful <span class="keyword">for</span> external highlighters.</span><br><span class="line">    langPrefix: <span class="string">&#x27;language-&#x27;</span>  </span><br><span class="line"></span><br><span class="line">    # Autoconvert URL-like text to links </span><br><span class="line">    linkify: <span class="literal">true</span>        </span><br><span class="line"></span><br><span class="line">    # Enable some language-neutral replacement + quotes beautification</span><br><span class="line">    typographer: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    # Double + single quotes replacement pairs, when typographer enabled,</span><br><span class="line">    # and smartquotes on. Could be either a String or an Array.</span><br><span class="line">    #</span><br><span class="line">    # For example, you can use <span class="string">&#x27;«»„“&#x27;</span> <span class="keyword">for</span> Russian, <span class="string">&#x27;„“‚‘&#x27;</span> <span class="keyword">for</span> German,</span><br><span class="line">    # and [<span class="string">&#x27;«\xA0&#x27;</span>, <span class="string">&#x27;\xA0»&#x27;</span>, <span class="string">&#x27;‹\xA0&#x27;</span>, <span class="string">&#x27;\xA0›&#x27;</span>] <span class="keyword">for</span> French (including nbsp).</span><br><span class="line">    quotes: <span class="string">&#x27;“”‘’&#x27;</span></span><br><span class="line"></span><br><span class="line">  # Plugins</span><br><span class="line">  plugins:</span><br><span class="line">    - markdown-it-abbr</span><br><span class="line">    - markdown-it-footnote</span><br><span class="line">    - markdown-it-ins</span><br><span class="line">    - markdown-it-sub</span><br><span class="line">    - markdown-it-sup</span><br><span class="line">    - markdown-it-anchor</span><br><span class="line">    - markdown-it-deflist</span><br><span class="line">    - markdown-it-mark</span><br><span class="line">    - markdown-it-container</span><br><span class="line"></span><br><span class="line">    - markdown-it-emoji</span><br><span class="line">    - markdown-it-named-headings</span><br><span class="line">    - markdown-it-toc</span><br><span class="line">    - markdown-it-attrs</span><br><span class="line">    - name: markdown-it-task-lists</span><br><span class="line">      options:</span><br><span class="line">        enabled: <span class="literal">false</span></span><br><span class="line">        label: <span class="literal">true</span></span><br><span class="line">        labelAfter: <span class="literal">false</span></span><br><span class="line">  </span><br><span class="line">  # Automatic Headline ID<span class="string">&#x27;s</span></span><br><span class="line"><span class="string">  anchors:</span></span><br><span class="line"><span class="string">    # Minimum level for ID creation. (Ex. h2 to h6)</span></span><br><span class="line"><span class="string">    level: 2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # A suffix that is prepended to the number given if the ID is repeated.</span></span><br><span class="line"><span class="string">    collisionSuffix: &#x27;</span>v<span class="string">&#x27;           </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # If `true`, creates an anchor tag with a permalink besides the heading.</span></span><br><span class="line"><span class="string">    permalink: false              </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # Class used for the permalink anchor tag.</span></span><br><span class="line"><span class="string">    permalinkClass: header-anchor </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # The symbol used to make the permalink</span></span><br><span class="line"><span class="string">    permalinkSymbol: ¶</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>hexo gulp兼容es5:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install gulp --save</span><br><span class="line">npm audit fix</span><br><span class="line">npm install gulp-minify-css --save</span><br><span class="line">npm audit fix</span><br><span class="line">npm install gulp-uglify --save</span><br><span class="line">npm audit fix</span><br><span class="line">npm install gulp-htmlmin --save</span><br><span class="line">npm audit fix</span><br><span class="line">npm install gulp-htmlclean --save</span><br><span class="line">npm audit fix</span><br><span class="line">npm install gulp-imagemin --save</span><br><span class="line">npm audit fix</span><br><span class="line"></span><br><span class="line">npm install babel-core@6.26.3 --save</span><br><span class="line">npm install gulp-babel@7.0.1 --save</span><br><span class="line">npm install babel-preset-es2015@6.24.1 --save</span><br><span class="line">npm audit fix</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>next文章加密用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-blog-encrypt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>未完待续…</p>
</blockquote>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>「13」Linux 进程</title>
    <url>/archives/ba455c1d.html</url>
    <content><![CDATA[<p>进程这是个老生常谈的问题，当然我不是那个老生，我只是个loser。</p>
<p>今天用chrome，占用很多的内存和资源，查了查，说chrome是多进程的，于是就想了解下进程一些相关的内容。<br>
主要从以下几个角度了解下进程：</p>
<ul>
<li>来源</li>
<li>定义</li>
<li>特征</li>
<li>多进程如何工作？</li>
<li>通信</li>
</ul>
<span id="more"></span>
<h3 id="来源"><a class="header-anchor" href="#来源">¶</a>来源</h3>
<p>抽象正在运行的程序，或者说是对计算机系统存储器的调度和管理。</p>
<h3 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h3>
<p>进程：并发程序在执行过程中资源分配和管理的最基本的单元（资源分配的最小单元，执行的最小单元）。一个程序一旦开始执行，就是一个进程。每一个进程都有自己的独立空间，系统会分配一定的地址空间和完整的数据段空间。</p>
<p>ps:[线程：程序执行的最小单位。]</p>
<p>组成：程序、数据、控制块组成。</p>
<h3 id="特征"><a class="header-anchor" href="#特征">¶</a>特征</h3>
<ul>
<li>动态性 ： 多个程序执行过程中的一次执行过程，进程是动态产生，动态销毁的。</li>
<li>并发性 ： 任何进程可以和其它进程并发执行。</li>
<li>独立性 ： 是独立运行的基本单元，也是资源分配和调度的独立单元。</li>
<li>异步性 ： 由于进程间的相互制约，进程间是各自独立，各自向前。</li>
</ul>
<h3 id="多进程工作："><a class="header-anchor" href="#多进程工作：">¶</a>多进程工作：</h3>
<h4 id="进程的状态："><a class="header-anchor" href="#进程的状态：">¶</a>进程的状态：</h4>
<blockquote>
<p>3种状态：</p>
</blockquote>
<ul>
<li>就绪</li>
<li>运行</li>
<li>阻塞</li>
</ul>
<h5 id="3态图："><a class="header-anchor" href="#3态图：">¶</a>3态图：</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/linux_process_3.1.png" alt=""></p>
<h5 id="5态图："><a class="header-anchor" href="#5态图：">¶</a>5态图：</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/linux_p3.png" alt=""></p>
<h5 id="7态图："><a class="header-anchor" href="#7态图：">¶</a>7态图：</h5>
<p>新增两种状态：</p>
<ul>
<li>挂起就绪状态：表明进程具备了运行的条件，目前在二级存储器里面。</li>
<li>挂起等待状态：表明进程正在等待某一个事件的结束且目前在二级存储器里面。</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/linux_process_7.png" alt=""></p>
<h3 id="进程间通信"><a class="header-anchor" href="#进程间通信">¶</a>进程间通信</h3>
<h4 id="共享内存"><a class="header-anchor" href="#共享内存">¶</a>共享内存</h4>
<p>映射一段能被其它进程访问的内存，一个进程创建，其它进程可访问。共享内存是最快的IPC方式，往往和信号量一起使用，达到进程间的同步和互斥。</p>
<h4 id="管道"><a class="header-anchor" href="#管道">¶</a>管道</h4>
<p>实质就是一个缓冲区。<br>
管道限制：</p>
<ul>
<li>半双工</li>
<li>只能在亲缘进程间通信</li>
</ul>
<p><strong>特点:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">写满时，不能再写，读空时，不能再读</span><br><span class="line">没写满，不能读，没读空，不能写</span><br></pre></td></tr></table></figure>
<h4 id="消息队列"><a class="header-anchor" href="#消息队列">¶</a>消息队列</h4>
<p>是一种消息的链表，解决了信号传递信息少，管道只能承载无格式字节流及管道大小限制的缺点。</p>
<h4 id="信号"><a class="header-anchor" href="#信号">¶</a>信号</h4>
<p>通知和接受进程某个事件已经发生了的。</p>
<h4 id="信号量"><a class="header-anchor" href="#信号量">¶</a>信号量</h4>
<p>实质上就是个计数器，用来控制多个进程对于共享资源的访问情况。</p>
<h4 id="套接字（Socket）"><a class="header-anchor" href="#套接字（Socket）">¶</a>套接字（Socket）</h4>
<p>进程间通信的一种机制，多用于不同机器进程间的通信。</p>
<h4 id="优缺点："><a class="header-anchor" href="#优缺点：">¶</a>优缺点：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、管道：速度慢，容量有限，只有父子进程能通讯.</span><br><span class="line"><span class="number">2</span>、FIFO：任何进程间都能通讯，但速度慢.</span><br><span class="line"><span class="number">3</span>、消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题.</span><br><span class="line"><span class="number">4</span>、信号量：不能传递复杂消息，只能用来同步.</span><br><span class="line"><span class="number">5</span>、共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存.</span><br></pre></td></tr></table></figure>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>「12」go 指针和引用</title>
    <url>/archives/1191d613.html</url>
    <content><![CDATA[<p>今写代码时，传函数无意间想到一个问题，slice通过参数传递给函数，为何可以改变具体的值呢？</p>
<p>如何解决这个问题？</p>
<ul>
<li>官方查文档</li>
<li>看源码</li>
<li>google看看有没有好的见解</li>
<li>思考🤔+冥想🧘‍♂️</li>
</ul>
<p>（ps:解决问题，主要不是看结果是怎么样的，主要是考虑问题的角度）</p>
<span id="more"></span>
<h3 id="查资料"><a class="header-anchor" href="#查资料">¶</a>查资料</h3>
<p><a href="https://golang.google.cn/doc/effective_go.html#slices">官网指南之Slice</a><br>
有一段是这么描述：<br>
<em>Slices hold references to an underlying array, and if you assign one slice to another, both refer to the same array.</em></p>
<h3 id="查源码"><a class="header-anchor" href="#查源码">¶</a>查源码</h3>
<h4 id="src-runtime-slice-go"><a class="header-anchor" href="#src-runtime-slice-go">¶</a>/src/runtime/slice.go</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer  <span class="comment">//指针类型哦</span></span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思考"><a class="header-anchor" href="#思考">¶</a>思考</h3>
<blockquote>
<p>原来下层是用过array这个指针，指向具体的数据的</p>
</blockquote>
<blockquote>
<p>那么其他的引用类型呢？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map?</span><br><span class="line">chan?</span><br><span class="line">interface?</span><br><span class="line">//Slice?</span><br></pre></td></tr></table></figure>
<h3 id="引用类型之Map"><a class="header-anchor" href="#引用类型之Map">¶</a>引用类型之Map</h3>
<h4 id="看源码-src-runtime-map-go："><a class="header-anchor" href="#看源码-src-runtime-map-go：">¶</a>看源码 /src/runtime/map.go：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.</span></span><br><span class="line">	<span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span></span><br><span class="line">	count     <span class="type">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">	flags     <span class="type">uint8</span></span><br><span class="line">	B         <span class="type">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">	noverflow <span class="type">uint16</span> <span class="comment">// approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line">	hash0     <span class="type">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过此指针类型</span></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用类型之Chan"><a class="header-anchor" href="#引用类型之Chan">¶</a>引用类型之Chan</h3>
<h4 id="源码-src-runtime-chan-go"><a class="header-anchor" href="#源码-src-runtime-chan-go">¶</a>源码:/src/runtime/chan.go</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="type">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">    <span class="comment">//通过此指针类型来处理</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">	elemsize <span class="type">uint16</span></span><br><span class="line">	closed   <span class="type">uint32</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">	<span class="comment">// with stack shrinking.</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用类型之Interface"><a class="header-anchor" href="#引用类型之Interface">¶</a>引用类型之Interface</h3>
<h4 id="源码-src-runtime-runtime2-go"><a class="header-anchor" href="#源码-src-runtime-runtime2-go">¶</a>源码/src/runtime/runtime2.go</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab</span><br><span class="line">    <span class="comment">//指针类型</span></span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    <span class="comment">//指针类型</span></span><br><span class="line">	data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结论？通过指针？"><a class="header-anchor" href="#结论？通过指针？">¶</a>结论？通过指针？</h3>
<p>从上述源码看来，内部结构中都是用指针类型来指向具体的值，</p>
<blockquote>
<p>So：形同这类的结构，肯定是引用类型的，具体是指针指向别的地址，从而来引用值。</p>
</blockquote>
<p>其实这个特性很早就晓得了，只是今天又看到了，觉得还是记录着吧，也许后续哪一天就有了创新的灵感来着~~.</p>
<p>[睡觉了～最近有点乏～ZZzzz…]</p>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go Package</tag>
        <tag>Day</tag>
      </tags>
  </entry>
  <entry>
    <title>「11」hexo 主题&amp;评论&amp;进度条&amp;背景效果</title>
    <url>/archives/e18c94ab.html</url>
    <content><![CDATA[<p>晚上折腾了下博客，稍微装饰了下，主要还是加了个评论吧，其它非常秀的插件就没有接入了，懒得折腾，好好写博客，内容才是精华。<br>
记录下折腾史：</p>
<h3 id="gitalk评论插件"><a class="header-anchor" href="#gitalk评论插件">¶</a>gitalk评论插件</h3>
<h4 id="步骤："><a class="header-anchor" href="#步骤：">¶</a>步骤：</h4>
<h5 id="申请id和secret"><a class="header-anchor" href="#申请id和secret">¶</a>申请id和secret</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/36f31671-8ada-4cbe-b60b-d1595dd701ee.png" alt=""></p>
<span id="more"></span>
<h4 id="配置文件："><a class="header-anchor" href="#配置文件：">¶</a>配置文件：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  github_id: crab21 # GitHub repo owner</span><br><span class="line">  repo: blog # Repository name to store issues</span><br><span class="line">  client_id: XXX # GitHub Application Client ID</span><br><span class="line">  client_secret: XXX # GitHub Application Client Secret</span><br><span class="line">  admin_user: crab21 # GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span><br><span class="line">  distraction_free_mode: true # Facebook-like distraction free mode</span><br><span class="line">  perPage: 15 #每页多少个评论</span><br><span class="line">  pagerDirection: last  #排序方式是从旧到新（first）还是从新到旧（last）</span><br><span class="line">  createIssueManually: true #如果当前页面没有相应的 isssue ，且登录的用户属于 admin，则会自动创建 issue。如果设置为 true，则显示一个初始化页面，创建 issue 需要点击 init 按钮。</span><br><span class="line">  distractionFreeMode: true #是否启用快捷键(cmd|ctrl + enter) 提交评论.</span><br><span class="line"></span><br><span class="line">  # Gitalk&#x27;s display language depends on user&#x27;s browser or system environment</span><br><span class="line">  # If you want everyone visiting your site to see a uniform language, you can set a force language value</span><br><span class="line">  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span><br><span class="line">  language:</span><br></pre></td></tr></table></figure>
<h3 id="pac阅读进度百分比"><a class="header-anchor" href="#pac阅读进度百分比">¶</a>pac阅读进度百分比</h3>
<p>1、github地址： https://github.com/HubSpot/pace，可以看下介绍<br>
2、修改值：<br>
修改主题下面的_config.yml：<br>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pace:</span><br><span class="line">    enable: <span class="literal">true</span></span><br><span class="line">    # Themes list:</span><br><span class="line">    # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span><br><span class="line">    # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span><br><span class="line">    theme: minimal</span><br></pre></td></tr></table></figure></p>
<h3 id="reading-progress"><a class="header-anchor" href="#reading-progress">¶</a>reading_progress</h3>
<p>github地址：https://github.com/theme-next/theme-next-reading-progress</p>
<p>包含使用说明和具体的步骤，就不搬运了，及时调整。</p>
<h3 id="文章字数和阅读时间统计："><a class="header-anchor" href="#文章字数和阅读时间统计：">¶</a>文章字数和阅读时间统计：</h3>
<p>hexo配置文件中修改：<br>
<code>symbols_count_time</code> 为true.</p>
<h3 id="back2top"><a class="header-anchor" href="#back2top">¶</a>back2top</h3>
<p>开启模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: true</span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure>
<h3 id="持续更新…"><a class="header-anchor" href="#持续更新…">¶</a>持续更新…</h3>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>hexo插件</tag>
      </tags>
  </entry>
  <entry>
    <title>「10」go mutex解读</title>
    <url>/archives/ff0d6c2b.html</url>
    <content><![CDATA[<p>上次说到rwmutex读写锁，其实就是加强了锁的粒度，区分读和写时不同的情况，核心思想：写优先于读。<br>
这次来看看mutex，go中的锁是如何实现的，用一张图来概括整个流程：</p>
<span id="more"></span>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/mutex.png" alt=""></p>
<blockquote>
<p>核心思想：饥饿和队列，正常流程都是加入到队列尾部，如果超过一定的时间限制则加入到队列头部。</p>
</blockquote>
<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<blockquote>
<p>开始看代码或者分析之前，先看下文档说明及其相关的资料。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">◯  go version</span><br><span class="line">go version go1.14.9 darwin/amd64</span><br></pre></td></tr></table></figure>
<h3 id="src-sync-mutex-go"><a class="header-anchor" href="#src-sync-mutex-go">¶</a>src/sync/mutex.go</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked      state &amp; mutexLocked 1==加锁  0==未加锁</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	mutexWoken                                      <span class="comment">//state &amp; mutexWoken 1==唤醒  0==未唤醒</span></span><br><span class="line">	mutexStarving                                   <span class="comment">// state &amp; mutexStarving 1==饥饿状态   0==正常状态</span></span><br><span class="line">	mutexWaiterShift = <span class="literal">iota</span>                         <span class="comment">// state &gt;&gt; mutexWaiterShift得到当前的goroutine数量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mutex fairness.</span></span><br><span class="line">	<span class="comment">// 两种模式：正常或饥饿</span></span><br><span class="line">    <span class="comment">// Mutex can be in 2 modes of operations: normal and starvation.</span></span><br><span class="line">    <span class="comment">//  正常模式就是FIFO队列。</span></span><br><span class="line">	<span class="comment">// In normal mode waiters are queued in FIFO order, but a woken up waiter</span></span><br><span class="line">	<span class="comment">// does not own the mutex and competes with new arriving goroutines over</span></span><br><span class="line">	<span class="comment">// the ownership. New arriving goroutines have an advantage -- they are</span></span><br><span class="line">	<span class="comment">// already running on CPU and there can be lots of them, so a woken up</span></span><br><span class="line">	<span class="comment">// waiter has good chances of losing. In such case it is queued at front</span></span><br><span class="line">	<span class="comment">// of the wait queue. If a waiter fails to acquire the mutex for more than 1ms,  //获取锁的时间超过1ms，切换到饥饿模式</span></span><br><span class="line">	<span class="comment">// it switches mutex to the starvation mode.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// In starvation mode ownership of the mutex is directly handed off from        //饥饿模式下锁的所有权直接从解锁goroutine的waiter手中移交到队列的前面。</span></span><br><span class="line">	<span class="comment">// the unlocking goroutine to the waiter at the front of the queue.</span></span><br><span class="line">	<span class="comment">// New arriving goroutines don&#x27;t try to acquire the mutex even if it appears</span></span><br><span class="line">	<span class="comment">// to be unlocked, and don&#x27;t try to spin. Instead they queue themselves at</span></span><br><span class="line">	<span class="comment">// the tail of the wait queue.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If a waiter receives ownership of the mutex and sees that either         //如果一个锁的所有权的等待者是以下两种情况之一的：1、处于队列的最后一个2、等待时间少于1ms，则切换到正常模式</span></span><br><span class="line">	<span class="comment">// (1) it is the last waiter in the queue, or (2) it waited for less than 1 ms,</span></span><br><span class="line">	<span class="comment">// it switches mutex back to normal operation mode.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Normal mode has considerably better performance as a goroutine can acquire</span></span><br><span class="line">	<span class="comment">// a mutex several times in a row even if there are blocked waiters.</span></span><br><span class="line">	<span class="comment">// Starvation mode is important to prevent pathological cases of tail latency.</span></span><br><span class="line">	starvationThresholdNs = <span class="number">1e6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="加锁流程"><a class="header-anchor" href="#加锁流程">¶</a>加锁流程</h3>
<blockquote>
<p>加锁过程图如上图提到的流程。</p>
</blockquote>
<blockquote>
<p>加锁代码具体流程：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line">	<span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">		<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">			race.Acquire(unsafe.Pointer(m))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">	m.lockSlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> lockSlow() &#123;</span><br><span class="line">	<span class="keyword">var</span> waitStartTime <span class="type">int64</span> <span class="comment">//等待时间</span></span><br><span class="line">	starving := <span class="literal">false</span>       <span class="comment">//是否处于饥饿状态</span></span><br><span class="line">	awoke := <span class="literal">false</span>          <span class="comment">//唤醒状态</span></span><br><span class="line">	iter := <span class="number">0</span>               <span class="comment">//自旋次数</span></span><br><span class="line">	old := m.state          <span class="comment">//当前状态copy</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Don&#x27;t spin in starvation mode, ownership is handed off to waiters</span></span><br><span class="line">        <span class="comment">// so we won&#x27;t be able to acquire the mutex anyway.</span></span><br><span class="line">        <span class="comment">//加锁且能够自旋</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">			<span class="comment">// Active spinning makes sense.</span></span><br><span class="line">			<span class="comment">// Try to set mutexWoken flag to inform Unlock</span></span><br><span class="line">            <span class="comment">// to not wake other blocked goroutines.</span></span><br><span class="line">            <span class="comment">//自旋过程发现没有被置woken标识，设置标识，将自己置为唤醒</span></span><br><span class="line">			<span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">				awoke = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			runtime_doSpin()    <span class="comment">//自旋</span></span><br><span class="line">			iter++              </span><br><span class="line">			old = m.state       <span class="comment">//状态重置</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新状态</span></span><br><span class="line">		<span class="built_in">new</span> := old</span><br><span class="line">        <span class="comment">// Don&#x27;t try to acquire starving mutex, new arriving goroutines must queue.</span></span><br><span class="line">        <span class="comment">//非饥饿模式，则置锁</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> |= mutexLocked</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处于饥饿模式下，新来的goroutine进入队列中</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// The current goroutine switches mutex to starvation mode.</span></span><br><span class="line">		<span class="comment">// But if the mutex is currently unlocked, don&#x27;t do the switch.</span></span><br><span class="line">		<span class="comment">// Unlock expects that starving mutex has waiters, which will not</span></span><br><span class="line">        <span class="comment">// be true in this case.</span></span><br><span class="line">        <span class="comment">//切换到饥饿模式下</span></span><br><span class="line">		<span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> |= mutexStarving</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前处于唤醒状态，则重置清除唤醒状态。</span></span><br><span class="line">		<span class="keyword">if</span> awoke &#123;</span><br><span class="line">			<span class="comment">// The goroutine has been woken from sleep,</span></span><br><span class="line">			<span class="comment">// so we need to reset the flag in either case.</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//CAS更新状态。</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">//获取到锁</span></span><br><span class="line">			<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// If we were already waiting before, queue at the front of the queue.</span></span><br><span class="line">            <span class="comment">//等待队列的时间</span></span><br><span class="line">			queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">			<span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">				waitStartTime = runtime_nanotime()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//acquire阻塞队列....</span></span><br><span class="line">            <span class="comment">// 新来的 goroutine, queueLifo=false, 加入到等待队列的尾部，耐心等待</span></span><br><span class="line">            <span class="comment">// 唤醒的 goroutine, queueLifo=true, 加入到等待队列的头部</span></span><br><span class="line">			runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">            old = m.state</span><br><span class="line">            <span class="comment">//处于饥饿模式</span></span><br><span class="line">			<span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// If this goroutine was woken and mutex is in starvation mode,</span></span><br><span class="line">				<span class="comment">// ownership was handed off to us but mutex is in somewhat</span></span><br><span class="line">				<span class="comment">// inconsistent state: mutexLocked is not set and we are still</span></span><br><span class="line">				<span class="comment">// accounted as waiter. Fix that.</span></span><br><span class="line">				<span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">					throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//等待的goroutine-1</span></span><br><span class="line">                delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">                <span class="comment">// 处于队列中最后一个或者请求锁的时间未超过starvationThresholdNs，则回退到正常模式。</span></span><br><span class="line">				<span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">					<span class="comment">// Exit starvation mode.</span></span><br><span class="line">					<span class="comment">// Critical to do it here and consider wait time.</span></span><br><span class="line">					<span class="comment">// Starvation mode is so inefficient, that two goroutines</span></span><br><span class="line">					<span class="comment">// can go lock-step infinitely once they switch mutex</span></span><br><span class="line">					<span class="comment">// to starvation mode.</span></span><br><span class="line">					delta -= mutexStarving</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新状态</span></span><br><span class="line">				atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重置迭代器和唤醒表示，继续获取锁</span></span><br><span class="line">			awoke = <span class="literal">true</span></span><br><span class="line">			iter = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//CAS失败，则更新状态，继续获取。</span></span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Acquire(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="解锁过程"><a class="header-anchor" href="#解锁过程">¶</a>解锁过程</h3>
<p>用一个流程图来表示解锁过程：</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/mutex-unlock.png" alt=""></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="comment">//state 不是处于锁的状态, 那么就是 Unlock 根本没有加锁的 mutex, panic</span></span><br><span class="line">    <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁，并通知其它等待者</span></span><br><span class="line">    <span class="comment">// 锁如果处于饥饿状态，直接交给等待队列的第一个, 唤醒它，让它去获取锁</span></span><br><span class="line">    <span class="comment">// mutex 正常模式</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">        old := <span class="built_in">new</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有等待者，或者已经存在一个 goroutine 被唤醒或得到锁、或处于饥饿模式</span></span><br><span class="line">            <span class="comment">// 直接返回.</span></span><br><span class="line">            <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将等待的 goroutine-1，并设置 woken 标识</span></span><br><span class="line">            <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">            <span class="comment">// 设置新的 state, 这里通过信号量会唤醒一个阻塞的 goroutine 去获取锁.</span></span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">                runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// mutex 饥饿模式，直接将 mutex 拥有权移交给等待队列最前端的 goroutine</span></span><br><span class="line">        <span class="comment">// 注意此时 state 的 mutex 还没有加锁，唤醒的 goroutine 会设置它。</span></span><br><span class="line">        <span class="comment">// 在此期间，如果有新的 goroutine 来请求锁， 因为 mutex 处于饥饿状态， mutex 还是被认为处于锁状态，</span></span><br><span class="line">        <span class="comment">// 新来的 goroutine 不会把锁抢过去.</span></span><br><span class="line">        runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="关键点"><a class="header-anchor" href="#关键点">¶</a>关键点</h3>
<ul>
<li>不要重复锁定互斥锁</li>
<li>不要忘记解锁互斥锁</li>
<li>不要在多个函数之间直接传递互斥锁</li>
</ul>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go源码</tag>
        <tag>Go Package</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>「9」Go reflect ~ DeepEqual</title>
    <url>/archives/e2e7cc4e.html</url>
    <content><![CDATA[<p>今天无意中看到Go101发了一个推特:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  fmt.Print(<span class="string">&quot;:&quot;</span>, reflect.DeepEqual(a, b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := [<span class="number">1</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;&#125;&#125;</span><br><span class="line">  p(a, a)</span><br><span class="line">  p(a[:], a[:])</span><br><span class="line">  b := a</span><br><span class="line">  p(a[:], b[:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果？？ :true:true:false</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>正确答案 :false:true:false</p>
</blockquote>
<h3 id="错误来源"><a class="header-anchor" href="#错误来源">¶</a>错误来源</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一个为啥想着为true,第一眼看过去，比较两个a的函数，那两个函数肯定是相等的，这是第一直觉(狗屁直觉).</span><br><span class="line">第二个两个都为nil了，这个是没有什么问题，两个nil肯定是deep相等的。</span><br><span class="line">第三个虽然是重新初始化了，所以两个肯定不是deep相等的。</span><br></pre></td></tr></table></figure>
<h3 id="思路比对（错在哪里）"><a class="header-anchor" href="#思路比对（错在哪里）">¶</a>思路比对（错在哪里）</h3>
<p>查阅文档之后，发现理解错了：</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/20200918-124746.png" alt=""></p>
<h3 id="DeepEqual正确理解"><a class="header-anchor" href="#DeepEqual正确理解">¶</a>DeepEqual正确理解</h3>
<blockquote>
<p>源码也很简洁：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeepEqual</span><span class="params">(x, y <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="comment">//同nil</span></span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> || y == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x == y</span><br><span class="line">	&#125;</span><br><span class="line">	v1 := ValueOf(x)</span><br><span class="line">  v2 := ValueOf(y)</span><br><span class="line">  <span class="comment">//属于同一类型</span></span><br><span class="line">	<span class="keyword">if</span> v1.Type() != v2.Type() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> deepValueEqual(v1, v2, <span class="built_in">make</span>(<span class="keyword">map</span>[visit]<span class="type">bool</span>), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了上面看源码，主要还是要看官方的文档和说明性的，这个算是理解源码的前提把：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DeepEqual reports whether x and y are ``deeply equal,&#x27;&#x27; defined as follows.</span></span><br><span class="line"><span class="comment">// Two values of identical type are deeply equal if one of the following cases applies.</span></span><br><span class="line"><span class="comment">// Values of distinct types are never deeply equal.</span></span><br><span class="line"><span class="comment">//  条件：数组深度相等，相应的元素都是相等的。</span></span><br><span class="line"><span class="comment">// Array values are deeply equal when their corresponding elements are deeply equal.</span></span><br><span class="line"><span class="comment">//  条件：结构体相对应的字段都是相等的。</span></span><br><span class="line"><span class="comment">// Struct values are deeply equal if their corresponding fields,</span></span><br><span class="line"><span class="comment">// both exported and unexported, are deeply equal.</span></span><br><span class="line"><span class="comment">// 条件：函数都是nil，则为深度相等，其它情况下都是不相等的。</span></span><br><span class="line"><span class="comment">// Func values are deeply equal if both are nil; otherwise they are not deeply equal.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 条件：两个interface持有深度相同的值。</span></span><br><span class="line"><span class="comment">// Interface values are deeply equal if they hold deeply equal concrete values.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    条件：下面条件为<span class="literal">true</span>，则深度相等：</span><br><span class="line">    两个全是<span class="literal">nil</span>，或者全non-<span class="literal">nil</span>，有相同的长度并且有相同的对象/key对应的值是相等的。</span><br><span class="line"><span class="comment">// Map values are deeply equal when all of the following are true:</span></span><br><span class="line"><span class="comment">// they are both nil or both non-nil, they have the same length,</span></span><br><span class="line"><span class="comment">// and either they are the same map object or their corresponding keys</span></span><br><span class="line"><span class="comment">// (matched using Go equality) map to deeply equal values.</span></span><br><span class="line">    条件：用 == 比较或者 point的</span><br><span class="line"><span class="comment">// Pointer values are deeply equal if they are equal using Go&#x27;s == operator</span></span><br><span class="line"><span class="comment">// or if they point to deeply equal values.</span></span><br><span class="line">    条件：下面条件为<span class="literal">true</span>，则深度相等：</span><br><span class="line">    两个全是<span class="literal">nil</span>，或者全non-<span class="literal">nil</span>，有相同的长度，指向相同的初始化节点（即：相同的数组）或相同的元素深度相等。</span><br><span class="line">    注意：empty和<span class="literal">nil</span> slice不是深度相等的。</span><br><span class="line"><span class="comment">// Slice values are deeply equal when all of the following are true:</span></span><br><span class="line"><span class="comment">// they are both nil or both non-nil, they have the same length,</span></span><br><span class="line"><span class="comment">// and either they point to the same initial entry of the same underlying array</span></span><br><span class="line"><span class="comment">// (that is, &amp;x[0] == &amp;y[0]) or their corresponding elements (up to length) are deeply equal.</span></span><br><span class="line"><span class="comment">// Note that a non-nil empty slice and a nil slice (for example, []byte&#123;&#125; and []byte(nil))</span></span><br><span class="line"><span class="comment">// are not deeply equal.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Other values - numbers, bools, strings, and channels - are deeply equal</span></span><br><span class="line"><span class="comment">// if they are equal using Go&#x27;s == operator.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In general DeepEqual is a recursive relaxation of Go&#x27;s == operator.</span></span><br><span class="line"><span class="comment">// However, this idea is impossible to implement without some inconsistency.</span></span><br><span class="line"><span class="comment">// Specifically, it is possible for a value to be unequal to itself,</span></span><br><span class="line"><span class="comment">// either because it is of func type (uncomparable in general)</span></span><br><span class="line"><span class="comment">// or because it is a floating-point NaN value (not equal to itself in floating-point comparison),</span></span><br><span class="line"><span class="comment">// or because it is an array, struct, or interface containing</span></span><br><span class="line"><span class="comment">// such a value.</span></span><br><span class="line"><span class="comment">// On the other hand, pointer values are always equal to themselves,</span></span><br><span class="line"><span class="comment">// even if they point at or contain such problematic values,</span></span><br><span class="line"><span class="comment">// because they compare equal using Go&#x27;s == operator, and that</span></span><br><span class="line"><span class="comment">// is a sufficient condition to be deeply equal, regardless of content.</span></span><br><span class="line"><span class="comment">// DeepEqual has been defined so that the same short-cut applies</span></span><br><span class="line"><span class="comment">// to slices and maps: if x and y are the same slice or the same map,</span></span><br><span class="line"><span class="comment">// they are deeply equal regardless of content.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// As DeepEqual traverses the data values it may find a cycle. The</span></span><br><span class="line"><span class="comment">// second and subsequent times that DeepEqual compares two pointer</span></span><br><span class="line"><span class="comment">// values that have been compared before, it treats the values as</span></span><br><span class="line"><span class="comment">// equal rather than examining the values to which they point.</span></span><br><span class="line"><span class="comment">// This ensures that DeepEqual terminates.</span></span><br></pre></td></tr></table></figure>
<p>再看看详细的deepValueEqual,大致的过程：<br>
<img data-src="https://raw.githubusercontent.com/crab21/Images/master/20200920-103516@2x.png" alt=""></p>
<blockquote>
<p>大致分为三个过程：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、判断类型和值</span><br><span class="line">2、hard回调</span><br><span class="line">3、按照kind分类处理</span><br></pre></td></tr></table></figure>
<h4 id="数组："><a class="header-anchor" href="#数组：">¶</a>数组：</h4>
<p>比较每一个元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v1.Len(); i++ &#123;</span><br><span class="line">	<span class="keyword">if</span> !deepValueEqual(v1.Index(i), v2.Index(i), visited, depth+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="Slice"><a class="header-anchor" href="#Slice">¶</a>Slice</h4>
<ul>
<li>比较为nil</li>
<li>比较长度</li>
<li>比较地址</li>
<li>比较每一个元素</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> v1.IsNil() != v2.IsNil() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v1.Len() != v2.Len() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v1.Pointer() == v2.Pointer() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v1.Len(); i++ &#123;</span><br><span class="line">	<span class="keyword">if</span> !deepValueEqual(v1.Index(i), v2.Index(i), visited, depth+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="Interface"><a class="header-anchor" href="#Interface">¶</a>Interface</h4>
<ul>
<li>比较nil</li>
<li>递归比较</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> v1.IsNil() || v2.IsNil() &#123;</span><br><span class="line">	<span class="keyword">return</span> v1.IsNil() == v2.IsNil()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> deepValueEqual(v1.Elem(), v2.Elem(), visited, depth+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Ptr"><a class="header-anchor" href="#Ptr">¶</a>Ptr</h4>
<ul>
<li>地址</li>
<li>递归比较</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> v1.Pointer() == v2.Pointer() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> deepValueEqual(v1.Elem(), v2.Elem(), visited, depth+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="struct"><a class="header-anchor" href="#struct">¶</a>struct</h4>
<ul>
<li>比较每一个元素</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> i, n := <span class="number">0</span>, v1.NumField(); i &lt; n; i++ &#123;</span><br><span class="line">	<span class="keyword">if</span> !deepValueEqual(v1.Field(i), v2.Field(i), visited, depth+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="Map"><a class="header-anchor" href="#Map">¶</a>Map</h4>
<ul>
<li>比较Nil</li>
<li>比较长度</li>
<li>地址比较</li>
<li>每一个key对应的value</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> v1.IsNil() != v2.IsNil() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v1.Len() != v2.Len() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v1.Pointer() == v2.Pointer() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> v1.MapKeys() &#123;</span><br><span class="line">	val1 := v1.MapIndex(k)</span><br><span class="line">	val2 := v2.MapIndex(k)</span><br><span class="line">	<span class="keyword">if</span> !val1.IsValid() || !val2.IsValid() || !deepValueEqual(val1, val2, visited, depth+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="Func"><a class="header-anchor" href="#Func">¶</a>Func</h4>
<ul>
<li>非nil，为不等。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> v1.IsNil() &amp;&amp; v2.IsNil() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Can&#x27;t do better than this:</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="painc注意点："><a class="header-anchor" href="#painc注意点：">¶</a>painc注意点：</h3>
<p>deepValueEqual函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> .....</span><br><span class="line"> ....</span><br><span class="line"> ...</span><br><span class="line"> ..</span><br><span class="line"> .</span><br><span class="line"> 递归次数超过<span class="number">10</span>次则会painc....</span><br><span class="line"> <span class="comment">// if depth &gt; 10 &#123; panic(&quot;deepValueEqual&quot;) &#125;	// for debugging</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We want to avoid putting more in the visited map than we need to.</span></span><br><span class="line"><span class="comment">// For any possible reference cycle that might be encountered,</span></span><br><span class="line"><span class="comment">// hard(v1, v2) needs to return true for at least one of the types in the cycle,</span></span><br><span class="line"><span class="comment">// and it&#x27;s safe and valid to get Value&#x27;s internal pointer.</span></span><br><span class="line">hard := <span class="function"><span class="keyword">func</span><span class="params">(v1, v2 Value)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> v1.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> Map, Slice, Ptr, Interface:</span><br><span class="line">		<span class="comment">// Nil pointers cannot be cyclic. Avoid putting them in the visited map.</span></span><br><span class="line">		<span class="keyword">return</span> !v1.IsNil() &amp;&amp; !v2.IsNil()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"> &#125;</span><br><span class="line"> .</span><br><span class="line"> ..</span><br><span class="line"> ...</span><br><span class="line"> ....</span><br><span class="line"> .....</span><br><span class="line"> ......</span><br></pre></td></tr></table></figure>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go Package</tag>
        <tag>Day</tag>
        <tag>Go reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>「8」go rwmutex解读</title>
    <url>/archives/3038b6c3.html</url>
    <content><![CDATA[<pre><code>好久没有更新文章了，表达能力生疏了许多😄....
今天扯扯:rwmutex 被称为读写锁。一说到【锁】最直接的联想可能就是lock()、Rlock()、unlock()、Runlock()之类的，但是作为程序猿，还是要了解下底层的设计和相关的逻辑实现，以便于把这种锁的设计思想应用到其它场景中，好了，不废话了，开题吧。
从锁的结构设计--&gt;加锁的过程---&gt;加锁的粒度----&gt;解锁释放，整个生命周期来看rwmutex的具体实现。
</code></pre>
<span id="more"></span>
<h3 id="版本"><a class="header-anchor" href="#版本">¶</a>版本</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">◯  go version</span><br><span class="line">go version go1.14.9 darwin/amd64</span><br></pre></td></tr></table></figure>
<h3 id="同向对比rwmutex锁的设计"><a class="header-anchor" href="#同向对比rwmutex锁的设计">¶</a>同向对比rwmutex锁的设计</h3>
<pre><code>java实现：AQS(AbstractQueuedSynchronizer)
</code></pre>
<h3 id="结构设计"><a class="header-anchor" href="#结构设计">¶</a>结构设计</h3>
<blockquote>
<p>原则：读写互斥，优先写。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	w           Mutex  <span class="comment">// held if there are pending writers</span></span><br><span class="line">	writerSem   <span class="type">uint32</span> <span class="comment">// semaphore for writers to wait for completing readers  写信号量</span></span><br><span class="line">	readerSem   <span class="type">uint32</span> <span class="comment">// semaphore for readers to wait for completing writers  读信号量</span></span><br><span class="line">	readerCount <span class="type">int32</span>  <span class="comment">// number of pending readers 读计数</span></span><br><span class="line">	readerWait  <span class="type">int32</span>  <span class="comment">// number of departing readers   读等待（write进行）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span>   <span class="comment">//最大读锁的个数</span></span><br></pre></td></tr></table></figure>
<p>其它再分类就是四个主要的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RLock</span><br><span class="line">RUnLock</span><br><span class="line">Lock</span><br><span class="line">UnLock</span><br></pre></td></tr></table></figure>
<h3 id="加锁过程"><a class="header-anchor" href="#加锁过程">¶</a>加锁过程</h3>
<h4 id="RLock过程"><a class="header-anchor" href="#RLock过程">¶</a>RLock过程</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Disable()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果写锁被获取的，则readerCount&lt;0的，阻塞状态</span></span><br><span class="line">    <span class="comment">//如果写锁没有被获取，则readerCount &gt;0的，获取读锁，不阻塞</span></span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// A writer is pending, wait for it. </span></span><br><span class="line">        <span class="comment">//写锁被获取了，加到G队列后面，挂起。</span></span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Lock过程"><a class="header-anchor" href="#Lock过程">¶</a>Lock过程</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lock locks rw for writing.</span></span><br><span class="line"><span class="comment">// If the lock is already locked for reading or writing,</span></span><br><span class="line"><span class="comment">// Lock blocks until the lock is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// First, resolve competition with other writers.</span></span><br><span class="line">    <span class="comment">//使用mutex锁</span></span><br><span class="line">	rw.w.Lock()</span><br><span class="line">	<span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">	<span class="comment">// Wait for active readers.</span></span><br><span class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//等待活跃的reader结束后，再给一个写的信号量，保证此刻之后的reader挂起。</span></span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加锁的粒度"><a class="header-anchor" href="#加锁的粒度">¶</a>加锁的粒度</h3>
<blockquote>
<p>读 &amp; 写 互不干扰.</p>
</blockquote>
<h3 id="解锁释放"><a class="header-anchor" href="#解锁释放">¶</a>解锁释放</h3>
<h4 id="RUnLock"><a class="header-anchor" href="#RUnLock">¶</a>RUnLock</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">		race.Disable()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写锁等待状态，检查当前是否可以进行获取</span></span><br><span class="line">	<span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Outlined slow-path to allow the fast-path to be inlined</span></span><br><span class="line">		rw.rUnlockSlow(r)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// r + 1 == 0表示直接执行RUnlock()</span></span><br><span class="line">	<span class="comment">// r + 1 == -rwmutexMaxReaders表示执行Lock()再执行RUnlock()</span></span><br><span class="line">	<span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		throw(<span class="string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// A writer is pending.</span></span><br><span class="line">    <span class="comment">// 当读锁释放完毕后，通知写锁</span></span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// The last reader unblocks the writer.</span></span><br><span class="line">		runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="UnLock"><a class="header-anchor" href="#UnLock">¶</a>UnLock</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Release(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Announce to readers there is no active writer.</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">    <span class="comment">//说明这个没有枷锁，没法再次释放</span></span><br><span class="line">	<span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		throw(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// Unblock blocked readers, if any.</span></span><br><span class="line">    <span class="comment">//释放所有的锁。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ &#123;</span><br><span class="line">		runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Allow other writers to proceed.</span></span><br><span class="line">	rw.w.Unlock()</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3>
<blockquote>
<p>读&amp;写，互不干扰。</p>
</blockquote>
<ul>
<li>
<p>读锁不能阻塞读锁，引入readerCount.</p>
</li>
<li>
<p>读锁需要阻塞写锁，直到所以读锁都释放，引入readerSem.</p>
</li>
<li>
<p>写锁需要阻塞读锁，直到所以写锁都释放，引入wirterSem.</p>
</li>
<li>
<p>写锁需要阻塞写锁，引入Metux.</p>
</li>
</ul>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go源码</tag>
        <tag>Go Package</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>「7」Go Context包使用</title>
    <url>/archives/410dfaec.html</url>
    <content><![CDATA[<h3 id="版本"><a class="header-anchor" href="#版本">¶</a>版本</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">◯  go version</span><br><span class="line">go version go1.14.9 darwin/amd64</span><br></pre></td></tr></table></figure>
<h3 id="用Go的都离不开Context，引用官网的一句话来描述Context包："><a class="header-anchor" href="#用Go的都离不开Context，引用官网的一句话来描述Context包：">¶</a>用Go的都离不开Context，引用官网的一句话来描述Context包：</h3>
<blockquote>
<p>Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.</p>
</blockquote>
<p>主要掌握四个方法的使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WithCancel</span><br><span class="line">WithDeadline</span><br><span class="line">WithTimeout</span><br><span class="line">WithValue</span><br></pre></td></tr></table></figure>
<h3 id="前期ready"><a class="header-anchor" href="#前期ready">¶</a>前期ready</h3>
<p>要用下面的方法，先了解下部分结构和逻辑：</p>
<blockquote>
<p>既然context全部都是和取消相关的，最起码Go在设计时会有这么一个结构。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>具体的取消设计结构</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type cancelCtx struct &#123;</span><br><span class="line">	Context</span><br><span class="line"></span><br><span class="line">	mu       sync.Mutex            // protects following fields  加锁用</span><br><span class="line">	done     chan struct&#123;&#125;         // created lazily, closed by first cancel call   控制channel</span><br><span class="line">	children map[canceler]struct&#123;&#125; // set to nil by the first cancel call  cancel函数调用后，释放子类</span><br><span class="line">	err      error                 // set to non-nil by the first cancel call</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>timer控制死锁时间结构：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// A timerCtx carries a timer and a deadline. It embeds a cancelCtx to</span><br><span class="line">// implement Done and Err. It implements cancel by stopping its timer then</span><br><span class="line">// delegating to cancelCtx.cancel.</span><br><span class="line"></span><br><span class="line">type timerCtx struct &#123;</span><br><span class="line">	cancelCtx  </span><br><span class="line">	timer *time.Timer // Under cancelCtx.mu.</span><br><span class="line"></span><br><span class="line">	deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WithCancel"><a class="header-anchor" href="#WithCancel">¶</a>WithCancel</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">    if parent == nil &#123;  //日常判空</span><br><span class="line">		panic(&quot;cannot create context from nil parent&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	c := newCancelCtx(parent) //cancelCtx new</span><br><span class="line">	propagateCancel(parent, &amp;c)  //循环传播取消函数for ctx</span><br><span class="line">	return &amp;c, func() &#123; c.cancel(true, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看似很简单，四行解决，但是更重要的是学会看注释说明和相关的设计思路：<br>
TODO</p>
</blockquote>
<p>引用官方的语言：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// WithCancel returns a copy of parent with a new Done channel. The returned</span><br><span class="line">// context&#x27;s Done channel is closed when the returned cancel function is called</span><br><span class="line">// or when the parent context&#x27;s Done channel is closed, whichever happens first.</span><br><span class="line">//</span><br><span class="line">// Canceling this context releases resources associated with it, so code should</span><br><span class="line">// call cancel as soon as the operations running in this Context complete.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Withcancel 返回的是一个parent的镜像/复制，伴随一个Done channel通道。</span><br><span class="line">Done关闭状态取决于</span><br><span class="line">1、返回的cancel函数。</span><br><span class="line">2、parent的Done Channel关闭。</span><br><span class="line">这两个哪个先符合条件了。</span><br></pre></td></tr></table></figure>
<h3 id="WithDeadline-WithTimeout"><a class="header-anchor" href="#WithDeadline-WithTimeout">¶</a>WithDeadline/WithTimeout</h3>
<p>自己梳理的逻辑执行顺序：</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/20200907-152032.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Deadline/WithTimeout区别：</span><br><span class="line"></span><br><span class="line">* deadline:的入参是一个具体的截止时间：Time.time</span><br><span class="line">* withTimeout:入参是一个多少时间后超时：Time.Duration</span><br></pre></td></tr></table></figure>
<h3 id="WithValue"><a class="header-anchor" href="#WithValue">¶</a>WithValue</h3>
<blockquote>
<p>Withvalue和value是成对出现的:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、给ctx设置k,v：withvalue(ctx,k,v)</span><br><span class="line">2、获取ctx中k的值value(ctx,k)</span><br></pre></td></tr></table></figure>
<h3 id="TODO"><a class="header-anchor" href="#TODO">¶</a>TODO</h3>
<h4 id="timerCtx详细的设计思路和结构文档"><a class="header-anchor" href="#timerCtx详细的设计思路和结构文档">¶</a>timerCtx详细的设计思路和结构文档</h4>
<h4 id="框架图整理"><a class="header-anchor" href="#框架图整理">¶</a>框架图整理</h4>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go Package</tag>
      </tags>
  </entry>
  <entry>
    <title>「6」git 初阶:安装配置 ～1</title>
    <url>/archives/bddc30f6.html</url>
    <content><![CDATA[<blockquote>
<p>自盘古开天辟地～～～～<br>
扯远了…<br>
完整的分享下Git的使用和学习的知识点，之前章节中的<a href="http://blog.imrcrab.com/2020/09/01/Git%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">Git常用技巧</a>是我之前部分快速使用的场景，适合于有经验的开发者，现在来系统的分享下对于Git的理解，也算是自己学习的记录。</p>
</blockquote>
<h2 id="前景"><a class="header-anchor" href="#前景">¶</a>前景</h2>
<p>SVN估计是家喻户晓了，一直被用作<code>'版本管理'</code>和<code>代码仓库</code>。（ps:不算是完整的<code>版本管理</code>.）<br>
Git的出现，是linus之父休假时产出的“作品”,<code>版本管理</code> &amp; <code>代码仓库</code>的作用。总而言之，用熟练Git了，就再也回不去了。</p>
<span id="more"></span>
<h2 id="目标："><a class="header-anchor" href="#目标：">¶</a>目标：</h2>
<blockquote>
<p>最终可以顺利的提交代码即可。</p>
</blockquote>
<h2 id="此篇只分享两个知识点："><a class="header-anchor" href="#此篇只分享两个知识点：">¶</a>此篇只分享两个知识点：</h2>
<blockquote>
<p>安装Git和Git基本配置</p>
</blockquote>
<h3 id="Git安装"><a class="header-anchor" href="#Git安装">¶</a>Git安装</h3>
<p>说安装其实就是去官网下载软件，安装到你选定地方即可。</p>
<p>在此附上官网的下载链接： <a href="https://git-scm.com/download/">点击进入</a></p>
<p>选择对应平台windows?linux?macos?</p>
<p>ps:别选错了，那就very尴尬了。</p>
<h3 id="基本配置"><a class="header-anchor" href="#基本配置">¶</a>基本配置</h3>
<p>说到基本配置，大多数都会有，更何况是如此强大的版本控制软件。</p>
<h4 id="前期基本配置"><a class="header-anchor" href="#前期基本配置">¶</a>前期基本配置</h4>
<p>主要分三个地方：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、/etc/gitconfig 文件: 系统上每一个用户及其他们的仓库配置文件。</span><br><span class="line">2、~/.gitconfig 或 ~/.config/git/config 文件： 只针对当前用户生效。 [global配置]</span><br><span class="line">3、当前使用仓库的Git配置： .git/config文件，仅仅对当前仓库配置生效。    [local配置]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ps: 优先机制：3 &gt; 2 &gt; 1  [.git/config覆盖~/.gitconfig、  ~/.gitconfig覆盖/etc/gitconfig]</p>
</blockquote>
<h5 id="注意："><a class="header-anchor" href="#注意：">¶</a>注意：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">windows下的~/.gitconfig路径为：C:\Users\$USER下；$USER指当前电脑用户名称</span><br></pre></td></tr></table></figure>
<h5 id="查看所有配置命令"><a class="header-anchor" href="#查看所有配置命令">¶</a>查看所有配置命令</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --list --show-origin</span><br></pre></td></tr></table></figure>
<h4 id="生成密钥-关联Github-Gitlab"><a class="header-anchor" href="#生成密钥-关联Github-Gitlab">¶</a>生成密钥&amp;关联Github/Gitlab</h4>
<h5 id="生成密钥"><a class="header-anchor" href="#生成密钥">¶</a>生成密钥</h5>
<blockquote>
<p>根据邮箱，会要求输入密码，连续3个回车即可。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;这里换上你的邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>最后得到id_rsa和id_rsa.pub两个文件。</p>
<p>这里用到的是你的 公钥<code>id_rsa.pub</code>文件，复制文件里面的内容到github密钥的界面：</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/20200902075825.png" alt=""></p>
<p>添加SSH完了之后，就绑定了你本机器和github的关联关系，相当于授权成功。</p>
<h5 id="拓展"><a class="header-anchor" href="#拓展">¶</a>拓展</h5>
<blockquote>
<p>上述生成密钥时也可以自定义文件名称.此种情况针对你有多个github账号时，提交公钥文件时，找出自定义名称的文件即可。（下图自定义生成文件名称pywang112,则公钥为pywang112.pub，看好你生成的路径哦）</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/20200902080130.png" alt=""></p>
<h4 id="global配置（全局配置）或-local配置（当前仓库配置）"><a class="header-anchor" href="#global配置（全局配置）或-local配置（当前仓库配置）">¶</a>global配置（全局配置）或 local配置（当前仓库配置）</h4>
<h5 id="global配置（针对你只有一个git账户的情况）"><a class="header-anchor" href="#global配置（针对你只有一个git账户的情况）">¶</a>global配置（针对你只有一个git账户的情况）</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看命令：</span><br><span class="line">git config --global --list</span><br><span class="line"></span><br><span class="line">全局配置：</span><br><span class="line"></span><br><span class="line">git config --global user.name &quot;crab&quot;</span><br><span class="line">git config --global user.email &quot;imrcrab@163.com&quot;</span><br><span class="line"></span><br><span class="line">代理配置（按需可选）</span><br><span class="line"># http</span><br><span class="line">git config --global https.proxy http://127.0.0.1:1080 </span><br><span class="line"># sock</span><br><span class="line">git config --global http.proxy &#x27;socks5://127.0.0.1:1080&#x27; </span><br><span class="line"></span><br><span class="line">取消代理：</span><br><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure>
<h5 id="local配置-建议本地仓库配置，这样比较灵活"><a class="header-anchor" href="#local配置-建议本地仓库配置，这样比较灵活">¶</a>local配置 (建议本地仓库配置，这样比较灵活)</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看命令：</span><br><span class="line">git config --local --list</span><br><span class="line"></span><br><span class="line">全局配置：</span><br><span class="line"></span><br><span class="line">git config --local user.name &quot;crab&quot;</span><br><span class="line">git config --local user.email &quot;imrcrab@163.com&quot;</span><br><span class="line"></span><br><span class="line">代理配置（按需可选）</span><br><span class="line"># http</span><br><span class="line">git config --local https.proxy http://127.0.0.1:1080 </span><br><span class="line"># sock</span><br><span class="line">git config --local http.proxy &#x27;socks5://127.0.0.1:1080&#x27; </span><br><span class="line"></span><br><span class="line">取消代理：</span><br><span class="line">git config --local --unset http.proxy</span><br></pre></td></tr></table></figure>
<h4 id="配置完成，clone-commit代码"><a class="header-anchor" href="#配置完成，clone-commit代码">¶</a>配置完成，clone/commit代码</h4>
<h5 id="clone仓库代码"><a class="header-anchor" href="#clone仓库代码">¶</a>clone仓库代码</h5>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/20200902081306.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/crab21/blog.git</span><br></pre></td></tr></table></figure>
<h5 id="commit代码"><a class="header-anchor" href="#commit代码">¶</a>commit代码</h5>
<blockquote>
<p>按照如上配置完成后，就可以完成基本的push和pull仓库代码了。</p>
</blockquote>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>「5」Git GPG签署工作</title>
    <url>/archives/580377d0.html</url>
    <content><![CDATA[<h3 id="GPG场景"><a class="header-anchor" href="#GPG场景">¶</a>GPG场景</h3>
<p>Git 虽然是密码级安全的，但它不是万无一失的。 如果你从因特网上的其他人那里拿取工作，并且想要验证提交是不是真正地来自于可信来源， Git 提供了几种通过 GPG 来签署和验证工作的方式。</p>
<p>最终效果：如下图所示</p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/20200902123343.png" alt=""></p>
<h3 id="安装过程"><a class="header-anchor" href="#安装过程">¶</a>安装过程</h3>
<p>windows安装地址： <a href="https://www.gnupg.org/">点击下载</a></p>
<p>mac os为例：</p>
<span id="more"></span>
<h4 id="安装GPG"><a class="header-anchor" href="#安装GPG">¶</a>安装GPG</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install gpg</span><br><span class="line"></span><br><span class="line">查看结果：</span><br><span class="line">± gpg --version                                                                                                                                                                                                                                     ⏎</span><br><span class="line"></span><br><span class="line">gpg (GnuPG) 2.2.22</span><br><span class="line">libgcrypt 1.8.6</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;https://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line">Home: /Users/gogoowang/.gnupg</span><br><span class="line">支持的算法：</span><br><span class="line">公钥： RSA, ELG, DSA, ECDH, ECDSA, EDDSA</span><br><span class="line">密文： IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH,</span><br><span class="line">    CAMELLIA128, CAMELLIA192, CAMELLIA256</span><br><span class="line">散列： SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224</span><br><span class="line">压缩：  不压缩, ZIP, ZLIB, BZIP2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="生成密钥"><a class="header-anchor" href="#生成密钥">¶</a>生成密钥</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --full-generate-key</span><br></pre></td></tr></table></figure>
<p>需要填写的地方：<br>
<img data-src="https://raw.githubusercontent.com/crab21/Images/master/20200902123803.png" alt=""></p>
<h4 id="查看密钥完整信息"><a class="header-anchor" href="#查看密钥完整信息">¶</a>查看密钥完整信息</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --list-secret-keys --keyid-format LONG</span><br></pre></td></tr></table></figure>
<blockquote>
<p>secret keys（红圈地方后续用到，留意下）：</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/20200902124016.png" alt=""></p>
<h4 id="根据secret-keys生成PGP"><a class="header-anchor" href="#根据secret-keys生成PGP">¶</a>根据secret keys生成PGP</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --armor --export  7BB8CF3593CA174C</span><br></pre></td></tr></table></figure>
<p>生成的PGP结果，后续需要将此结果导入到Github账号的配置信息中<br>
<img data-src="https://raw.githubusercontent.com/crab21/Images/master/20200902124305.png" alt=""></p>
<h4 id="Github账号中设置"><a class="header-anchor" href="#Github账号中设置">¶</a>Github账号中设置</h4>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/20200902124443.png" alt=""></p>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/20200902124527.png" alt=""></p>
<blockquote>
<p>将上述生成的PGP填入，点击[Add GPG Key]即可</p>
</blockquote>
<h4 id="配置本地GPG签名信息"><a class="header-anchor" href="#配置本地GPG签名信息">¶</a>配置本地GPG签名信息</h4>
<p>依次执行下面命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、git config --global user.signingkey 7BB8CF3593CA174C  #此处的7BB8CF3593CA174C为生成的secret keys</span><br><span class="line">2、git config commit.gpgsign true</span><br><span class="line">3、git config --global commit.gpgsign true</span><br></pre></td></tr></table></figure>
<h4 id="Git-PGP生效"><a class="header-anchor" href="#Git-PGP生效">¶</a>Git PGP生效</h4>
<blockquote>
<p>再次提交commit即可生效。产生如下图的签名效果：</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/crab21/Images/master/20200902123343.png" alt=""></p>
<h4 id="End"><a class="header-anchor" href="#End">¶</a>End</h4>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>「4」Git常用技巧</title>
    <url>/archives/3c1dd822.html</url>
    <content><![CDATA[<h3 id="学习方式"><a class="header-anchor" href="#学习方式">¶</a>学习方式</h3>
<p>多练多得，直接学习<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6">官网</a>理解。</p>
<p>以下仅仅是部分用到的场景和部分场景记录，不代表全部情况，如有错误，请及时指正。</p>
<h3 id="Git版本："><a class="header-anchor" href="#Git版本：">¶</a>Git版本：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1944 ± git version </span><br><span class="line">git version 2.28.0</span><br></pre></td></tr></table></figure>
<h3 id="先说说Git的常用命令：-可跳过"><a class="header-anchor" href="#先说说Git的常用命令：-可跳过">¶</a>先说说Git的常用命令：(可跳过)</h3>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2081 ◯  git </span><br><span class="line">用法：git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;]</span><br><span class="line">           [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]</span><br><span class="line">           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]</span><br><span class="line">           [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;]</span><br><span class="line">           &lt;command&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">这些是各种场合常见的 Git 命令：</span><br><span class="line"></span><br><span class="line">开始一个工作区（参见：git help tutorial）</span><br><span class="line">   clone             克隆仓库到一个新目录</span><br><span class="line">   init              创建一个空的 Git 仓库或重新初始化一个已存在的仓库</span><br><span class="line"></span><br><span class="line">在当前变更上工作（参见：git help everyday）</span><br><span class="line">   add               添加文件内容至索引</span><br><span class="line">   mv                移动或重命名一个文件、目录或符号链接</span><br><span class="line">   restore           恢复工作区文件</span><br><span class="line">   rm                从工作区和索引中删除文件</span><br><span class="line">   sparse-checkout   初始化及修改稀疏检出</span><br><span class="line"></span><br><span class="line">检查历史和状态（参见：git help revisions）</span><br><span class="line">   bisect            通过二分查找定位引入 bug 的提交</span><br><span class="line">   diff              显示提交之间、提交和工作区之间等的差异</span><br><span class="line">   grep              输出和模式匹配的行</span><br><span class="line">   log               显示提交日志</span><br><span class="line">   show              显示各种类型的对象</span><br><span class="line">   status            显示工作区状态</span><br><span class="line"></span><br><span class="line">扩展、标记和调校您的历史记录</span><br><span class="line">   branch            列出、创建或删除分支</span><br><span class="line">   commit            记录变更到仓库</span><br><span class="line">   merge             合并两个或更多开发历史</span><br><span class="line">   rebase            在另一个分支上重新应用提交</span><br><span class="line">   reset             重置当前 HEAD 到指定状态</span><br><span class="line">   switch            切换分支</span><br><span class="line">   tag               创建、列出、删除或校验一个 GPG 签名的标签对象</span><br><span class="line"></span><br><span class="line">协同（参见：git help workflows）</span><br><span class="line">   fetch             从另外一个仓库下载对象和引用</span><br><span class="line">   pull              获取并整合另外的仓库或一个本地分支</span><br><span class="line">   push              更新远程引用和相关的对象</span><br><span class="line"></span><br><span class="line">命令 &#x27;git help -a&#x27; 和 &#x27;git help -g&#x27; 显示可用的子命令和一些概念帮助。</span><br><span class="line">查看 &#x27;git help &lt;命令&gt;&#x27; 或 &#x27;git help &lt;概念&gt;&#x27; 以获取给定子命令或概念的</span><br><span class="line">帮助。</span><br><span class="line">有关系统的概述，查看 &#x27;git help git&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="Git使用："><a class="header-anchor" href="#Git使用：">¶</a>Git使用：</h3>
<h4 id="生成密钥"><a class="header-anchor" href="#生成密钥">¶</a>生成密钥</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;这里换上你的邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>最后得到<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件。</p>
<h4 id="Git配置信息"><a class="header-anchor" href="#Git配置信息">¶</a>Git配置信息</h4>
<h5 id="查看配置信息"><a class="header-anchor" href="#查看配置信息">¶</a>查看配置信息</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看系统配置信息</span><br><span class="line">* git config --system --list</span><br><span class="line"></span><br><span class="line">当前用户配置</span><br><span class="line">* git config --global --list</span><br><span class="line"></span><br><span class="line">查看当前仓库配置</span><br><span class="line">* git config --local --list</span><br></pre></td></tr></table></figure>
<h5 id="设置用户信息"><a class="header-anchor" href="#设置用户信息">¶</a>设置用户信息</h5>
<p>全局设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;crab&quot;</span><br><span class="line">git config --global user.email &quot;imrcrab@163.com&quot;</span><br></pre></td></tr></table></figure>
<p>当前仓库生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --local user.name &quot;crab&quot;</span><br><span class="line">git config --local user.email &quot;imrcrab@163.com&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Git-Remote"><a class="header-anchor" href="#Git-Remote">¶</a>Git Remote</h4>
<h5 id="新增remote地址"><a class="header-anchor" href="#新增remote地址">¶</a>新增remote地址</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add upstream http://github/**remote**/test.git</span><br><span class="line">git remote -v 可以查看具体路径</span><br></pre></td></tr></table></figure>
<h5 id="merge-fetch远程代码到XXX分支"><a class="header-anchor" href="#merge-fetch远程代码到XXX分支">¶</a>merge/fetch远程代码到XXX分支</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、git fetch upstream。</span><br><span class="line">2、切回到master分支。</span><br><span class="line">3、git merge upstream/master 合并远程upstream分支到本地master。</span><br><span class="line">4、解决冲突或其他问题。</span><br></pre></td></tr></table></figure>
<h4 id="Git-误删除恢复"><a class="header-anchor" href="#Git-误删除恢复">¶</a>Git 误删除恢复</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、git  fsck --lost -found :查看最近移除的文件.</span><br><span class="line">2、git show  &#x27;误删编号&#x27;：查看删除文件内容.</span><br><span class="line">3、git merge ‘误删编号’： 本地合并误删的文件内容.</span><br></pre></td></tr></table></figure>
<h4 id="Git-reset撤回操作"><a class="header-anchor" href="#Git-reset撤回操作">¶</a>Git reset撤回操作</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、git reflog</span><br><span class="line">2、git reset COMMITID    就可以回到COMMITID那个分支和版本。</span><br></pre></td></tr></table></figure>
<h4 id="Git分支"><a class="header-anchor" href="#Git分支">¶</a>Git分支</h4>
<h5 id="用法"><a class="header-anchor" href="#用法">¶</a>用法</h5>
<blockquote>
<p>获取用法：Git branch -d --help</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用法：git branch [&lt;选项&gt;] [-r | -a] [--merged | --no-merged]</span><br><span class="line">  或：git branch [&lt;选项&gt;] [-l] [-f] &lt;分支名&gt; [&lt;起始点&gt;]</span><br><span class="line">  或：git branch [&lt;选项&gt;] [-r] (-d | -D) &lt;分支名&gt;...</span><br><span class="line">  或：git branch [&lt;选项&gt;] (-m | -M) [&lt;旧分支&gt;] &lt;新分支&gt;</span><br><span class="line">  或：git branch [&lt;选项&gt;] (-c | -C) [&lt;老分支&gt;] &lt;新分支&gt;</span><br><span class="line">  或：git branch [&lt;选项&gt;] [-r | -a] [--points-at]</span><br><span class="line">  或：git branch [&lt;选项&gt;] [-r | -a] [--format]</span><br><span class="line"></span><br><span class="line">通用选项</span><br><span class="line">    -v, --verbose         显示哈希值和主题，若参数出现两次则显示上游分支</span><br><span class="line">    -q, --quiet           不显示信息</span><br><span class="line">    -t, --track           设置跟踪模式（参见 git-pull(1)）</span><br><span class="line">    -u, --set-upstream-to &lt;上游&gt;</span><br><span class="line">                          改变上游信息</span><br><span class="line">    --unset-upstream      取消上游信息的设置</span><br><span class="line">    --color[=&lt;何时&gt;]      使用彩色输出</span><br><span class="line">    -r, --remotes         作用于远程跟踪分支</span><br><span class="line">    --contains &lt;提交&gt;     只打印包含该提交的分支</span><br><span class="line">    --no-contains &lt;提交&gt;  只打印不包含该提交的分支</span><br><span class="line">    --abbrev[=&lt;n&gt;]        用 &lt;n&gt; 位数字显示 SHA-1 哈希值</span><br><span class="line"></span><br><span class="line">具体的 git-branch 动作：</span><br><span class="line">    -a, --all             列出远程跟踪及本地分支</span><br><span class="line">    -d, --delete          删除完全合并的分支</span><br><span class="line">    -D                    删除分支（即使没有合并）</span><br><span class="line">    -m, --move            移动/重命名一个分支，以及它的引用日志</span><br><span class="line">    -M                    移动/重命名一个分支，即使目标已存在</span><br><span class="line">    -c, --copy            拷贝一个分支和它的引用日志</span><br><span class="line">    -C                    拷贝一个分支，即使目标已存在</span><br><span class="line">    -l, --list            列出分支名</span><br><span class="line">    --show-current        显示当前分支名</span><br><span class="line">    --create-reflog       创建分支的引用日志</span><br><span class="line">    --edit-description    标记分支的描述</span><br><span class="line">    -f, --force           强制创建、移动/重命名、删除</span><br><span class="line">    --merged &lt;提交&gt;       只打印已经合并的分支</span><br><span class="line">    --no-merged &lt;提交&gt;    只打印尚未合并的分支</span><br><span class="line">    --column[=&lt;风格&gt;]     以列的方式显示分支</span><br><span class="line">    --sort &lt;key&gt;          排序的字段名</span><br><span class="line">    --points-at &lt;对象&gt;    只打印指向该对象的分支</span><br><span class="line">    -i, --ignore-case     排序和过滤属于大小写不敏感</span><br><span class="line">    --format &lt;格式&gt;       输出格式</span><br></pre></td></tr></table></figure>
<h5 id="获取所有分支"><a class="header-anchor" href="#获取所有分支">¶</a>获取所有分支</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -r | grep -v &#x27;\-&gt;&#x27; | while read remote; do git branch --track &quot;$&#123;remote#origin/&#125;&quot; &quot;$remote&quot;; done</span><br><span class="line">git fetch --all</span><br><span class="line">git pull --all</span><br></pre></td></tr></table></figure>
<h5 id="add-remove分支"><a class="header-anchor" href="#add-remove分支">¶</a>add/remove分支</h5>
<p>新建&amp;切换:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b iss53</span><br><span class="line"></span><br><span class="line">是下面两条的简写：</span><br><span class="line">git branch iss53</span><br><span class="line">git checkout iss53</span><br></pre></td></tr></table></figure>
<p>删除分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d iss53</span><br></pre></td></tr></table></figure>
<h4 id="Git-stash"><a class="header-anchor" href="#Git-stash">¶</a>Git stash</h4>
<h5 id="常用："><a class="header-anchor" href="#常用：">¶</a>常用：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）git stash save &quot;save message&quot;  : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</span><br><span class="line">（2）git stash list  ：查看stash了哪些存储</span><br><span class="line">（3）git stash show ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@&#123;$num&#125;，比如第二个 git stash show stash@&#123;1&#125;</span><br><span class="line">（4）git stash show -p : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show  stash@&#123;$num&#125;  -p ，比如第二个：git stash show  stash@&#123;1&#125;  -p</span><br><span class="line">（5）git stash apply :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@&#123;0&#125;，如果要使用其他个，git stash apply stash@&#123;$num&#125; ， 比如第二个：git stash apply stash@&#123;1&#125; </span><br><span class="line">（6）git stash pop ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@&#123;0&#125;，如果要应用并删除其他stash，命令：git stash pop stash@&#123;$num&#125; ，比如应用并删除第二个：git stash pop stash@&#123;1&#125;</span><br><span class="line">（7）git stash drop stash@&#123;$num&#125; ：丢弃stash@&#123;$num&#125;存储，从列表中删除这个存储</span><br><span class="line">（8）git stash clear ：删除所有缓存的stash</span><br></pre></td></tr></table></figure>
<h4 id="Git-Tag"><a class="header-anchor" href="#Git-Tag">¶</a>Git Tag</h4>
<h5 id="常用：-v2"><a class="header-anchor" href="#常用：-v2">¶</a>常用：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2097 ± git tag -a --help</span><br><span class="line">用法：git tag [-a | -s | -u &lt;key-id&gt;] [-f] [-m &lt;消息&gt; | -F &lt;文件&gt;]</span><br><span class="line">		&lt;标签名&gt; [&lt;头&gt;]</span><br><span class="line">  或：git tag -d &lt;标签名&gt;...</span><br><span class="line">  或：git tag -l [-n[&lt;数字&gt;]] [--contains &lt;提交&gt;] [--no-contains &lt;提交&gt;] [--points-at &lt;对象&gt;]</span><br><span class="line">		[--format=&lt;格式&gt;] [--[no-]merged [&lt;提交&gt;]] [&lt;模式&gt;...]</span><br><span class="line">  或：git tag -v [--format=&lt;格式&gt;] &lt;标签名&gt;...</span><br><span class="line"></span><br><span class="line">    -l, --list            列出标签名称</span><br><span class="line">    -n[&lt;n&gt;]               每个标签信息打印 &lt;n&gt; 行</span><br><span class="line">    -d, --delete          删除标签</span><br><span class="line">    -v, --verify          验证标签</span><br><span class="line"></span><br><span class="line">标签创建选项</span><br><span class="line">    -a, --annotate        附注标签，需要一个说明</span><br><span class="line">    -m, --message &lt;说明&gt;  标签说明</span><br><span class="line">    -F, --file &lt;文件&gt;     从文件中读取提交说明</span><br><span class="line">    -e, --edit            强制编辑标签说明</span><br><span class="line">    -s, --sign            附注并附加 GPG 签名的标签</span><br><span class="line">    --cleanup &lt;模式&gt;      设置如何删除提交说明里的空格和#注释</span><br><span class="line">    -u, --local-user &lt;key-id&gt;</span><br><span class="line">                          使用另外的私钥签名该标签</span><br><span class="line">    -f, --force           如果存在，替换现有的标签</span><br><span class="line">    --create-reflog       创建引用日志</span><br><span class="line"></span><br><span class="line">标签列表选项</span><br><span class="line">    --column[=&lt;风格&gt;]     以列的方式显示标签列表</span><br><span class="line">    --contains &lt;提交&gt;     只打印包含该提交的标签</span><br><span class="line">    --no-contains &lt;提交&gt;  只打印不包含该提交的标签</span><br><span class="line">    --merged &lt;提交&gt;       只打印已经合并的标签</span><br><span class="line">    --no-merged &lt;提交&gt;    只打印尚未合并的标签</span><br><span class="line">    --sort &lt;key&gt;          排序的字段名</span><br><span class="line">    --points-at &lt;对象&gt;    只打印指向该对象的标签</span><br><span class="line">    --format &lt;格式&gt;       输出格式</span><br><span class="line">    --color[=&lt;何时&gt;]      遵照格式中的颜色输出</span><br><span class="line">    -i, --ignore-case     排序和过滤属于大小写不敏感</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag按照version排序：</span><br><span class="line">git tag -n</span><br><span class="line"></span><br><span class="line">git tag按照时间排序</span><br><span class="line">git tag -n --sort=taggerdate</span><br><span class="line"></span><br><span class="line">git tag按照顺序拉</span><br><span class="line">git tag --sort=-v:refname</span><br><span class="line"></span><br><span class="line">git tag 批量删除</span><br><span class="line">git tag | grep &quot;v&quot; |xargs git tag -d</span><br><span class="line"></span><br><span class="line">git tag 批量删除远端</span><br><span class="line">git show-ref --tag | grep &quot;v1.0&quot;| awk &#x27;&#123;print $2&#125;&#x27;|xargs git push origin --delete</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="打Tag"><a class="header-anchor" href="#打Tag">¶</a>打Tag</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -a v0.0.1 -m &quot;V0.0.1&quot; </span><br></pre></td></tr></table></figure>
<h5 id="删除Tag"><a class="header-anchor" href="#删除Tag">¶</a>删除Tag</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -d v0.0.1</span><br></pre></td></tr></table></figure>
<h5 id="推送Tag"><a class="header-anchor" href="#推送Tag">¶</a>推送Tag</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master --tags</span><br></pre></td></tr></table></figure>
<h4 id="Git-push"><a class="header-anchor" href="#Git-push">¶</a>Git push</h4>
<h5 id="用法-v2"><a class="header-anchor" href="#用法-v2">¶</a>用法</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用法：git push [&lt;选项&gt;] [&lt;仓库&gt; [&lt;引用规格&gt;...]]</span><br><span class="line"></span><br><span class="line">    -v, --verbose         更加详细</span><br><span class="line">    -q, --quiet           更加安静</span><br><span class="line">    --repo &lt;仓库&gt;         仓库</span><br><span class="line">    --all                 推送所有引用</span><br><span class="line">    --mirror              镜像所有引用</span><br><span class="line">    -d, --delete          删除引用</span><br><span class="line">    --tags                推送标签（不能使用 --all or --mirror）</span><br><span class="line">    -n, --dry-run         演习</span><br><span class="line">    --porcelain           机器可读的输出</span><br><span class="line">    -f, --force           强制更新</span><br><span class="line">    --force-with-lease[=&lt;引用名&gt;:&lt;期望值&gt;]</span><br><span class="line">                          要求引用旧的取值为设定值</span><br><span class="line">    --recurse-submodules (check|on-demand|no)</span><br><span class="line">                          控制子模组的递归推送</span><br><span class="line">    --thin                使用精简打包</span><br><span class="line">    --receive-pack &lt;receive-pack&gt;</span><br><span class="line">                          接收包程序</span><br><span class="line">    --exec &lt;receive-pack&gt;</span><br><span class="line">                          接收包程序</span><br><span class="line">    -u, --set-upstream    设置 git pull/status 的上游</span><br><span class="line">    --progress            强制显示进度报告</span><br><span class="line">    --prune               清除本地删除的引用</span><br><span class="line">    --no-verify           绕过 pre-push 钩子</span><br><span class="line">    --follow-tags         推送缺失但有关的标签</span><br><span class="line">    --signed[=(yes|no|if-asked)]</span><br><span class="line">                          用 GPG 为推送签名</span><br><span class="line">    --atomic              需要远端支持原子事务</span><br><span class="line">    -o, --push-option &lt;server-specific&gt;</span><br><span class="line">                          传输选项</span><br><span class="line">    -4, --ipv4            只使用 IPv4 地址</span><br><span class="line">    -6, --ipv6            只使用 IPv6 地址</span><br></pre></td></tr></table></figure>
<h4 id="Git-rebase"><a class="header-anchor" href="#Git-rebase">¶</a>Git rebase</h4>
<h5 id="变基遵守的原则"><a class="header-anchor" href="#变基遵守的原则">¶</a>变基遵守的原则</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。---[官网变基](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA)</span><br><span class="line"></span><br><span class="line">TODO 后续更新此过程</span><br></pre></td></tr></table></figure>
<h5 id="经典用法："><a class="header-anchor" href="#经典用法：">¶</a>经典用法：</h5>
<blockquote>
<p>git rebase --help</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Assume the following history exists and the current branch is &quot;topic&quot;:</span><br><span class="line"></span><br><span class="line">              A---B---C topic</span><br><span class="line">             /</span><br><span class="line">        D---E---F---G master</span><br><span class="line">From this point, the result of either of thefollowing </span><br><span class="line"></span><br><span class="line">commands:</span><br><span class="line">    git rebase master</span><br><span class="line">    git rebase master topic</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">would be:</span><br><span class="line">                      A&#x27;--B&#x27;--C&#x27; topic</span><br><span class="line">                     /</span><br><span class="line">        D---E---F---G master</span><br></pre></td></tr></table></figure>
<h5 id="rebase场景："><a class="header-anchor" href="#rebase场景：">¶</a>rebase场景：</h5>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA">官网例子</a></p>
<h3 id="Git-快速场景："><a class="header-anchor" href="#Git-快速场景：">¶</a>Git 快速场景：</h3>
<p>其实还是对上述命令的活学活用。</p>
<h4 id="Git-Reset场景"><a class="header-anchor" href="#Git-Reset场景">¶</a>Git Reset场景</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 本地修改了一堆文件(并没有使用git add到暂存区)，想放弃修改。</span><br><span class="line">单个文件/文件夹：</span><br><span class="line"></span><br><span class="line">git checkout -- filename</span><br><span class="line"></span><br><span class="line">所有文件/文件夹：</span><br><span class="line"></span><br><span class="line">git checkout .</span><br><span class="line"> </span><br><span class="line">2. 本地新增了一堆文件(并没有git add到暂存区)，想放弃修改。</span><br><span class="line">单个文件/文件夹：</span><br><span class="line"></span><br><span class="line">$ rm filename / rm dir -rf</span><br><span class="line"></span><br><span class="line">所有文件/文件夹：</span><br><span class="line"></span><br><span class="line">$ git clean -xdf</span><br><span class="line"></span><br><span class="line">// 删除新增的文件，如果文件已经已经git add到暂存区，并不会删除！</span><br><span class="line"></span><br><span class="line">3. 本地修改/新增了一堆文件，已经git add到暂存区，想放弃修改。</span><br><span class="line">单个文件/文件夹：</span><br><span class="line"></span><br><span class="line">git reset HEAD filename</span><br><span class="line"></span><br><span class="line">所有文件/文件夹：</span><br><span class="line"></span><br><span class="line">git reset HEAD .</span><br><span class="line"> </span><br><span class="line">4. 本地通过git add &amp; git commit 之后，想要撤销此次commit和代码</span><br><span class="line"></span><br><span class="line">git reset commit_id</span><br><span class="line"></span><br><span class="line">这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位</span><br><span class="line">// 撤销之后，你所做的已经commit的修改还在工作区！</span><br><span class="line"></span><br><span class="line">git reset --hard commit_id</span><br><span class="line"></span><br><span class="line">这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位</span><br><span class="line">// 撤销之后，你所做的已经commit的修改将会清除，仍在工作区/暂存区的代码不会清除！</span><br><span class="line"></span><br><span class="line">5. git add &amp; git commit 提交后，只想回滚commit：</span><br><span class="line">	git reset --soft HEAD^</span><br><span class="line">	注意这仅仅是回滚了你的commit，代码依旧在的。</span><br></pre></td></tr></table></figure>
<h3 id="Git-☞-for-each-ref"><a class="header-anchor" href="#Git-☞-for-each-ref">¶</a>Git <a href="https://git-scm.com/docs/git-for-each-ref"> ☞ for-each-ref</a></h3>
<blockquote>
<p>主要用于查看所有的ref历史等信息。</p>
</blockquote>
<blockquote>
<p>不废话，上例子</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git for-each-ref --sort=committerdate --format=&#x27;*** %(refname)%09%(committerdate) *** %(subject)  %09%(upstream) %09 %(authorname)%(authordate)&#x27;|tail -n 10</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：<br>
[这里显示最后10次信息]</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">❯ git for-each-ref --sort=committerdate --format=&#x27;*** %(refname)%09%(committerdate) *** %(subject)  %09%(upstream) %09 %(authorname)%(authordate)&#x27;|tail -n 10</span><br><span class="line">*** refs/tags/v0.1.0.4   *** v0.1.0.4            </span><br><span class="line">*** refs/tags/v0.1.0.5   *** v0.1.0.5            </span><br><span class="line">*** refs/tags/v0.1.0.6   *** v0.1.0.6            </span><br><span class="line">*** refs/tags/v0.1.0.7   *** v0.1.0.7            </span><br><span class="line">*** refs/tags/v0.1.0.8   *** v0.1.0.8            </span><br><span class="line">*** refs/tags/v0.1.0.9   *** v0.1.0.9            </span><br><span class="line">*** refs/remotes/origin/server  Sun Dec 13 11:41:57 2020 +0800 *** Site updated: 2020-12-13 11:41:57             crabSun Dec 13 11:41:57 2020 +0800</span><br><span class="line">*** refs/heads/master   Wed Mar 30 00:53:31 2022 +0800 *** feat: kubebuilder    refs/remotes/origin/master       crabWed Mar 30 00:53:31 2022 +0800</span><br><span class="line">*** refs/remotes/origin/HEAD    Wed Mar 30 00:53:31 2022 +0800 *** feat: kubebuilder             crabWed Mar 30 00:53:31 2022 +0800</span><br><span class="line">*** refs/remotes/origin/master  Wed Mar 30 00:53:31 2022 +0800 *** feat: kubebuilder             crabWed Mar 30 00:53:31 2022 +0800</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="持续更新…"><a class="header-anchor" href="#持续更新…">¶</a>持续更新…</h3>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>「3」git cz规范提交</title>
    <url>/archives/458b44c2.html</url>
    <content><![CDATA[<h3 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h3>
<p><a href="https://github.com/commitizen/cz-cli">官方 specification</a><br>
简单的说为了代码提交更加规范</p>
<h3 id="场景"><a class="header-anchor" href="#场景">¶</a>场景</h3>
<p>git commit使用<br>
<img data-src="https://github.com/commitizen/cz-cli/raw/master/meta/screenshots/add-commit.png" alt=""></p>
<h3 id="使用步骤"><a class="header-anchor" href="#使用步骤">¶</a>使用步骤</h3>
<ul>
<li>安装nodejs，版本建议最新.<a href="https://nodejs.org/zh-cn/">官网</a></li>
<li>打开你的命令行：</li>
</ul>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：npm install -g commitizen</span><br><span class="line">windows应该是cmd吧。</span><br><span class="line">mac用终端或者iterm2都可以。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示以下信息即成功。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; % sudo npm install -g commitizen</span><br><span class="line">Password:</span><br><span class="line">npm WARN deprecated resolve-url@0.2.1: https://github.com/lydell/resolve-url#deprecated</span><br><span class="line">npm WARN deprecated urix@0.1.0: Please see https://github.com/lydell/urix#deprecated</span><br><span class="line">/usr/local/bin/cz -&gt; /usr/local/lib/node_modules/commitizen/bin/git-cz</span><br><span class="line">/usr/local/bin/git-cz -&gt; /usr/local/lib/node_modules/commitizen/bin/git-cz</span><br><span class="line">/usr/local/bin/commitizen -&gt; /usr/local/lib/node_modules/commitizen/bin/commitizen</span><br><span class="line">+ commitizen@4.2.1</span><br><span class="line">updated 1 package in 8.132s</span><br></pre></td></tr></table></figure>
<p>3、进入git项目中，执行下面命令初始化环境。<br>
<code>commitizen init cz-conventional-changelog --save --save-exact</code></p>
<p>4、在提交代码时使用</p>
<blockquote>
<p>git cz 替换 git commit命令</p>
</blockquote>
<h3 id="注意事项"><a class="header-anchor" href="#注意事项">¶</a>注意事项</h3>
<ul>
<li>安装方式可选择全局安装</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g commitizen cz-conventional-changelog</span><br><span class="line">echo &#x27;&#123; &quot;path&quot;: &quot;cz-conventional-changelog&quot; &#125;&#x27; &gt; ~/.czrc</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>「2」vscode 常见插件及其使用</title>
    <url>/archives/8cf3cbca.html</url>
    <content><![CDATA[<blockquote>
<p>vscode中一些常见的坑点…</p>
</blockquote>
<h3 id="插件"><a class="header-anchor" href="#插件">¶</a>插件</h3>
<h4 id="样式方面："><a class="header-anchor" href="#样式方面：">¶</a>样式方面：</h4>
<ul>
<li>Indent Rainbo</li>
<li>Bracket Pair Colorizer # 括号颜色</li>
<li>Chinese Language       # 汉化</li>
</ul>
<span id="more"></span>
<h4 id="功能方面"><a class="header-anchor" href="#功能方面">¶</a>功能方面</h4>
<ul>
<li>Git Blame              # Git提交查看</li>
<li>Code Spell Checker     # 拼写检查</li>
<li>Reload                 # 重新加载</li>
<li>Todo Tree              # 代办事项</li>
<li>Settings Sync          # 设置同步</li>
</ul>
]]></content>
      <tags>
        <tag>vscode</tag>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
