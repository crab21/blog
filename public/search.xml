<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>「15」Plan9 汇编小记</title>
    <url>/archives/2ce846ed.html</url>
    <content><![CDATA[<h4 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h4><blockquote>
<p>平常coding时，偶尔会查看计算机的具体执行过程，那最基本的就是汇编了，了解汇编是调试过程中必不可少的，尤其是一些细节的处理方面.Go的汇编是Plan 9(贝尔实验室的产物)，和汇编很类似。</p>
</blockquote>
<h4 id="如何得到汇编结果？"><a href="#如何得到汇编结果？" class="headerlink" title="如何得到汇编结果？"></a>如何得到汇编结果？</h4><ul>
<li>官网文档</li>
<li>Google</li>
</ul>
<h5 id="3种方式："><a href="#3种方式：" class="headerlink" title="3种方式："></a>3种方式：</h5><blockquote>
<p>第一种</p>
</blockquote>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> tool compile -N -l -S ***.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>第二种</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、先编译：</span><br><span class="line">    <span class="keyword">go</span> tool compile -N -l ***.<span class="keyword">go</span></span><br><span class="line"><span class="number">2</span>、再反编译：</span><br><span class="line">    <span class="keyword">go</span> tool objdump ***.o</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第三种</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> build -gcflags -S ***.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>


<h4 id="常用寄存器"><a href="#常用寄存器" class="headerlink" title="常用寄存器"></a>常用寄存器</h4><h5 id="AX-BX-CX-DX-BP-SI-SP-IP"><a href="#AX-BX-CX-DX-BP-SI-SP-IP" class="headerlink" title="AX BX CX DX BP SI SP IP"></a>AX BX CX DX BP SI SP IP</h5><table>
<thead>
<tr>
<th align="left">寄存器</th>
<th align="left">16位</th>
<th align="left">32位</th>
<th align="left">64位</th>
</tr>
</thead>
<tbody><tr>
<td align="left">累加寄存器</td>
<td align="left">AX</td>
<td align="left">EAX</td>
<td align="left">RAX</td>
</tr>
<tr>
<td align="left">基址寄存器</td>
<td align="left">BX</td>
<td align="left">EBX</td>
<td align="left">RBX</td>
</tr>
<tr>
<td align="left">计数寄存器</td>
<td align="left">CX</td>
<td align="left">ECX</td>
<td align="left">RCX</td>
</tr>
<tr>
<td align="left">数据寄存器</td>
<td align="left">DX</td>
<td align="left">EDX</td>
<td align="left">RDX</td>
</tr>
<tr>
<td align="left">堆栈基指针</td>
<td align="left">BP</td>
<td align="left">EBP</td>
<td align="left">RBP</td>
</tr>
<tr>
<td align="left">变址寄存器</td>
<td align="left">SI</td>
<td align="left">ESI</td>
<td align="left">RSI</td>
</tr>
<tr>
<td align="left">堆栈顶指针</td>
<td align="left">SP</td>
<td align="left">ESP</td>
<td align="left">RSP</td>
</tr>
<tr>
<td align="left">指令寄存器</td>
<td align="left">IP</td>
<td align="left">EIP</td>
<td align="left">RIP</td>
</tr>
</tbody></table>
<h5 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h5><blockquote>
<p>movb（8位）、movw（16位）、movl（32位）、movq（64位）</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MOVSS: 移动单精度浮点数</span><br></pre></td></tr></table></figure>

<h4 id="查询地址"><a href="#查询地址" class="headerlink" title="查询地址"></a>查询地址</h4><p><a href="https://c9x.me/x86/html/file_module_x86_id_205.html">MOVSS</a><br><a href="https://www.felixcloutier.com/x86/index.html">Intel汇编指令查询</a><br><a href="https://plan9.io/sources/contrib/ericvh/go-plan9/src/pkg/runtime/slice.c">Plan9查询</a></p>
<h4 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…."></a>持续更新….</h4>]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>Plan9</tag>
      </tags>
  </entry>
  <entry>
    <title>「13」Linux 进程</title>
    <url>/archives/ba455c1d.html</url>
    <content><![CDATA[<p>进程这是个老生常谈的问题，当然我不是那个老生，我只是个loser。</p>
<p>今天用chrome，占用很多的内存和资源，查了查，说chrome是多进程的，于是就想了解下进程一些相关的内容。<br>主要从以下几个角度了解下进程：</p>
<ul>
<li>来源</li>
<li>定义</li>
<li>特征</li>
<li>多进程如何工作？</li>
<li>通信</li>
</ul>
<a id="more"></a>

<h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>抽象正在运行的程序，或者说是对计算机系统存储器的调度和管理。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>进程：并发程序在执行过程中资源分配和管理的最基本的单元（资源分配的最小单元，执行的最小单元）。一个程序一旦开始执行，就是一个进程。每一个进程都有自己的独立空间，系统会分配一定的地址空间和完整的数据段空间。</p>
<p>ps:[线程：程序执行的最小单位。]</p>
<p>组成：程序、数据、控制块组成。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>动态性 ： 多个程序执行过程中的一次执行过程，进程是动态产生，动态销毁的。</li>
<li>并发性 ： 任何进程可以和其它进程并发执行。</li>
<li>独立性 ： 是独立运行的基本单元，也是资源分配和调度的独立单元。</li>
<li>异步性 ： 由于进程间的相互制约，进程间是各自独立，各自向前。</li>
</ul>
<h3 id="多进程工作："><a href="#多进程工作：" class="headerlink" title="多进程工作："></a>多进程工作：</h3><h4 id="进程的状态："><a href="#进程的状态：" class="headerlink" title="进程的状态："></a>进程的状态：</h4><blockquote>
<p>3种状态：</p>
</blockquote>
<ul>
<li>就绪</li>
<li>运行</li>
<li>阻塞</li>
</ul>
<h5 id="3态图："><a href="#3态图：" class="headerlink" title="3态图："></a>3态图：</h5><p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/linux_process_3.1.png"></p>
<h5 id="5态图："><a href="#5态图：" class="headerlink" title="5态图："></a>5态图：</h5><p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/linux_p3.png"></p>
<h5 id="7态图："><a href="#7态图：" class="headerlink" title="7态图："></a>7态图：</h5><p>新增两种状态：</p>
<ul>
<li>挂起就绪状态：表明进程具备了运行的条件，目前在二级存储器里面。</li>
<li>挂起等待状态：表明进程正在等待某一个事件的结束且目前在二级存储器里面。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/linux_process_7.png"></p>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>映射一段能被其它进程访问的内存，一个进程创建，其它进程可访问。共享内存是最快的IPC方式，往往和信号量一起使用，达到进程间的同步和互斥。</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>实质就是一个缓冲区。<br>管道限制：</p>
<ul>
<li>半双工</li>
<li>只能在亲缘进程间通信</li>
</ul>
<p><strong>特点:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">写满时，不能再写，读空时，不能再读</span><br><span class="line">没写满，不能读，没读空，不能写</span><br></pre></td></tr></table></figure>

<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>是一种消息的链表，解决了信号传递信息少，管道只能承载无格式字节流及管道大小限制的缺点。</p>
<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>通知和接受进程某个事件已经发生了的。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>实质上就是个计数器，用来控制多个进程对于共享资源的访问情况。</p>
<h4 id="套接字（Socket）"><a href="#套接字（Socket）" class="headerlink" title="套接字（Socket）"></a>套接字（Socket）</h4><p>进程间通信的一种机制，多用于不同机器进程间的通信。</p>
<h4 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、管道：速度慢，容量有限，只有父子进程能通讯.</span><br><span class="line"><span class="number">2</span>、FIFO：任何进程间都能通讯，但速度慢.</span><br><span class="line"><span class="number">3</span>、消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题.</span><br><span class="line"><span class="number">4</span>、信号量：不能传递复杂消息，只能用来同步.</span><br><span class="line"><span class="number">5</span>、共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存.</span><br></pre></td></tr></table></figure>

<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>「20」博客诡异事件</title>
    <url>/archives/5ce14ff5.html</url>
    <content><![CDATA[<h3 id="博客CI-CD崩了"><a href="#博客CI-CD崩了" class="headerlink" title="博客CI CD崩了"></a>博客CI CD崩了</h3><blockquote>
<p>就在刚才修改了部分的config配置，后打了tag push了上去,</p>
</blockquote>
<blockquote>
<p>oh……GG了</p>
</blockquote>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">err: FATAL Something&#39;s wrong. Maybe you can find the solution here: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html</span><br><span class="line">err: TypeError: Cannot read property &#39;enable&#39; of undefined</span><br><span class="line">err:     at ***&#x2F;themes&#x2F;nextTheme&#x2F;scripts&#x2F;filters&#x2F;comment&#x2F;disqus.js:11:21</span><br><span class="line">err:     at Filter.execSync (&#x2F;***&#x2F;node_modules&#x2F;hexo&#x2F;lib&#x2F;extend&#x2F;filter.js:74:28)</span><br><span class="line">err:     at Hexo.execFilterSync (&#x2F;***&#x2F;node_modules&#x2F;hexo&#x2F;lib&#x2F;hexo&#x2F;index.js:432:29)</span><br><span class="line">err:     at module.exports (***&#x2F;themes&#x2F;nextTheme&#x2F;scripts&#x2F;events&#x2F;lib&#x2F;injects.js:58:8)</span><br><span class="line">err:     at Hexo.&lt;anonymous&gt; (***&#x2F;themes&#x2F;nextTheme&#x2F;scripts&#x2F;events&#x2F;index.js:9:27)</span><br><span class="line">err:     at Hexo.emit (events.js:314:20)</span><br><span class="line">err:     at Hexo._generate (&#x2F;***&#x2F;node_modules&#x2F;hexo&#x2F;lib&#x2F;hexo&#x2F;index.js:399:8)</span><br><span class="line">err:     at &#x2F;***&#x2F;node_modules&#x2F;hexo&#x2F;lib&#x2F;hexo&#x2F;index.js:249:***</span><br><span class="line">err:     at tryCatcher (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;util.js:16:23)</span><br><span class="line">err:     at Promise._settlePromiseFromHandler (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:547:31)</span><br><span class="line">err:     at Promise._settlePromise (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:604:18)</span><br><span class="line">err:     at Promise._settlePromise0 (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:649:10)</span><br><span class="line">err:     at Promise._settlePromises (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:729:18)</span><br><span class="line">err:     at Promise._fulfill (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:673:18)</span><br><span class="line">err:     at PromiseArray._resolve (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise_array.js:127:19)</span><br><span class="line">err:     at PromiseArray._promiseFulfilled (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise_array.js:145:14)</span><br><span class="line">err:     at Promise._settlePromise (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:609:26)</span><br><span class="line">err:     at Promise._settlePromise0 (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:649:10)</span><br><span class="line">err:     at Promise._settlePromises (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:729:18)</span><br><span class="line">err:     at Promise._fulfill (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:673:18)</span><br><span class="line">err:     at Promise._resolveCallback (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:466:57)</span><br><span class="line">err:     at Promise._settlePromiseFromHandler (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:559:17)</span><br><span class="line">out: INFO  Start processing</span><br><span class="line">err: FATAL Something&#39;s wrong. Maybe you can find the solution here: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html</span><br><span class="line">err: TypeError: Cannot read property &#39;enable&#39; of undefined</span><br><span class="line">err:     at ***&#x2F;themes&#x2F;nextTheme&#x2F;scripts&#x2F;filters&#x2F;comment&#x2F;disqus.js:11:21</span><br><span class="line">err:     at Filter.execSync (&#x2F;***&#x2F;node_modules&#x2F;hexo&#x2F;lib&#x2F;extend&#x2F;filter.js:74:28)</span><br><span class="line">err:     at Hexo.execFilterSync (&#x2F;***&#x2F;node_modules&#x2F;hexo&#x2F;lib&#x2F;hexo&#x2F;index.js:432:29)</span><br><span class="line">err:     at module.exports (***&#x2F;themes&#x2F;nextTheme&#x2F;scripts&#x2F;events&#x2F;lib&#x2F;injects.js:58:8)</span><br><span class="line">err:     at Hexo.&lt;anonymous&gt; (***&#x2F;themes&#x2F;nextTheme&#x2F;scripts&#x2F;events&#x2F;index.js:9:27)</span><br><span class="line">err:     at Hexo.emit (events.js:314:20)</span><br><span class="line">err:     at Hexo._generate (&#x2F;***&#x2F;node_modules&#x2F;hexo&#x2F;lib&#x2F;hexo&#x2F;index.js:399:8)</span><br><span class="line">err:     at &#x2F;***&#x2F;node_modules&#x2F;hexo&#x2F;lib&#x2F;hexo&#x2F;index.js:249:***</span><br><span class="line">err:     at tryCatcher (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;util.js:16:23)</span><br><span class="line">err:     at Promise._settlePromiseFromHandler (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:547:31)</span><br><span class="line">err:     at Promise._settlePromise (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:604:18)</span><br><span class="line">err:     at Promise._settlePromise0 (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:649:10)</span><br><span class="line">err:     at Promise._settlePromises (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:729:18)</span><br><span class="line">err:     at Promise._fulfill (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:673:18)</span><br><span class="line">err:     at PromiseArray._resolve (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise_array.js:127:19)</span><br><span class="line">err:     at PromiseArray._promiseFulfilled (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise_array.js:145:14)</span><br><span class="line">err:     at Promise._settlePromise (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:609:26)</span><br><span class="line">err:     at Promise._settlePromise0 (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:649:10)</span><br><span class="line">err:     at Promise._settlePromises (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:729:18)</span><br><span class="line">err:     at Promise._fulfill (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:673:18)</span><br><span class="line">err:     at Promise._resolveCallback (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:466:57)</span><br><span class="line">err:     at Promise._settlePromiseFromHandler (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:559:17)</span><br></pre></td></tr></table></figure>

<p>简单点，显示没有enable这个属性，，，，我懵了，这部署了多少次了，没有出现这么个错误啊。</p>
<p>先删了js，本地跑ok了，远端挂了，又提示另一个js错误。<br>再删一个错误的js,再跑….又挂了!</p>
<h3 id="排查…"><a href="#排查…" class="headerlink" title="排查…"></a>排查…</h3><blockquote>
<p>初步定位为文件没有更到最新</p>
</blockquote>
<p>本地ok,服务器部署不起来…..</p>
<p>查下文件scp copy的工作流</p>
<p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120201117-000817@2x.png"></p>
<p>看起来很简单，也很好用，但是呢，大坑来了……….<br>当时没有选择是否选择覆盖文件：</p>
<p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120201117-001054@2x.png"></p>
<h3 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h3><p>没有覆盖配置文件，导致残留或者修改不彻底，同名的始终不修改，导致的问题。</p>
<p>PS：花了半个小时定位这么个rewrite的问题！ 记着吧，提醒自己….</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://github.com/appleboy/scp-action/blob/master/action.yml#L44">copy workflow Github</a><br><a href="https://github.com/marketplace/actions/scp-files">scp copy workflow</a></p>
]]></content>
      <tags>
        <tag>Day</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>「19」GPM-2.1-调度流程</title>
    <url>/archives/5c6a362f.html</url>
    <content><![CDATA[<p>工欲善其事，必先知其所以然……<br>学习GPM调度之前，先看下源码部分的准备工作吧，不然一脸茫然的看源码，基本不会有太多的收获.</p>
<h3 id="函数-amp-变量初识"><a href="#函数-amp-变量初识" class="headerlink" title="函数&amp; 变量初识"></a>函数&amp; 变量初识</h3><blockquote>
</blockquote>
<a id="more"></a>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><blockquote>
<p>/proc.go</p>
</blockquote>
<ul>
<li>main</li>
<li>sysmon</li>
<li>findrunnable</li>
<li>gopark「1.1」</li>
<li>gosched 「1.2」</li>
<li>mstart</li>
<li>wakep</li>
<li>schedule</li>
<li>cpuinit</li>
<li>schedinit</li>
<li>ready</li>
<li>readgstatus</li>
<li>startm</li>
<li>pollWork</li>
<li>injectglist</li>
<li>park_m</li>
<li>goyield</li>
<li>retake</li>
<li>globrunqput</li>
<li>globrunqputbatch</li>
<li>globrunqputhead</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><blockquote>
<p>/proc.go</p>
</blockquote>
<ul>
<li>m0</li>
<li>g0</li>
<li>allgs</li>
<li>allglock</li>
</ul>
<blockquote>
<p>/runtime2.go</p>
</blockquote>
<ul>
<li>g</li>
<li>p</li>
<li>m</li>
<li>allglen</li>
<li>allm</li>
<li>allp</li>
<li>allpLock</li>
<li>gomaxprocs</li>
<li>sched</li>
</ul>
<blockquote>
<p>/runtime2.go 常量</p>
</blockquote>
<ul>
<li>_Grunnable/_Grunning/_Gwaiting…..</li>
</ul>
<h3 id="上述这些函数-变量-常量-what？"><a href="#上述这些函数-变量-常量-what？" class="headerlink" title="上述这些函数/变量/常量 what？"></a>上述这些函数/变量/常量 what？</h3><p>写这么多，肯定不是简单的从源码仓库里面超出来，这些是一些比较重要的函数，当然还有很多没有罗列，这里主要想记录，也是思考的点：</p>
<ul>
<li>GPM为何会有这么多的状态</li>
<li>这些状态之间是如何配合和协调的</li>
<li>著名的工作偷取「P」是怎么操作的</li>
<li>如果让你设计，你应该会怎么设计GPM这个调度的过程「🏁重点」</li>
</ul>
<h3 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h3><ul>
<li>main:入口函数</li>
<li>sysmon：监控调度线程</li>
<li>schedule：真实的调度器逻辑</li>
<li>m0/g0：特殊的存在体</li>
</ul>
<h3 id="如何开始？"><a href="#如何开始？" class="headerlink" title="如何开始？"></a>如何开始？</h3><blockquote>
<p>简单点，从main开始.</p>
</blockquote>
<h3 id="瞎扯"><a href="#瞎扯" class="headerlink" title="瞎扯"></a>瞎扯</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">看了很长时间的go源码了，觉得一个好的设计，从来不是简单的学习别人的源码，</span><br><span class="line">更多的是学习源码的设计思路和当时设计时是基于哪种场景下的。</span><br><span class="line"></span><br><span class="line">考虑更多的场景，有没有其它的设计思路，可能没有现有的设计更出色，但更加适合别的场景。</span><br></pre></td></tr></table></figure>

<h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续."></a>未完待续.</h3>]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go源码</tag>
        <tag>GPM</tag>
      </tags>
  </entry>
  <entry>
    <title>「18」GPM-1-[初识/设计]</title>
    <url>/archives/b885f9f7.html</url>
    <content><![CDATA[<h3 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h3><p>学go有一段时间了，最近总感觉忙碌无为，也该总结下前段时间读源码的一些心得和体会了。</p>
<p>GPM调度算是在Go中比较经典的了，有必要深入学习下。</p>
<blockquote>
<p><a href="https://golang.org/s/go11sched">Go GPM设计文档</a></p>
</blockquote>
<h3 id="GPM设计的由来"><a href="#GPM设计的由来" class="headerlink" title="GPM设计的由来"></a>GPM设计的由来</h3><p>一个好的设计，总会伴随发现现有的问题，在解决的基础上考虑场景并提高扩展性，先来了解下Go为何要重新设计GPM这个模型：</p>
<a id="more"></a>

<h4 id="现有的问题："><a href="#现有的问题：" class="headerlink" title="现有的问题："></a>现有的问题：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Single global mutex (Sched.Lock) and centralized state. The mutex protects all goroutine-related operations (creation, completion, rescheduling, etc).</span><br><span class="line">2. Goroutine (G) hand-off (G.nextg). Worker threads (M&#39;s) frequently hand-off runnable goroutines between each other, this may lead to increased latencies and additional overheads. Every M must be able to execute any runnable G, in particular the M that just created the G.</span><br><span class="line">3. Per-M memory cache (M.mcache). Memory cache and other caches (stack alloc) are associated with all M&#39;s, while they need to be associated only with M&#39;s running Go code (an M blocked inside of syscall does not need mcache). A ratio between M&#39;s running Go code and all M&#39;s can be as high as 1:100. This leads to excessive resource consumption (each MCache can suck up up to 2M) and poor data locality.</span><br><span class="line">4. Aggressive thread blocking&#x2F;unblocking. In presence of syscalls worker threads are frequently blocked and unblocked. This adds a lot of overhead.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、单一的全局锁和集中的状态.此锁所有g的操作。</span><br><span class="line">2、g退出。工作中的M频繁的交出正在running的g，导致延迟增加和额外的负载。每个M执行任何g，尤其是M自身创建的g。</span><br><span class="line">3、M的内存缓存问题。   内存缓存和其它的缓存关联这所有的M，当他们需要关联M来running code时。比率显示M运行的code和所有M的呈1:100。导致很多资源的浪费和内存的贫瘠。</span><br><span class="line">4、侵略性的加锁，在系统线程频繁的加锁和解锁。这样会造成很大的负载。</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="设计改变"><a href="#设计改变" class="headerlink" title="设计改变"></a>设计改变</h3><blockquote>
<p>以前的设计：<br><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/GPM-1.png"></p>
</blockquote>
<blockquote>
<p>新增Processor</p>
</blockquote>
<p> <img src="https://raw.githubusercontent.com/crab21/Images/master/blog/GPM-2.png"></p>
<h3 id="实现计划"><a href="#实现计划" class="headerlink" title="实现计划"></a>实现计划</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Introduce the P struct (empty for now); implement allp&#x2F;idlep containers (idlep is mutex-protected for starters); associate a P with M running Go code. Global mutex and atomic state is still preserved.</span><br><span class="line">2. Move G freelist to P.</span><br><span class="line">3. Move mcache to P.</span><br><span class="line">4. Move stackalloc to P.</span><br><span class="line">5. Move ncgocall&#x2F;gcstats to P.</span><br><span class="line">&#x2F;&#x2F; work-steal工作窃取模式,仍然在全局锁下。</span><br><span class="line">6. Decentralize run queue, implement work-stealing. Eliminate G hand off. Still under global mutex.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 移除全局锁，实现分散的检测。</span><br><span class="line">7. Remove global mutex, implement distributed termination detection, LockOSThread.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实现自旋替代提示锁「普通锁」。</span><br><span class="line">8. Implement spinning instead of prompt blocking&#x2F;unblocking.</span><br><span class="line">The plan may turn out to not work, there are a lot of unexplored details.</span><br></pre></td></tr></table></figure>

<h3 id="Potential-Improvement"><a href="#Potential-Improvement" class="headerlink" title="Potential Improvement"></a>Potential Improvement</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 后进先出计划。提供公平和优雅的处理g。</span><br><span class="line">1. Try out LIFO scheduling, this will improve locality. However, it still must provide some degree of fairness and gracefully handle yielding goroutines.</span><br><span class="line"></span><br><span class="line"># 不分配内存和栈空间，直到g跑起来。对于一个新创建的g，需要下面几个函数。 这将创建to完成伴随着较低内存的负载。</span><br><span class="line">2. Do not allocate G and stack until the goroutine first runs. For a newly created goroutine we need just callerpc, fn, narg, nret and args, that is, about 6 words. This will allow to create a lot of running-to-completion goroutines with significantly lower memory overhead.</span><br><span class="line"></span><br><span class="line"># 更好的G-P。尝试入队未锁定的G到P，从上一次运行。</span><br><span class="line">4. Better locality of G-to-P. Try to enqueue an unblocked G to a P on which it was last running.</span><br><span class="line"></span><br><span class="line"># 更好的P-M。尝试执行p，在同样的M最后一次运行。</span><br><span class="line">5. Better locality of P-to-M. Try to execute P on the same M it was last running.</span><br><span class="line"></span><br><span class="line"># M限流创建。调度器创建上千哥M在毫秒之间，直到OS拒绝创建更多的thread。M必须立刻创建，最多创建k*GOMAXPROCS,后续新的M会通过定时器创建。</span><br><span class="line">6. Throttling of M creation. The scheduler can be easily forced to create thousands of M&#39;s per second until OS refuses to create more threads. M’s must be created promptly up to k*GOMAXPROCS, after that new M’s may added by a timer.</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><p><a href="https://golang.org/s/go11scheds">GPM g11设计文档</a></p>
</li>
<li><p><a href="http://supertech.csail.mit.edu/papers/steal.pdf">work steal模式</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go源码</tag>
        <tag>GPM</tag>
      </tags>
  </entry>
  <entry>
    <title>「17」chrome headless「截图/PDF/DOM...」</title>
    <url>/archives/5544baea.html</url>
    <content><![CDATA[<blockquote>
<p>最近在搞一个需求：html「文件」渲染成png/jpg；chrome不能装在服务器中，可以打成docker镜像。<br>说到这个，很多人肯定说很容易啊，chrome headless有现成的，直接用，它是不香么。<br>然而事情并没有这么简单；</p>
</blockquote>
<h3 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、服务器中不能装chrome</span><br><span class="line"><span class="number">2</span>、chrome必须打在docker里面</span><br><span class="line"><span class="number">3</span>、渲染效果要和在本地效果一样：图片不能丢失字体，不能失真。</span><br><span class="line"><span class="number">4</span>、不能启动新的服务</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="切入点："><a href="#切入点：" class="headerlink" title="切入点："></a>切入点：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">docker &amp;&amp; chrome</span><br></pre></td></tr></table></figure>

<blockquote>
<p>so先去搜一把有没有现成的可用？</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/20201110-193745.png"></p>
<p>分析分析吧：</p>
<ul>
<li><a href="https://github.com/browserless/chrome">browserless</a></li>
<li><a href="https://github.com/puppeteer/puppeteer">puppeteer</a></li>
<li><a href="https://github.com/prisma-archive/chromeless">prisma-archive</a><br>……….<ul>
<li>适合启动服务，然后进行测试或者跑服务</li>
<li>入参数为url</li>
</ul>
</li>
</ul>
<blockquote>
<p>所以上述的基本不符合需求，再寻找…..</p>
</blockquote>
<h3 id="Zenika-alpine-chrome"><a href="#Zenika-alpine-chrome" class="headerlink" title="Zenika/alpine-chrome"></a><a href="https://github.com/Zenika/alpine-chrome">Zenika/alpine-chrome</a></h3><blockquote>
<p>看起来可行：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/20201110-194452.png"></p>
<p>这个经过验证总会有一个错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1110&#x2F;031547.366909:ERROR:bus.cc(393)] Failed to connect to the bus: Failed to connect to socket &#x2F;var&#x2F;run&#x2F;dbus&#x2F;system_bus_socket: No such file or directory</span><br><span class="line">[1110&#x2F;031547.367451:WARNING:dns_config_service_posix.cc(342)] Failed to read DnsConfig.</span><br><span class="line">[1110&#x2F;031547.437879:WARNING:dns_config_service_posix.cc(342)] Failed to read DnsConfig.</span><br><span class="line">[1110&#x2F;031549.073431:ERROR:headless_shell.cc(591)] Writing to file code&#x2F;ss.png was unsuccessful, could not open file: FILE_ERROR_ACCESS_DENIED</span><br></pre></td></tr></table></figure>

<p>文件没权限哦，尴尬了,再修正：</p>
<blockquote>
<p>发现源码有一段添加了用户，汗，太搞了.</p>
</blockquote>
<p><a href="https://github.com/Zenika/alpine-chrome/blob/master/Dockerfile#L38">点击查看</a></p>
<p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/20201110-194711.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">很郁闷这个chrome用户干嘛的，如果真用这个，那得确定你跑的环境要允许你添加一个user出来，很明显不行,</span><br><span class="line">这样导致整个alpine-chrome服务权限都是乱的「chrome用户的」,最明显的是无法读写文件，因为你这个add chrome没权限。</span><br><span class="line"></span><br><span class="line">最直接的，去掉就好了。</span><br><span class="line"></span><br><span class="line">果然去掉后，跑docker就可以了</span><br></pre></td></tr></table></figure>

<p><a href="https://hub.docker.com/r/zenika/alpine-chrome">docker镜像地址</a></p>
<p>这个是可以了，但是有一个新的问题，图像失真了，再去查github源码，坑那，压根没有装全文字库，只简单装了lib***的库。</p>
<h3 id="再尝试「自己搞个docker-images」"><a href="#再尝试「自己搞个docker-images」" class="headerlink" title="再尝试「自己搞个docker images」"></a>再尝试「自己搞个docker images」</h3><blockquote>
<p>别人都能搞，为何我不可以勒</p>
</blockquote>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><ul>
<li>本地跑这个服务是ok的，那chrome就是依赖macos/linux系统的</li>
<li>那可以搞个linux系统，再装个chrome</li>
<li>最后把字体装完就ok了</li>
<li>最后的最后，想办法直接可以用这个docker，不用启动服务，也就是说docker run之后有了结果，直接rm掉。</li>
</ul>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>1、搞个docker debain系统</li>
<li>2、想办法把chrome装上</li>
<li>3、在里面跑一个测试，看能否生成图片</li>
<li>4、安装缺失的字体</li>
<li>5、container跑起来</li>
<li>6、导出container，再导入到本地的images；让container变成images</li>
<li>7、自己搞个Dockerfile，把「RUN」接口留出来，方便可以直接跑起来</li>
<li>8、再把搞好的images导出来用就可以了。</li>
</ul>
<h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull debian</span><br></pre></td></tr></table></figure>

<h4 id="2-3-4-5"><a href="#2-3-4-5" class="headerlink" title="2/3/4/5"></a>2/3/4/5</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、进入系统</span><br><span class="line">docker exec -it XXXXX &#x2F;bin&#x2F;bash</span><br><span class="line">2、更新源</span><br><span class="line">apt-get update</span><br><span class="line">3、下载wget</span><br><span class="line">apt-get install wget</span><br><span class="line">4、下载chrome linux版本的</span><br><span class="line">wget https:&#x2F;&#x2F;dl.google.com&#x2F;linux&#x2F;direct&#x2F;google-chrome-stable_current_amd64.deb</span><br><span class="line">5、安装chrome</span><br><span class="line"> dpkg -i ******.deb</span><br><span class="line"> 解决依赖关系：</span><br><span class="line">    apt-get -f install</span><br><span class="line">6、跑一把发现汉字变问好「？」了</span><br><span class="line">7、安装缺失的字体</span><br><span class="line">apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy</span><br></pre></td></tr></table></figure>

<h4 id="6导出container"><a href="#6导出container" class="headerlink" title="6导出container"></a>6导出container</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、导出container</span><br><span class="line">docker export container_name &gt; chrome.tar</span><br><span class="line">2、导入到images中</span><br><span class="line">docker load &lt; chrome.tar</span><br></pre></td></tr></table></figure>

<h4 id="7自己搞Dockerfile-预留「RUN」接口"><a href="#7自己搞Dockerfile-预留「RUN」接口" class="headerlink" title="7自己搞Dockerfile,预留「RUN」接口"></a>7自己搞Dockerfile,预留「RUN」接口</h4><p>Dockerfile文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#这个是上一步导入的images</span><br><span class="line">FROM gogoowang&#x2F;chrome:v1</span><br><span class="line">RUN mkdir -p &#x2F;home</span><br><span class="line">WORKDIR &#x2F;home</span><br><span class="line">ENTRYPOINT [&quot;chrome&quot;,&quot;--headless&quot;,&quot;--disable-gpu&quot;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构建成镜像：docker build -t gogoo/chrome:v2 . </p>
</blockquote>
<p>PS:「/home」的含义就是这个images的工作目录是/home文件夹下面</p>
<h4 id="8跑一把，收工"><a href="#8跑一把，收工" class="headerlink" title="8跑一把，收工"></a>8跑一把，收工</h4><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><h4 id="PS-1"><a href="#PS-1" class="headerlink" title="PS-1"></a>PS-1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、错误❌</span><br><span class="line">docker container run -it --rm -v &#x2F;tmp:&#x2F;home gogoowang&#x2F;chrome:v1 --no-sandbox --screenshot --hide-scrollbars &#x2F;XXXX&#x2F;XXXX.html</span><br><span class="line">2、正确</span><br><span class="line">docker container run -i --rm -v &#x2F;tmp:&#x2F;home gogoowang&#x2F;chrome:v1 --no-sandbox --screenshot&#x3D;&#x2F;home&#x2F;xx.png --hide-scrollbars &#x2F;XXXX&#x2F;XXXX.html</span><br><span class="line"></span><br><span class="line">少一个 -t，这个 -t：再搞一个临时的TTy来跑程序，既然是后台跑的，那就没必要了</span><br></pre></td></tr></table></figure>

<h4 id="PS-2"><a href="#PS-2" class="headerlink" title="PS-2"></a>PS-2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container run -i --rm -v &#x2F;tmp:&#x2F;home gogoowang&#x2F;chrome:v1 --no-sandbox --screenshot&#x3D;&#x2F;home&#x2F;xx.png --hide-scrollbars &#x2F;XXXX&#x2F;XXXX.html</span><br><span class="line"></span><br><span class="line">1、关于这个-v的问题,后面就固定了，具体见Dockerfile中</span><br><span class="line">2、--screenshot路径问题，既然是docker镜像，那就得填个docker镜像中的地址，那就是&#x2F;home下面了</span><br></pre></td></tr></table></figure>


<h3 id="优化后一键脚本"><a href="#优化后一键脚本" class="headerlink" title="优化后一键脚本"></a>优化后一键脚本</h3><p>Dockerfile文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM debian</span><br><span class="line">RUN apt-get update </span><br><span class="line">RUN apt-get install -y wget </span><br><span class="line">RUN wget https:&#x2F;&#x2F;dl.google.com&#x2F;linux&#x2F;direct&#x2F;google-chrome-stable_current_amd64.deb </span><br><span class="line">RUN dpkg -i google-chrome-stable_current_amd64.deb || true</span><br><span class="line">RUN apt-get -f -y install</span><br><span class="line">RUN apt-get install -y ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy</span><br><span class="line">RUN mkdir -p &#x2F;home</span><br><span class="line">WORKDIR &#x2F;home</span><br><span class="line">ENTRYPOINT [&quot;&#x2F;opt&#x2F;google&#x2F;chrome&#x2F;chrome&quot;,&quot;--headless&quot;,&quot;--disable-gpu&quot;]</span><br></pre></td></tr></table></figure>
<p>构建：</p>
<blockquote>
<p>docker build -t google-chrome:latest .</p>
</blockquote>
]]></content>
      <tags>
        <tag>Day</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>「16」go源码words归纳</title>
    <url>/archives/425d5e80.html</url>
    <content><![CDATA[<h3 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h3><p>好久没有更新了，不是不更新，最近感冒严重，一直没好，太影响身体了…..「身体还是很重要的!」</p>
<p>当然了，在生病期间也看了很多东西，更多的思考了许多：人生规划的、如何学习技术、后续的生涯发展之类的。「思考的方式很多种，不建议去生病了才去思考.」</p>
<blockquote>
<p>后续会更新一篇，主要是结合之前的成长和技术的壁垒来说说后续想怎么学，怎么发展，生涯规划吧。</p>
</blockquote>
<p>不扯了，这篇主要想记录一些词汇，主要还是在阅读Go源码中的一些词汇，毕竟英文有点差，再不积累就更差了。</p>
<h3 id="Words"><a href="#Words" class="headerlink" title="Words"></a>Words</h3><h4 id="全称"><a href="#全称" class="headerlink" title="全称"></a>全称</h4><a id="more"></a>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">「<span class="number">11</span>/<span class="number">3</span>」</span><br><span class="line">Preempt  v 抢占、掠夺                                   --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">retake   v 重新获取「重新分配」                           --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">syscall  v 系统调用                                     --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">decrement v 递减                                       --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">pretending  v 假装、伪装                                --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">contended  v 竞争                                      --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">procresize  v 扩大                                     --&gt; /proc.<span class="keyword">go</span> </span><br><span class="line">corruption  n 腐败，译：损坏</span><br><span class="line"></span><br><span class="line">「<span class="number">11</span>/<span class="number">5</span>」</span><br><span class="line">assembly  n  装配                                      --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">amortizes  v  缓冲                                     --&gt; /proc.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>


<h4 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">「<span class="number">11</span>/<span class="number">3</span>」</span><br><span class="line">sysmon -&gt; system monitor 系统监控                                               /proc.<span class="keyword">go</span></span><br><span class="line">incidlelocked  --&gt; increment idle locked   增加空闲锁                           /proc.<span class="keyword">go</span></span><br><span class="line">sysmontick  --&gt; system monitor ticket   系统监控数量                            /proc.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<h3 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…."></a>持续更新….</h3>]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
      </tags>
  </entry>
  <entry>
    <title>「14」hexo-安装&amp;插件</title>
    <url>/archives/ae4aba0d.html</url>
    <content><![CDATA[<p>hexo安装及其第三方插件包下载总结，以便后续CI一次到位。</p>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install hexo-renderer-sass --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br><span class="line">npm install request --save</span><br><span class="line">npm install xml-parser --save</span><br><span class="line">npm install yamljs --save</span><br><span class="line">npm install md5 --save</span><br><span class="line">npm install request --save</span><br><span class="line">npm install xml-parser --save</span><br><span class="line">npm install yamljs --save</span><br><span class="line">npm install cheerio --save</span><br><span class="line">npm install blueimp-md5 --save</span><br><span class="line">npm install hexo-abbrlink --save</span><br><span class="line">npm audit fix</span><br><span class="line"></span><br><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br><span class="line">npm audit fix</span><br><span class="line"></span><br><span class="line">npm install hexo-neat --save</span><br><span class="line">npm audit fix</span><br><span class="line">npm install hexo-leancloud-counter-security --save</span><br><span class="line">npm audit fix</span><br></pre></td></tr></table></figure>

<blockquote>
<p>未完待续……</p>
</blockquote>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>「12」go 指针和引用</title>
    <url>/archives/1191d613.html</url>
    <content><![CDATA[<p>今写代码时，传函数无意间想到一个问题，slice通过参数传递给函数，为何可以改变具体的值呢？</p>
<p>如何解决这个问题？</p>
<ul>
<li>官方查文档</li>
<li>看源码</li>
<li>google看看有没有好的见解</li>
<li>思考🤔+冥想🧘‍♂️</li>
</ul>
<p>（ps:解决问题，主要不是看结果是怎么样的，主要是考虑问题的角度）</p>
<a id="more"></a>

<h3 id="查资料"><a href="#查资料" class="headerlink" title="查资料"></a>查资料</h3><p><a href="https://golang.google.cn/doc/effective_go.html#slices">官网指南之Slice</a><br>有一段是这么描述：<br><em>Slices hold references to an underlying array, and if you assign one slice to another, both refer to the same array.</em></p>
<h3 id="查源码"><a href="#查源码" class="headerlink" title="查源码"></a>查源码</h3><h4 id="src-runtime-slice-go"><a href="#src-runtime-slice-go" class="headerlink" title="/src/runtime/slice.go"></a>/src/runtime/slice.go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer  <span class="comment">//指针类型哦</span></span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><blockquote>
<p>原来下层是用过array这个指针，指向具体的数据的</p>
</blockquote>
<blockquote>
<p>那么其他的引用类型呢？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map?</span><br><span class="line">chan?</span><br><span class="line">interface?</span><br><span class="line">&#x2F;&#x2F;Slice?</span><br></pre></td></tr></table></figure>

<h3 id="引用类型之Map"><a href="#引用类型之Map" class="headerlink" title="引用类型之Map"></a>引用类型之Map</h3><h4 id="看源码-src-runtime-map-go："><a href="#看源码-src-runtime-map-go：" class="headerlink" title="看源码 /src/runtime/map.go："></a>看源码 /src/runtime/map.go：</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.</span></span><br><span class="line">	<span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span></span><br><span class="line">	count     <span class="keyword">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">	flags     <span class="keyword">uint8</span></span><br><span class="line">	B         <span class="keyword">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">	noverflow <span class="keyword">uint16</span> <span class="comment">// approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line">	hash0     <span class="keyword">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过此指针类型</span></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">	nevacuate  <span class="keyword">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用类型之Chan"><a href="#引用类型之Chan" class="headerlink" title="引用类型之Chan"></a>引用类型之Chan</h3><h4 id="源码-src-runtime-chan-go"><a href="#源码-src-runtime-chan-go" class="headerlink" title="源码:/src/runtime/chan.go"></a>源码:/src/runtime/chan.go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">    <span class="comment">//通过此指针类型来处理</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">	<span class="comment">// with stack shrinking.</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用类型之Interface"><a href="#引用类型之Interface" class="headerlink" title="引用类型之Interface"></a>引用类型之Interface</h3><h4 id="源码-src-runtime-runtime2-go"><a href="#源码-src-runtime-runtime2-go" class="headerlink" title="源码/src/runtime/runtime2.go"></a>源码/src/runtime/runtime2.go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab</span><br><span class="line">    <span class="comment">//指针类型</span></span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    <span class="comment">//指针类型</span></span><br><span class="line">	data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结论？通过指针？"><a href="#结论？通过指针？" class="headerlink" title="结论？通过指针？"></a>结论？通过指针？</h3><p>从上述源码看来，内部结构中都是用指针类型来指向具体的值，</p>
<blockquote>
<p>So：形同这类的结构，肯定是引用类型的，具体是指针指向别的地址，从而来引用值。</p>
</blockquote>
<p>其实这个特性很早就晓得了，只是今天又看到了，觉得还是记录着吧，也许后续哪一天就有了创新的灵感来着~~.</p>
<p>[睡觉了～最近有点乏～ZZzzz…]</p>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go Package</tag>
        <tag>Day</tag>
      </tags>
  </entry>
  <entry>
    <title>「11」hexo 主题&amp;评论&amp;进度条&amp;背景效果</title>
    <url>/archives/e18c94ab.html</url>
    <content><![CDATA[<p>晚上折腾了下博客，稍微装饰了下，主要还是加了个评论吧，其它非常秀的插件就没有接入了，懒得折腾，好好写博客，内容才是精华。<br>记录下折腾史：</p>
<h3 id="gitalk评论插件"><a href="#gitalk评论插件" class="headerlink" title="gitalk评论插件"></a>gitalk评论插件</h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><h5 id="申请id和secret"><a href="#申请id和secret" class="headerlink" title="申请id和secret"></a>申请id和secret</h5><p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/36f31671-8ada-4cbe-b60b-d1595dd701ee.png"></p>
<a id="more"></a>

<h4 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  github_id: crab21 # GitHub repo owner</span><br><span class="line">  repo: blog # Repository name to store issues</span><br><span class="line">  client_id: XXX # GitHub Application Client ID</span><br><span class="line">  client_secret: XXX # GitHub Application Client Secret</span><br><span class="line">  admin_user: crab21 # GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span><br><span class="line">  distraction_free_mode: true # Facebook-like distraction free mode</span><br><span class="line">  perPage: 15 #每页多少个评论</span><br><span class="line">  pagerDirection: last  #排序方式是从旧到新（first）还是从新到旧（last）</span><br><span class="line">  createIssueManually: true #如果当前页面没有相应的 isssue ，且登录的用户属于 admin，则会自动创建 issue。如果设置为 true，则显示一个初始化页面，创建 issue 需要点击 init 按钮。</span><br><span class="line">  distractionFreeMode: true #是否启用快捷键(cmd|ctrl + enter) 提交评论.</span><br><span class="line"></span><br><span class="line">  # Gitalk&#39;s display language depends on user&#39;s browser or system environment</span><br><span class="line">  # If you want everyone visiting your site to see a uniform language, you can set a force language value</span><br><span class="line">  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span><br><span class="line">  language:</span><br></pre></td></tr></table></figure>

<h3 id="pac阅读进度百分比"><a href="#pac阅读进度百分比" class="headerlink" title="pac阅读进度百分比"></a>pac阅读进度百分比</h3><p>1、github地址： <a href="https://github.com/HubSpot/pace%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E4%B8%8B%E4%BB%8B%E7%BB%8D">https://github.com/HubSpot/pace，可以看下介绍</a><br>2、修改值：<br>    修改主题下面的_config.yml：<br>    <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pace:</span><br><span class="line">    enable: <span class="literal">true</span></span><br><span class="line">    # Themes list:</span><br><span class="line">    # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span><br><span class="line">    # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span><br><span class="line">    theme: minimal</span><br></pre></td></tr></table></figure></p>
<h3 id="reading-progress"><a href="#reading-progress" class="headerlink" title="reading_progress"></a>reading_progress</h3><p>github地址：<a href="https://github.com/theme-next/theme-next-reading-progress">https://github.com/theme-next/theme-next-reading-progress</a></p>
<p>包含使用说明和具体的步骤，就不搬运了，及时调整。</p>
<h3 id="文章字数和阅读时间统计："><a href="#文章字数和阅读时间统计：" class="headerlink" title="文章字数和阅读时间统计："></a>文章字数和阅读时间统计：</h3><p>hexo配置文件中修改：<br>    <code>symbols_count_time</code> 为true.</p>
<h3 id="back2top"><a href="#back2top" class="headerlink" title="back2top"></a>back2top</h3><p>开启模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: true</span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure>
<h3 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h3><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>hexo插件</tag>
      </tags>
  </entry>
  <entry>
    <title>「10」go mutex解读</title>
    <url>/archives/ff0d6c2b.html</url>
    <content><![CDATA[<p>上次说到rwmutex读写锁，其实就是加强了锁的粒度，区分读和写时不同的情况，核心思想：写优先于读。<br>这次来看看mutex，go中的锁是如何实现的，用一张图来概括整个流程：</p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/mutex.png"></p>
<blockquote>
<p>核心思想：饥饿和队列，正常流程都是加入到队列尾部，如果超过一定的时间限制则加入到队列头部。</p>
</blockquote>
<h3 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h3><blockquote>
<p>开始看代码或者分析之前，先看下文档说明及其相关的资料。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">◯  go version</span><br><span class="line">go version go1.14.9 darwin&#x2F;amd64</span><br></pre></td></tr></table></figure>

<h3 id="src-sync-mutex-go"><a href="#src-sync-mutex-go" class="headerlink" title="src/sync/mutex.go"></a>src/sync/mutex.go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked      state &amp; mutexLocked 1==加锁  0==未加锁</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	mutexWoken                                      <span class="comment">//state &amp; mutexWoken 1==唤醒  0==未唤醒</span></span><br><span class="line">	mutexStarving                                   <span class="comment">// state &amp; mutexStarving 1==饥饿状态   0==正常状态</span></span><br><span class="line">	mutexWaiterShift = <span class="literal">iota</span>                         <span class="comment">// state &gt;&gt; mutexWaiterShift得到当前的goroutine数量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mutex fairness.</span></span><br><span class="line">	<span class="comment">// 两种模式：正常或饥饿</span></span><br><span class="line">    <span class="comment">// Mutex can be in 2 modes of operations: normal and starvation.</span></span><br><span class="line">    <span class="comment">//  正常模式就是FIFO队列。</span></span><br><span class="line">	<span class="comment">// In normal mode waiters are queued in FIFO order, but a woken up waiter</span></span><br><span class="line">	<span class="comment">// does not own the mutex and competes with new arriving goroutines over</span></span><br><span class="line">	<span class="comment">// the ownership. New arriving goroutines have an advantage -- they are</span></span><br><span class="line">	<span class="comment">// already running on CPU and there can be lots of them, so a woken up</span></span><br><span class="line">	<span class="comment">// waiter has good chances of losing. In such case it is queued at front</span></span><br><span class="line">	<span class="comment">// of the wait queue. If a waiter fails to acquire the mutex for more than 1ms,  //获取锁的时间超过1ms，切换到饥饿模式</span></span><br><span class="line">	<span class="comment">// it switches mutex to the starvation mode.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// In starvation mode ownership of the mutex is directly handed off from        //饥饿模式下锁的所有权直接从解锁goroutine的waiter手中移交到队列的前面。</span></span><br><span class="line">	<span class="comment">// the unlocking goroutine to the waiter at the front of the queue.</span></span><br><span class="line">	<span class="comment">// New arriving goroutines don&#x27;t try to acquire the mutex even if it appears</span></span><br><span class="line">	<span class="comment">// to be unlocked, and don&#x27;t try to spin. Instead they queue themselves at</span></span><br><span class="line">	<span class="comment">// the tail of the wait queue.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If a waiter receives ownership of the mutex and sees that either         //如果一个锁的所有权的等待者是以下两种情况之一的：1、处于队列的最后一个2、等待时间少于1ms，则切换到正常模式</span></span><br><span class="line">	<span class="comment">// (1) it is the last waiter in the queue, or (2) it waited for less than 1 ms,</span></span><br><span class="line">	<span class="comment">// it switches mutex back to normal operation mode.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Normal mode has considerably better performance as a goroutine can acquire</span></span><br><span class="line">	<span class="comment">// a mutex several times in a row even if there are blocked waiters.</span></span><br><span class="line">	<span class="comment">// Starvation mode is important to prevent pathological cases of tail latency.</span></span><br><span class="line">	starvationThresholdNs = <span class="number">1e6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a>加锁流程</h3><blockquote>
<p>加锁过程图如上图提到的流程。</p>
</blockquote>
<blockquote>
<p>加锁代码具体流程：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">		<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">			race.Acquire(unsafe.Pointer(m))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">	m.lockSlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">lockSlow</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> waitStartTime <span class="keyword">int64</span> <span class="comment">//等待时间</span></span><br><span class="line">	starving := <span class="literal">false</span>       <span class="comment">//是否处于饥饿状态</span></span><br><span class="line">	awoke := <span class="literal">false</span>          <span class="comment">//唤醒状态</span></span><br><span class="line">	iter := <span class="number">0</span>               <span class="comment">//自旋次数</span></span><br><span class="line">	old := m.state          <span class="comment">//当前状态copy</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Don&#x27;t spin in starvation mode, ownership is handed off to waiters</span></span><br><span class="line">        <span class="comment">// so we won&#x27;t be able to acquire the mutex anyway.</span></span><br><span class="line">        <span class="comment">//加锁且能够自旋</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">			<span class="comment">// Active spinning makes sense.</span></span><br><span class="line">			<span class="comment">// Try to set mutexWoken flag to inform Unlock</span></span><br><span class="line">            <span class="comment">// to not wake other blocked goroutines.</span></span><br><span class="line">            <span class="comment">//自旋过程发现没有被置woken标识，设置标识，将自己置为唤醒</span></span><br><span class="line">			<span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">				awoke = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			runtime_doSpin()    <span class="comment">//自旋</span></span><br><span class="line">			iter++              </span><br><span class="line">			old = m.state       <span class="comment">//状态重置</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新状态</span></span><br><span class="line">		<span class="built_in">new</span> := old</span><br><span class="line">        <span class="comment">// Don&#x27;t try to acquire starving mutex, new arriving goroutines must queue.</span></span><br><span class="line">        <span class="comment">//非饥饿模式，则置锁</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> |= mutexLocked</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处于饥饿模式下，新来的goroutine进入队列中</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// The current goroutine switches mutex to starvation mode.</span></span><br><span class="line">		<span class="comment">// But if the mutex is currently unlocked, don&#x27;t do the switch.</span></span><br><span class="line">		<span class="comment">// Unlock expects that starving mutex has waiters, which will not</span></span><br><span class="line">        <span class="comment">// be true in this case.</span></span><br><span class="line">        <span class="comment">//切换到饥饿模式下</span></span><br><span class="line">		<span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> |= mutexStarving</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前处于唤醒状态，则重置清除唤醒状态。</span></span><br><span class="line">		<span class="keyword">if</span> awoke &#123;</span><br><span class="line">			<span class="comment">// The goroutine has been woken from sleep,</span></span><br><span class="line">			<span class="comment">// so we need to reset the flag in either case.</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//CAS更新状态。</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">//获取到锁</span></span><br><span class="line">			<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// If we were already waiting before, queue at the front of the queue.</span></span><br><span class="line">            <span class="comment">//等待队列的时间</span></span><br><span class="line">			queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">			<span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">				waitStartTime = runtime_nanotime()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//acquire阻塞队列....</span></span><br><span class="line">            <span class="comment">// 新来的 goroutine, queueLifo=false, 加入到等待队列的尾部，耐心等待</span></span><br><span class="line">            <span class="comment">// 唤醒的 goroutine, queueLifo=true, 加入到等待队列的头部</span></span><br><span class="line">			runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">            old = m.state</span><br><span class="line">            <span class="comment">//处于饥饿模式</span></span><br><span class="line">			<span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// If this goroutine was woken and mutex is in starvation mode,</span></span><br><span class="line">				<span class="comment">// ownership was handed off to us but mutex is in somewhat</span></span><br><span class="line">				<span class="comment">// inconsistent state: mutexLocked is not set and we are still</span></span><br><span class="line">				<span class="comment">// accounted as waiter. Fix that.</span></span><br><span class="line">				<span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">					throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//等待的goroutine-1</span></span><br><span class="line">                delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">                <span class="comment">// 处于队列中最后一个或者请求锁的时间未超过starvationThresholdNs，则回退到正常模式。</span></span><br><span class="line">				<span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">					<span class="comment">// Exit starvation mode.</span></span><br><span class="line">					<span class="comment">// Critical to do it here and consider wait time.</span></span><br><span class="line">					<span class="comment">// Starvation mode is so inefficient, that two goroutines</span></span><br><span class="line">					<span class="comment">// can go lock-step infinitely once they switch mutex</span></span><br><span class="line">					<span class="comment">// to starvation mode.</span></span><br><span class="line">					delta -= mutexStarving</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新状态</span></span><br><span class="line">				atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重置迭代器和唤醒表示，继续获取锁</span></span><br><span class="line">			awoke = <span class="literal">true</span></span><br><span class="line">			iter = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//CAS失败，则更新状态，继续获取。</span></span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Acquire(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h3><p>用一个流程图来表示解锁过程：</p>
<p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/mutex-unlock.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//state 不是处于锁的状态, 那么就是 Unlock 根本没有加锁的 mutex, panic</span></span><br><span class="line">    <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁，并通知其它等待者</span></span><br><span class="line">    <span class="comment">// 锁如果处于饥饿状态，直接交给等待队列的第一个, 唤醒它，让它去获取锁</span></span><br><span class="line">    <span class="comment">// mutex 正常模式</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">        old := <span class="built_in">new</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有等待者，或者已经存在一个 goroutine 被唤醒或得到锁、或处于饥饿模式</span></span><br><span class="line">            <span class="comment">// 直接返回.</span></span><br><span class="line">            <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将等待的 goroutine-1，并设置 woken 标识</span></span><br><span class="line">            <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">            <span class="comment">// 设置新的 state, 这里通过信号量会唤醒一个阻塞的 goroutine 去获取锁.</span></span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">                runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// mutex 饥饿模式，直接将 mutex 拥有权移交给等待队列最前端的 goroutine</span></span><br><span class="line">        <span class="comment">// 注意此时 state 的 mutex 还没有加锁，唤醒的 goroutine 会设置它。</span></span><br><span class="line">        <span class="comment">// 在此期间，如果有新的 goroutine 来请求锁， 因为 mutex 处于饥饿状态， mutex 还是被认为处于锁状态，</span></span><br><span class="line">        <span class="comment">// 新来的 goroutine 不会把锁抢过去.</span></span><br><span class="line">        runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>不要重复锁定互斥锁</li>
<li>不要忘记解锁互斥锁</li>
<li>不要在多个函数之间直接传递互斥锁</li>
</ul>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go源码</tag>
        <tag>Go Package</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>「9」Go reflect ~ DeepEqual</title>
    <url>/archives/e2e7cc4e.html</url>
    <content><![CDATA[<p>今天无意中看到Go101发了一个推特:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  fmt.Print(<span class="string">&quot;:&quot;</span>, reflect.DeepEqual(a, b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := [<span class="number">1</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;&#125;&#125;</span><br><span class="line">  p(a, a)</span><br><span class="line">  p(a[:], a[:])</span><br><span class="line">  b := a</span><br><span class="line">  p(a[:], b[:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果？？ :true:true:false</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>正确答案 :false:true:false</p>
</blockquote>
<h3 id="错误来源"><a href="#错误来源" class="headerlink" title="错误来源"></a>错误来源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一个为啥想着为true,第一眼看过去，比较两个a的函数，那两个函数肯定是相等的，这是第一直觉(狗屁直觉).</span><br><span class="line">第二个两个都为nil了，这个是没有什么问题，两个nil肯定是deep相等的。</span><br><span class="line">第三个虽然是重新初始化了，所以两个肯定不是deep相等的。</span><br></pre></td></tr></table></figure>

<h3 id="思路比对（错在哪里）"><a href="#思路比对（错在哪里）" class="headerlink" title="思路比对（错在哪里）"></a>思路比对（错在哪里）</h3><p>查阅文档之后，发现理解错了：</p>
<p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/20200918-124746.png"></p>
<h3 id="DeepEqual正确理解"><a href="#DeepEqual正确理解" class="headerlink" title="DeepEqual正确理解"></a>DeepEqual正确理解</h3><blockquote>
<p>源码也很简洁：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeepEqual</span><span class="params">(x, y <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">//同nil</span></span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> || y == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x == y</span><br><span class="line">	&#125;</span><br><span class="line">	v1 := ValueOf(x)</span><br><span class="line">  v2 := ValueOf(y)</span><br><span class="line">  <span class="comment">//属于同一类型</span></span><br><span class="line">	<span class="keyword">if</span> v1.Type() != v2.Type() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> deepValueEqual(v1, v2, <span class="built_in">make</span>(<span class="keyword">map</span>[visit]<span class="keyword">bool</span>), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面看源码，主要还是要看官方的文档和说明性的，这个算是理解源码的前提把：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DeepEqual reports whether x and y are ``deeply equal,&#x27;&#x27; defined as follows.</span></span><br><span class="line"><span class="comment">// Two values of identical type are deeply equal if one of the following cases applies.</span></span><br><span class="line"><span class="comment">// Values of distinct types are never deeply equal.</span></span><br><span class="line"><span class="comment">//  条件：数组深度相等，相应的元素都是相等的。</span></span><br><span class="line"><span class="comment">// Array values are deeply equal when their corresponding elements are deeply equal.</span></span><br><span class="line"><span class="comment">//  条件：结构体相对应的字段都是相等的。</span></span><br><span class="line"><span class="comment">// Struct values are deeply equal if their corresponding fields,</span></span><br><span class="line"><span class="comment">// both exported and unexported, are deeply equal.</span></span><br><span class="line"><span class="comment">// 条件：函数都是nil，则为深度相等，其它情况下都是不相等的。</span></span><br><span class="line"><span class="comment">// Func values are deeply equal if both are nil; otherwise they are not deeply equal.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 条件：两个interface持有深度相同的值。</span></span><br><span class="line"><span class="comment">// Interface values are deeply equal if they hold deeply equal concrete values.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    条件：下面条件为<span class="literal">true</span>，则深度相等：</span><br><span class="line">    两个全是<span class="literal">nil</span>，或者全non-<span class="literal">nil</span>，有相同的长度并且有相同的对象/key对应的值是相等的。</span><br><span class="line"><span class="comment">// Map values are deeply equal when all of the following are true:</span></span><br><span class="line"><span class="comment">// they are both nil or both non-nil, they have the same length,</span></span><br><span class="line"><span class="comment">// and either they are the same map object or their corresponding keys</span></span><br><span class="line"><span class="comment">// (matched using Go equality) map to deeply equal values.</span></span><br><span class="line">    条件：用 == 比较或者 point的</span><br><span class="line"><span class="comment">// Pointer values are deeply equal if they are equal using Go&#x27;s == operator</span></span><br><span class="line"><span class="comment">// or if they point to deeply equal values.</span></span><br><span class="line">    条件：下面条件为<span class="literal">true</span>，则深度相等：</span><br><span class="line">    两个全是<span class="literal">nil</span>，或者全non-<span class="literal">nil</span>，有相同的长度，指向相同的初始化节点（即：相同的数组）或相同的元素深度相等。</span><br><span class="line">    注意：empty和<span class="literal">nil</span> slice不是深度相等的。</span><br><span class="line"><span class="comment">// Slice values are deeply equal when all of the following are true:</span></span><br><span class="line"><span class="comment">// they are both nil or both non-nil, they have the same length,</span></span><br><span class="line"><span class="comment">// and either they point to the same initial entry of the same underlying array</span></span><br><span class="line"><span class="comment">// (that is, &amp;x[0] == &amp;y[0]) or their corresponding elements (up to length) are deeply equal.</span></span><br><span class="line"><span class="comment">// Note that a non-nil empty slice and a nil slice (for example, []byte&#123;&#125; and []byte(nil))</span></span><br><span class="line"><span class="comment">// are not deeply equal.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Other values - numbers, bools, strings, and channels - are deeply equal</span></span><br><span class="line"><span class="comment">// if they are equal using Go&#x27;s == operator.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In general DeepEqual is a recursive relaxation of Go&#x27;s == operator.</span></span><br><span class="line"><span class="comment">// However, this idea is impossible to implement without some inconsistency.</span></span><br><span class="line"><span class="comment">// Specifically, it is possible for a value to be unequal to itself,</span></span><br><span class="line"><span class="comment">// either because it is of func type (uncomparable in general)</span></span><br><span class="line"><span class="comment">// or because it is a floating-point NaN value (not equal to itself in floating-point comparison),</span></span><br><span class="line"><span class="comment">// or because it is an array, struct, or interface containing</span></span><br><span class="line"><span class="comment">// such a value.</span></span><br><span class="line"><span class="comment">// On the other hand, pointer values are always equal to themselves,</span></span><br><span class="line"><span class="comment">// even if they point at or contain such problematic values,</span></span><br><span class="line"><span class="comment">// because they compare equal using Go&#x27;s == operator, and that</span></span><br><span class="line"><span class="comment">// is a sufficient condition to be deeply equal, regardless of content.</span></span><br><span class="line"><span class="comment">// DeepEqual has been defined so that the same short-cut applies</span></span><br><span class="line"><span class="comment">// to slices and maps: if x and y are the same slice or the same map,</span></span><br><span class="line"><span class="comment">// they are deeply equal regardless of content.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// As DeepEqual traverses the data values it may find a cycle. The</span></span><br><span class="line"><span class="comment">// second and subsequent times that DeepEqual compares two pointer</span></span><br><span class="line"><span class="comment">// values that have been compared before, it treats the values as</span></span><br><span class="line"><span class="comment">// equal rather than examining the values to which they point.</span></span><br><span class="line"><span class="comment">// This ensures that DeepEqual terminates.</span></span><br></pre></td></tr></table></figure>

<p>再看看详细的deepValueEqual,大致的过程：<br><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/20200920-103516@2x.png"></p>
<blockquote>
<p>大致分为三个过程：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、判断类型和值</span><br><span class="line">2、hard回调</span><br><span class="line">3、按照kind分类处理</span><br></pre></td></tr></table></figure>

<h4 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h4><p>比较每一个元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v1.Len(); i++ &#123;</span><br><span class="line">	<span class="keyword">if</span> !deepValueEqual(v1.Index(i), v2.Index(i), visited, depth+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h4><ul>
<li>比较为nil</li>
<li>比较长度</li>
<li>比较地址</li>
<li>比较每一个元素<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> v1.IsNil() != v2.IsNil() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v1.Len() != v2.Len() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v1.Pointer() == v2.Pointer() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v1.Len(); i++ &#123;</span><br><span class="line">	<span class="keyword">if</span> !deepValueEqual(v1.Index(i), v2.Index(i), visited, depth+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h4><ul>
<li>比较nil</li>
<li>递归比较<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> v1.IsNil() || v2.IsNil() &#123;</span><br><span class="line">	<span class="keyword">return</span> v1.IsNil() == v2.IsNil()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> deepValueEqual(v1.Elem(), v2.Elem(), visited, depth+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Ptr"><a href="#Ptr" class="headerlink" title="Ptr"></a>Ptr</h4></li>
<li>地址</li>
<li>递归比较<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> v1.Pointer() == v2.Pointer() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> deepValueEqual(v1.Elem(), v2.Elem(), visited, depth+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h4><ul>
<li>比较每一个元素<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> i, n := <span class="number">0</span>, v1.NumField(); i &lt; n; i++ &#123;</span><br><span class="line">	<span class="keyword">if</span> !deepValueEqual(v1.Field(i), v2.Field(i), visited, depth+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul>
<li>比较Nil</li>
<li>比较长度</li>
<li>地址比较</li>
<li>每一个key对应的value</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> v1.IsNil() != v2.IsNil() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v1.Len() != v2.Len() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v1.Pointer() == v2.Pointer() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> v1.MapKeys() &#123;</span><br><span class="line">	val1 := v1.MapIndex(k)</span><br><span class="line">	val2 := v2.MapIndex(k)</span><br><span class="line">	<span class="keyword">if</span> !val1.IsValid() || !val2.IsValid() || !deepValueEqual(val1, val2, visited, depth+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="Func"><a href="#Func" class="headerlink" title="Func"></a>Func</h4><ul>
<li>非nil，为不等。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> v1.IsNil() &amp;&amp; v2.IsNil() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Can&#x27;t do better than this:</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="painc注意点："><a href="#painc注意点：" class="headerlink" title="painc注意点："></a>painc注意点：</h3><p> deepValueEqual函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> .....</span><br><span class="line"> ....</span><br><span class="line"> ...</span><br><span class="line"> ..</span><br><span class="line"> .</span><br><span class="line"> 递归次数超过<span class="number">10</span>次则会painc....</span><br><span class="line"> <span class="comment">// if depth &gt; 10 &#123; panic(&quot;deepValueEqual&quot;) &#125;	// for debugging</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We want to avoid putting more in the visited map than we need to.</span></span><br><span class="line"><span class="comment">// For any possible reference cycle that might be encountered,</span></span><br><span class="line"><span class="comment">// hard(v1, v2) needs to return true for at least one of the types in the cycle,</span></span><br><span class="line"><span class="comment">// and it&#x27;s safe and valid to get Value&#x27;s internal pointer.</span></span><br><span class="line">hard := <span class="function"><span class="keyword">func</span><span class="params">(v1, v2 Value)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> v1.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> Map, Slice, Ptr, Interface:</span><br><span class="line">		<span class="comment">// Nil pointers cannot be cyclic. Avoid putting them in the visited map.</span></span><br><span class="line">		<span class="keyword">return</span> !v1.IsNil() &amp;&amp; !v2.IsNil()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"> &#125;</span><br><span class="line"> .</span><br><span class="line"> ..</span><br><span class="line"> ...</span><br><span class="line"> ....</span><br><span class="line"> .....</span><br><span class="line"> ......</span><br></pre></td></tr></table></figure>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go Package</tag>
        <tag>Day</tag>
        <tag>Go reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>「8」go rwmutex解读</title>
    <url>/archives/3038b6c3.html</url>
    <content><![CDATA[<pre><code>好久没有更新文章了，表达能力生疏了许多😄....
今天扯扯:rwmutex 被称为读写锁。一说到【锁】最直接的联想可能就是lock()、Rlock()、unlock()、Runlock()之类的，但是作为程序猿，还是要了解下底层的设计和相关的逻辑实现，以便于把这种锁的设计思想应用到其它场景中，好了，不废话了，开题吧。
从锁的结构设计--&gt;加锁的过程---&gt;加锁的粒度----&gt;解锁释放，整个生命周期来看rwmutex的具体实现。</code></pre>
<a id="more"></a>
<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">◯  go version</span><br><span class="line">go version go1.14.9 darwin&#x2F;amd64</span><br></pre></td></tr></table></figure>

<h3 id="同向对比rwmutex锁的设计"><a href="#同向对比rwmutex锁的设计" class="headerlink" title="同向对比rwmutex锁的设计"></a>同向对比rwmutex锁的设计</h3><pre><code>java实现：AQS(AbstractQueuedSynchronizer)</code></pre>
<h3 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h3><blockquote>
<p>原则：读写互斥，优先写。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	w           Mutex  <span class="comment">// held if there are pending writers</span></span><br><span class="line">	writerSem   <span class="keyword">uint32</span> <span class="comment">// semaphore for writers to wait for completing readers  写信号量</span></span><br><span class="line">	readerSem   <span class="keyword">uint32</span> <span class="comment">// semaphore for readers to wait for completing writers  读信号量</span></span><br><span class="line">	readerCount <span class="keyword">int32</span>  <span class="comment">// number of pending readers 读计数</span></span><br><span class="line">	readerWait  <span class="keyword">int32</span>  <span class="comment">// number of departing readers   读等待（write进行）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span>   <span class="comment">//最大读锁的个数</span></span><br></pre></td></tr></table></figure>

<p>其它再分类就是四个主要的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RLock</span><br><span class="line">RUnLock</span><br><span class="line">Lock</span><br><span class="line">UnLock</span><br></pre></td></tr></table></figure>
<h3 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h3><h4 id="RLock过程"><a href="#RLock过程" class="headerlink" title="RLock过程"></a>RLock过程</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Disable()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果写锁被获取的，则readerCount&lt;0的，阻塞状态</span></span><br><span class="line">    <span class="comment">//如果写锁没有被获取，则readerCount &gt;0的，获取读锁，不阻塞</span></span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// A writer is pending, wait for it. </span></span><br><span class="line">        <span class="comment">//写锁被获取了，加到G队列后面，挂起。</span></span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Lock过程"><a href="#Lock过程" class="headerlink" title="Lock过程"></a>Lock过程</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lock locks rw for writing.</span></span><br><span class="line"><span class="comment">// If the lock is already locked for reading or writing,</span></span><br><span class="line"><span class="comment">// Lock blocks until the lock is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// First, resolve competition with other writers.</span></span><br><span class="line">    <span class="comment">//使用mutex锁</span></span><br><span class="line">	rw.w.Lock()</span><br><span class="line">	<span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">	<span class="comment">// Wait for active readers.</span></span><br><span class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//等待活跃的reader结束后，再给一个写的信号量，保证此刻之后的reader挂起。</span></span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加锁的粒度"><a href="#加锁的粒度" class="headerlink" title="加锁的粒度"></a>加锁的粒度</h3><blockquote>
<p>读 &amp; 写 互不干扰.</p>
</blockquote>
<h3 id="解锁释放"><a href="#解锁释放" class="headerlink" title="解锁释放"></a>解锁释放</h3><h4 id="RUnLock"><a href="#RUnLock" class="headerlink" title="RUnLock"></a>RUnLock</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">		race.Disable()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写锁等待状态，检查当前是否可以进行获取</span></span><br><span class="line">	<span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Outlined slow-path to allow the fast-path to be inlined</span></span><br><span class="line">		rw.rUnlockSlow(r)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">rUnlockSlow</span><span class="params">(r <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// r + 1 == 0表示直接执行RUnlock()</span></span><br><span class="line">	<span class="comment">// r + 1 == -rwmutexMaxReaders表示执行Lock()再执行RUnlock()</span></span><br><span class="line">	<span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		throw(<span class="string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// A writer is pending.</span></span><br><span class="line">    <span class="comment">// 当读锁释放完毕后，通知写锁</span></span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// The last reader unblocks the writer.</span></span><br><span class="line">		runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="UnLock"><a href="#UnLock" class="headerlink" title="UnLock"></a>UnLock</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Release(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Announce to readers there is no active writer.</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">    <span class="comment">//说明这个没有枷锁，没法再次释放</span></span><br><span class="line">	<span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		throw(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// Unblock blocked readers, if any.</span></span><br><span class="line">    <span class="comment">//释放所有的锁。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</span><br><span class="line">		runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Allow other writers to proceed.</span></span><br><span class="line">	rw.w.Unlock()</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>读&amp;写，互不干扰。</p>
</blockquote>
<ul>
<li><p>读锁不能阻塞读锁，引入readerCount.</p>
</li>
<li><p>读锁需要阻塞写锁，直到所以读锁都释放，引入readerSem.</p>
</li>
<li><p>写锁需要阻塞读锁，直到所以写锁都释放，引入wirterSem.</p>
</li>
<li><p>写锁需要阻塞写锁，引入Metux.</p>
</li>
</ul>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go源码</tag>
        <tag>Go Package</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>「7」Go Context包使用</title>
    <url>/archives/410dfaec.html</url>
    <content><![CDATA[<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">◯  go version</span><br><span class="line">go version go1.14.9 darwin&#x2F;amd64</span><br></pre></td></tr></table></figure>

<h3 id="用Go的都离不开Context，引用官网的一句话来描述Context包："><a href="#用Go的都离不开Context，引用官网的一句话来描述Context包：" class="headerlink" title="用Go的都离不开Context，引用官网的一句话来描述Context包："></a>用Go的都离不开Context，引用官网的一句话来描述Context包：</h3><blockquote>
<p>Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.</p>
</blockquote>
<p>主要掌握四个方法的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WithCancel</span><br><span class="line">WithDeadline</span><br><span class="line">WithTimeout</span><br><span class="line">WithValue</span><br></pre></td></tr></table></figure>
<h3 id="前期ready"><a href="#前期ready" class="headerlink" title="前期ready"></a>前期ready</h3><p>要用下面的方法，先了解下部分结构和逻辑：</p>
<blockquote>
<p>既然context全部都是和取消相关的，最起码Go在设计时会有这么一个结构。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>具体的取消设计结构</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type cancelCtx struct &#123;</span><br><span class="line">	Context</span><br><span class="line"></span><br><span class="line">	mu       sync.Mutex            &#x2F;&#x2F; protects following fields  加锁用</span><br><span class="line">	done     chan struct&#123;&#125;         &#x2F;&#x2F; created lazily, closed by first cancel call   控制channel</span><br><span class="line">	children map[canceler]struct&#123;&#125; &#x2F;&#x2F; set to nil by the first cancel call  cancel函数调用后，释放子类</span><br><span class="line">	err      error                 &#x2F;&#x2F; set to non-nil by the first cancel call</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>timer控制死锁时间结构：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; A timerCtx carries a timer and a deadline. It embeds a cancelCtx to</span><br><span class="line">&#x2F;&#x2F; implement Done and Err. It implements cancel by stopping its timer then</span><br><span class="line">&#x2F;&#x2F; delegating to cancelCtx.cancel.</span><br><span class="line"></span><br><span class="line">type timerCtx struct &#123;</span><br><span class="line">	cancelCtx  </span><br><span class="line">	timer *time.Timer &#x2F;&#x2F; Under cancelCtx.mu.</span><br><span class="line"></span><br><span class="line">	deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">    if parent &#x3D;&#x3D; nil &#123;  &#x2F;&#x2F;日常判空</span><br><span class="line">		panic(&quot;cannot create context from nil parent&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	c :&#x3D; newCancelCtx(parent) &#x2F;&#x2F;cancelCtx new</span><br><span class="line">	propagateCancel(parent, &amp;c)  &#x2F;&#x2F;循环传播取消函数for ctx</span><br><span class="line">	return &amp;c, func() &#123; c.cancel(true, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看似很简单，四行解决，但是更重要的是学会看注释说明和相关的设计思路：<br>TODO </p>
</blockquote>
<p>引用官方的语言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; WithCancel returns a copy of parent with a new Done channel. The returned</span><br><span class="line">&#x2F;&#x2F; context&#39;s Done channel is closed when the returned cancel function is called</span><br><span class="line">&#x2F;&#x2F; or when the parent context&#39;s Done channel is closed, whichever happens first.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Canceling this context releases resources associated with it, so code should</span><br><span class="line">&#x2F;&#x2F; call cancel as soon as the operations running in this Context complete.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Withcancel 返回的是一个parent的镜像&#x2F;复制，伴随一个Done channel通道。</span><br><span class="line">Done关闭状态取决于</span><br><span class="line">1、返回的cancel函数。</span><br><span class="line">2、parent的Done Channel关闭。</span><br><span class="line">这两个哪个先符合条件了。</span><br></pre></td></tr></table></figure>

<h3 id="WithDeadline-WithTimeout"><a href="#WithDeadline-WithTimeout" class="headerlink" title="WithDeadline/WithTimeout"></a>WithDeadline/WithTimeout</h3><p>自己梳理的逻辑执行顺序：</p>
<p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/20200907-152032.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Deadline&#x2F;WithTimeout区别：</span><br><span class="line"></span><br><span class="line">* deadline:的入参是一个具体的截止时间：Time.time</span><br><span class="line">* withTimeout:入参是一个多少时间后超时：Time.Duration</span><br></pre></td></tr></table></figure>

<h3 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h3><blockquote>
<p>Withvalue和value是成对出现的:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、给ctx设置k,v：withvalue(ctx,k,v)</span><br><span class="line">2、获取ctx中k的值value(ctx,k)</span><br></pre></td></tr></table></figure>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><h4 id="timerCtx详细的设计思路和结构文档"><a href="#timerCtx详细的设计思路和结构文档" class="headerlink" title="timerCtx详细的设计思路和结构文档"></a>timerCtx详细的设计思路和结构文档</h4><h4 id="框架图整理"><a href="#框架图整理" class="headerlink" title="框架图整理"></a>框架图整理</h4><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go Package</tag>
      </tags>
  </entry>
  <entry>
    <title>「6」git 初阶:安装配置 ～1</title>
    <url>/archives/bddc30f6.html</url>
    <content><![CDATA[<blockquote>
<p>自盘古开天辟地～～～～<br>扯远了……<br>完整的分享下Git的使用和学习的知识点，之前章节中的<a href="http://blog.imrcrab.com/2020/09/01/Git%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">Git常用技巧</a>是我之前部分快速使用的场景，适合于有经验的开发者，现在来系统的分享下对于Git的理解，也算是自己学习的记录。</p>
</blockquote>
<h2 id="前景"><a href="#前景" class="headerlink" title="前景"></a>前景</h2><p>SVN估计是家喻户晓了，一直被用作<code>&#39;版本管理&#39;</code>和<code>代码仓库</code>。（ps:不算是完整的<code>版本管理</code>.）<br>Git的出现，是linus之父休假时产出的“作品”,<code>版本管理</code> &amp; <code>代码仓库</code>的作用。总而言之，用熟练Git了，就再也回不去了。</p>
<a id="more"></a>

<h2 id="掌握目标："><a href="#掌握目标：" class="headerlink" title="掌握目标："></a>掌握目标：</h2><blockquote>
<p>最终可以顺利的提交代码即可。</p>
</blockquote>
<h2 id="此篇只分享两个知识点："><a href="#此篇只分享两个知识点：" class="headerlink" title="此篇只分享两个知识点："></a>此篇只分享两个知识点：</h2><blockquote>
<p>安装Git和Git基本配置</p>
</blockquote>
<h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><p>说安装其实就是去官网下载软件，安装到你选定地方即可。</p>
<p>在此附上官网的下载链接： <a href="https://git-scm.com/download/">点击进入</a></p>
<p>选择对应平台windows?linux?macos?  </p>
<p>ps:别选错了，那就very尴尬了。</p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>说到基本配置，大多数都会有，更何况是如此强大的版本控制软件。</p>
<h4 id="前期基本配置"><a href="#前期基本配置" class="headerlink" title="前期基本配置"></a>前期基本配置</h4><p>主要分三个地方：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、&#x2F;etc&#x2F;gitconfig 文件: 系统上每一个用户及其他们的仓库配置文件。</span><br><span class="line">2、~&#x2F;.gitconfig 或 ~&#x2F;.config&#x2F;git&#x2F;config 文件： 只针对当前用户生效。 [global配置]</span><br><span class="line">3、当前使用仓库的Git配置： .git&#x2F;config文件，仅仅对当前仓库配置生效。    [local配置]</span><br></pre></td></tr></table></figure>


<blockquote>
<p>ps: 优先机制：3 &gt; 2 &gt; 1  [.git/config覆盖~/.gitconfig、  ~/.gitconfig覆盖/etc/gitconfig]</p>
</blockquote>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">windows下的~&#x2F;.gitconfig路径为：C:\Users\$USER下；$USER指当前电脑用户名称</span><br></pre></td></tr></table></figure>

<h5 id="查看所有配置命令"><a href="#查看所有配置命令" class="headerlink" title="查看所有配置命令"></a>查看所有配置命令</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --list --show-origin</span><br></pre></td></tr></table></figure>

<h4 id="生成密钥-amp-关联Github-Gitlab"><a href="#生成密钥-amp-关联Github-Gitlab" class="headerlink" title="生成密钥&amp;关联Github/Gitlab"></a>生成密钥&amp;关联Github/Gitlab</h4><h5 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h5><blockquote>
<p>根据邮箱，会要求输入密码，连续3个回车即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;这里换上你的邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>最后得到id_rsa和id_rsa.pub两个文件。</p>
<p>这里用到的是你的 公钥<code>id_rsa.pub</code>文件，复制文件里面的内容到github密钥的界面：</p>
<p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/20200902075825.png"></p>
<p>添加SSH完了之后，就绑定了你本机器和github的关联关系，相当于授权成功。</p>
<h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><blockquote>
<p>上述生成密钥时也可以自定义文件名称.此种情况针对你有多个github账号时，提交公钥文件时，找出自定义名称的文件即可。（下图自定义生成文件名称pywang112,则公钥为pywang112.pub，看好你生成的路径哦）</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/20200902080130.png"></p>
<h4 id="global配置（全局配置）或-local配置（当前仓库配置）"><a href="#global配置（全局配置）或-local配置（当前仓库配置）" class="headerlink" title="global配置（全局配置）或 local配置（当前仓库配置）"></a>global配置（全局配置）或 local配置（当前仓库配置）</h4><h5 id="global配置（针对你只有一个git账户的情况）"><a href="#global配置（针对你只有一个git账户的情况）" class="headerlink" title="global配置（针对你只有一个git账户的情况）"></a>global配置（针对你只有一个git账户的情况）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看命令：</span><br><span class="line">git config --global --list</span><br><span class="line"></span><br><span class="line">全局配置：</span><br><span class="line"></span><br><span class="line">git config --global user.name &quot;crab&quot;</span><br><span class="line">git config --global user.email &quot;imrcrab@163.com&quot;</span><br><span class="line"></span><br><span class="line">代理配置（按需可选）</span><br><span class="line"># http</span><br><span class="line">git config --global https.proxy http:&#x2F;&#x2F;127.0.0.1:1080 </span><br><span class="line"># sock</span><br><span class="line">git config --global http.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39; </span><br><span class="line"></span><br><span class="line">取消代理：</span><br><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure>

<h5 id="local配置-建议本地仓库配置，这样比较灵活"><a href="#local配置-建议本地仓库配置，这样比较灵活" class="headerlink" title="local配置 (建议本地仓库配置，这样比较灵活)"></a>local配置 (建议本地仓库配置，这样比较灵活)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看命令：</span><br><span class="line">git config --local --list</span><br><span class="line"></span><br><span class="line">全局配置：</span><br><span class="line"></span><br><span class="line">git config --local user.name &quot;crab&quot;</span><br><span class="line">git config --local user.email &quot;imrcrab@163.com&quot;</span><br><span class="line"></span><br><span class="line">代理配置（按需可选）</span><br><span class="line"># http</span><br><span class="line">git config --local https.proxy http:&#x2F;&#x2F;127.0.0.1:1080 </span><br><span class="line"># sock</span><br><span class="line">git config --local http.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39; </span><br><span class="line"></span><br><span class="line">取消代理：</span><br><span class="line">git config --local --unset http.proxy</span><br></pre></td></tr></table></figure>

<h4 id="配置完成，clone-commit代码"><a href="#配置完成，clone-commit代码" class="headerlink" title="配置完成，clone/commit代码"></a>配置完成，clone/commit代码</h4><h5 id="clone仓库代码"><a href="#clone仓库代码" class="headerlink" title="clone仓库代码"></a>clone仓库代码</h5><p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/20200902081306.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;crab21&#x2F;blog.git</span><br></pre></td></tr></table></figure>
<h5 id="commit代码"><a href="#commit代码" class="headerlink" title="commit代码"></a>commit代码</h5><blockquote>
<p>按照如上配置完成后，就可以完成基本的push和pull仓库代码了。</p>
</blockquote>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>「5」Git GPG签署工作</title>
    <url>/archives/580377d0.html</url>
    <content><![CDATA[<h3 id="GPG场景"><a href="#GPG场景" class="headerlink" title="GPG场景"></a>GPG场景</h3><p> Git 虽然是密码级安全的，但它不是万无一失的。 如果你从因特网上的其他人那里拿取工作，并且想要验证提交是不是真正地来自于可信来源， Git 提供了几种通过 GPG 来签署和验证工作的方式。</p>
<p> 最终效果：如下图所示</p>
<p> <img src="https://raw.githubusercontent.com/crab21/Images/master/blog/20200902123343.png"></p>
<h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>windows安装地址： <a href="https://www.gnupg.org/">点击下载</a></p>
<p>mac os为例：</p>
<a id="more"></a>
<h4 id="安装GPG"><a href="#安装GPG" class="headerlink" title="安装GPG"></a>安装GPG</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install gpg</span><br><span class="line"></span><br><span class="line">查看结果：</span><br><span class="line">± gpg --version                                                                                                                                                                                                                                     ⏎</span><br><span class="line"></span><br><span class="line">gpg (GnuPG) 2.2.22</span><br><span class="line">libgcrypt 1.8.6</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;https:&#x2F;&#x2F;gnu.org&#x2F;licenses&#x2F;gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line">Home: &#x2F;Users&#x2F;gogoowang&#x2F;.gnupg</span><br><span class="line">支持的算法：</span><br><span class="line">公钥： RSA, ELG, DSA, ECDH, ECDSA, EDDSA</span><br><span class="line">密文： IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH,</span><br><span class="line">    CAMELLIA128, CAMELLIA192, CAMELLIA256</span><br><span class="line">散列： SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224</span><br><span class="line">压缩：  不压缩, ZIP, ZLIB, BZIP2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gpg --full-generate-key</span><br></pre></td></tr></table></figure>

<p>需要填写的地方：<br><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/20200902123803.png"></p>
<h4 id="查看密钥完整信息"><a href="#查看密钥完整信息" class="headerlink" title="查看密钥完整信息"></a>查看密钥完整信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gpg --list-secret-keys --keyid-format LONG</span><br></pre></td></tr></table></figure>

<blockquote>
<p>secret keys（红圈地方后续用到，留意下）：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/20200902124016.png"></p>
<h4 id="根据secret-keys生成PGP"><a href="#根据secret-keys生成PGP" class="headerlink" title="根据secret keys生成PGP"></a>根据secret keys生成PGP</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gpg --armor --export  7BB8CF3593CA174C</span><br></pre></td></tr></table></figure>

<p>生成的PGP结果，后续需要将此结果导入到Github账号的配置信息中<br><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/20200902124305.png"></p>
<h4 id="Github账号中设置"><a href="#Github账号中设置" class="headerlink" title="Github账号中设置"></a>Github账号中设置</h4><p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/20200902124443.png"></p>
<p><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/20200902124527.png"></p>
<blockquote>
<p>将上述生成的PGP填入，点击[Add GPG Key]即可</p>
</blockquote>
<h4 id="配置本地GPG签名信息"><a href="#配置本地GPG签名信息" class="headerlink" title="配置本地GPG签名信息"></a>配置本地GPG签名信息</h4><p>依次执行下面命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、git config --global user.signingkey 7BB8CF3593CA174C  #此处的7BB8CF3593CA174C为生成的secret keys</span><br><span class="line">2、git config commit.gpgsign true</span><br><span class="line">3、git config --global commit.gpgsign true</span><br></pre></td></tr></table></figure>

<h4 id="Git-PGP生效"><a href="#Git-PGP生效" class="headerlink" title="Git PGP生效"></a>Git PGP生效</h4><blockquote>
<p>再次提交commit即可生效。产生如下图的签名效果：<br><img src="https://raw.githubusercontent.com/crab21/Images/master/blog/20200902123343.png"></p>
</blockquote>
<h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4>]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>「4」Git常用技巧</title>
    <url>/archives/3c1dd822.html</url>
    <content><![CDATA[<h3 id="学习方式"><a href="#学习方式" class="headerlink" title="学习方式"></a>学习方式</h3><p>多练多得，直接学习<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6">官网</a>理解。</p>
<p>以下仅仅是部分用到的场景和部分场景记录，不代表全部情况，如有错误，请及时指正。</p>
<h3 id="Git版本："><a href="#Git版本：" class="headerlink" title="Git版本："></a>Git版本：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1944 ± git version </span><br><span class="line">git version 2.28.0</span><br></pre></td></tr></table></figure>
<h3 id="先说说Git的常用命令：-可跳过"><a href="#先说说Git的常用命令：-可跳过" class="headerlink" title="先说说Git的常用命令：(可跳过)"></a>先说说Git的常用命令：(可跳过)</h3><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2081 ◯  git </span><br><span class="line">用法：git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;&#x3D;&lt;value&gt;]</span><br><span class="line">           [--exec-path[&#x3D;&lt;path&gt;]] [--html-path] [--man-path] [--info-path]</span><br><span class="line">           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]</span><br><span class="line">           [--git-dir&#x3D;&lt;path&gt;] [--work-tree&#x3D;&lt;path&gt;] [--namespace&#x3D;&lt;name&gt;]</span><br><span class="line">           &lt;command&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">这些是各种场合常见的 Git 命令：</span><br><span class="line"></span><br><span class="line">开始一个工作区（参见：git help tutorial）</span><br><span class="line">   clone             克隆仓库到一个新目录</span><br><span class="line">   init              创建一个空的 Git 仓库或重新初始化一个已存在的仓库</span><br><span class="line"></span><br><span class="line">在当前变更上工作（参见：git help everyday）</span><br><span class="line">   add               添加文件内容至索引</span><br><span class="line">   mv                移动或重命名一个文件、目录或符号链接</span><br><span class="line">   restore           恢复工作区文件</span><br><span class="line">   rm                从工作区和索引中删除文件</span><br><span class="line">   sparse-checkout   初始化及修改稀疏检出</span><br><span class="line"></span><br><span class="line">检查历史和状态（参见：git help revisions）</span><br><span class="line">   bisect            通过二分查找定位引入 bug 的提交</span><br><span class="line">   diff              显示提交之间、提交和工作区之间等的差异</span><br><span class="line">   grep              输出和模式匹配的行</span><br><span class="line">   log               显示提交日志</span><br><span class="line">   show              显示各种类型的对象</span><br><span class="line">   status            显示工作区状态</span><br><span class="line"></span><br><span class="line">扩展、标记和调校您的历史记录</span><br><span class="line">   branch            列出、创建或删除分支</span><br><span class="line">   commit            记录变更到仓库</span><br><span class="line">   merge             合并两个或更多开发历史</span><br><span class="line">   rebase            在另一个分支上重新应用提交</span><br><span class="line">   reset             重置当前 HEAD 到指定状态</span><br><span class="line">   switch            切换分支</span><br><span class="line">   tag               创建、列出、删除或校验一个 GPG 签名的标签对象</span><br><span class="line"></span><br><span class="line">协同（参见：git help workflows）</span><br><span class="line">   fetch             从另外一个仓库下载对象和引用</span><br><span class="line">   pull              获取并整合另外的仓库或一个本地分支</span><br><span class="line">   push              更新远程引用和相关的对象</span><br><span class="line"></span><br><span class="line">命令 &#39;git help -a&#39; 和 &#39;git help -g&#39; 显示可用的子命令和一些概念帮助。</span><br><span class="line">查看 &#39;git help &lt;命令&gt;&#39; 或 &#39;git help &lt;概念&gt;&#39; 以获取给定子命令或概念的</span><br><span class="line">帮助。</span><br><span class="line">有关系统的概述，查看 &#39;git help git&#39;</span><br></pre></td></tr></table></figure>

<h3 id="Git使用："><a href="#Git使用：" class="headerlink" title="Git使用："></a>Git使用：</h3><h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;这里换上你的邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>最后得到<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件。</p>
<h4 id="Git配置信息"><a href="#Git配置信息" class="headerlink" title="Git配置信息"></a>Git配置信息</h4><h5 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看系统配置信息</span><br><span class="line">* git config --system --list</span><br><span class="line"></span><br><span class="line">当前用户配置</span><br><span class="line">* git config --global --list</span><br><span class="line"></span><br><span class="line">查看当前仓库配置</span><br><span class="line">* git config --local --list</span><br></pre></td></tr></table></figure>

<h5 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h5><p>全局设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;crab&quot;</span><br><span class="line">git config --global user.email &quot;imrcrab@163.com&quot;</span><br></pre></td></tr></table></figure>

<p>当前仓库生效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --local user.name &quot;crab&quot;</span><br><span class="line">git config --local user.email &quot;imrcrab@163.com&quot;</span><br></pre></td></tr></table></figure>



<h4 id="Git-Remote"><a href="#Git-Remote" class="headerlink" title="Git Remote"></a>Git Remote</h4><h5 id="新增remote地址"><a href="#新增remote地址" class="headerlink" title="新增remote地址"></a>新增remote地址</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add upstream http:&#x2F;&#x2F;github&#x2F;**remote**&#x2F;test.git</span><br><span class="line">git remote -v 可以查看具体路径</span><br></pre></td></tr></table></figure>
<h5 id="merge-fetch远程代码到XXX分支"><a href="#merge-fetch远程代码到XXX分支" class="headerlink" title="merge/fetch远程代码到XXX分支"></a>merge/fetch远程代码到XXX分支</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、git fetch upstream。</span><br><span class="line">2、切回到master分支。</span><br><span class="line">3、git merge upstream&#x2F;master 合并远程upstream分支到本地master。</span><br><span class="line">4、解决冲突或其他问题。</span><br></pre></td></tr></table></figure>

<h4 id="Git-误删除恢复"><a href="#Git-误删除恢复" class="headerlink" title="Git 误删除恢复"></a>Git 误删除恢复</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、git  fsck --lost -found :查看最近移除的文件.</span><br><span class="line">2、git show  &#39;误删编号&#39;：查看删除文件内容.</span><br><span class="line">3、git merge ‘误删编号’： 本地合并误删的文件内容.</span><br></pre></td></tr></table></figure>

<h4 id="Git-reset撤回操作"><a href="#Git-reset撤回操作" class="headerlink" title="Git reset撤回操作"></a>Git reset撤回操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、git reflog</span><br><span class="line">2、git reset COMMITID    就可以回到COMMITID那个分支和版本。</span><br></pre></td></tr></table></figure>

<h4 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h4><h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><blockquote>
<p>获取用法：Git branch -d –help</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法：git branch [&lt;选项&gt;] [-r | -a] [--merged | --no-merged]</span><br><span class="line">  或：git branch [&lt;选项&gt;] [-l] [-f] &lt;分支名&gt; [&lt;起始点&gt;]</span><br><span class="line">  或：git branch [&lt;选项&gt;] [-r] (-d | -D) &lt;分支名&gt;...</span><br><span class="line">  或：git branch [&lt;选项&gt;] (-m | -M) [&lt;旧分支&gt;] &lt;新分支&gt;</span><br><span class="line">  或：git branch [&lt;选项&gt;] (-c | -C) [&lt;老分支&gt;] &lt;新分支&gt;</span><br><span class="line">  或：git branch [&lt;选项&gt;] [-r | -a] [--points-at]</span><br><span class="line">  或：git branch [&lt;选项&gt;] [-r | -a] [--format]</span><br><span class="line"></span><br><span class="line">通用选项</span><br><span class="line">    -v, --verbose         显示哈希值和主题，若参数出现两次则显示上游分支</span><br><span class="line">    -q, --quiet           不显示信息</span><br><span class="line">    -t, --track           设置跟踪模式（参见 git-pull(1)）</span><br><span class="line">    -u, --set-upstream-to &lt;上游&gt;</span><br><span class="line">                          改变上游信息</span><br><span class="line">    --unset-upstream      取消上游信息的设置</span><br><span class="line">    --color[&#x3D;&lt;何时&gt;]      使用彩色输出</span><br><span class="line">    -r, --remotes         作用于远程跟踪分支</span><br><span class="line">    --contains &lt;提交&gt;     只打印包含该提交的分支</span><br><span class="line">    --no-contains &lt;提交&gt;  只打印不包含该提交的分支</span><br><span class="line">    --abbrev[&#x3D;&lt;n&gt;]        用 &lt;n&gt; 位数字显示 SHA-1 哈希值</span><br><span class="line"></span><br><span class="line">具体的 git-branch 动作：</span><br><span class="line">    -a, --all             列出远程跟踪及本地分支</span><br><span class="line">    -d, --delete          删除完全合并的分支</span><br><span class="line">    -D                    删除分支（即使没有合并）</span><br><span class="line">    -m, --move            移动&#x2F;重命名一个分支，以及它的引用日志</span><br><span class="line">    -M                    移动&#x2F;重命名一个分支，即使目标已存在</span><br><span class="line">    -c, --copy            拷贝一个分支和它的引用日志</span><br><span class="line">    -C                    拷贝一个分支，即使目标已存在</span><br><span class="line">    -l, --list            列出分支名</span><br><span class="line">    --show-current        显示当前分支名</span><br><span class="line">    --create-reflog       创建分支的引用日志</span><br><span class="line">    --edit-description    标记分支的描述</span><br><span class="line">    -f, --force           强制创建、移动&#x2F;重命名、删除</span><br><span class="line">    --merged &lt;提交&gt;       只打印已经合并的分支</span><br><span class="line">    --no-merged &lt;提交&gt;    只打印尚未合并的分支</span><br><span class="line">    --column[&#x3D;&lt;风格&gt;]     以列的方式显示分支</span><br><span class="line">    --sort &lt;key&gt;          排序的字段名</span><br><span class="line">    --points-at &lt;对象&gt;    只打印指向该对象的分支</span><br><span class="line">    -i, --ignore-case     排序和过滤属于大小写不敏感</span><br><span class="line">    --format &lt;格式&gt;       输出格式</span><br></pre></td></tr></table></figure>

<h5 id="获取所有分支"><a href="#获取所有分支" class="headerlink" title="获取所有分支"></a>获取所有分支</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -r | grep -v &#39;\-&gt;&#39; | while read remote; do git branch --track &quot;$&#123;remote#origin&#x2F;&#125;&quot; &quot;$remote&quot;; done</span><br><span class="line">git fetch --all</span><br><span class="line">git pull --all</span><br></pre></td></tr></table></figure>
<h5 id="add-remove分支"><a href="#add-remove分支" class="headerlink" title="add/remove分支"></a>add/remove分支</h5><p>新建&amp;切换:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b iss53</span><br><span class="line"></span><br><span class="line">是下面两条的简写：</span><br><span class="line">git branch iss53</span><br><span class="line">git checkout iss53</span><br></pre></td></tr></table></figure>
<p>删除分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d iss53</span><br></pre></td></tr></table></figure>

<h4 id="Git-stash"><a href="#Git-stash" class="headerlink" title="Git stash"></a>Git stash</h4><h5 id="常用："><a href="#常用：" class="headerlink" title="常用："></a>常用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）git stash save &quot;save message&quot;  : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</span><br><span class="line">（2）git stash list  ：查看stash了哪些存储</span><br><span class="line">（3）git stash show ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@&#123;$num&#125;，比如第二个 git stash show stash@&#123;1&#125;</span><br><span class="line">（4）git stash show -p : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show  stash@&#123;$num&#125;  -p ，比如第二个：git stash show  stash@&#123;1&#125;  -p</span><br><span class="line">（5）git stash apply :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@&#123;0&#125;，如果要使用其他个，git stash apply stash@&#123;$num&#125; ， 比如第二个：git stash apply stash@&#123;1&#125; </span><br><span class="line">（6）git stash pop ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@&#123;0&#125;，如果要应用并删除其他stash，命令：git stash pop stash@&#123;$num&#125; ，比如应用并删除第二个：git stash pop stash@&#123;1&#125;</span><br><span class="line">（7）git stash drop stash@&#123;$num&#125; ：丢弃stash@&#123;$num&#125;存储，从列表中删除这个存储</span><br><span class="line">（8）git stash clear ：删除所有缓存的stash</span><br></pre></td></tr></table></figure>

<h4 id="Git-Tag"><a href="#Git-Tag" class="headerlink" title="Git Tag"></a>Git Tag</h4><h5 id="常用：-1"><a href="#常用：-1" class="headerlink" title="常用："></a>常用：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2097 ± git tag -a --help</span><br><span class="line">用法：git tag [-a | -s | -u &lt;key-id&gt;] [-f] [-m &lt;消息&gt; | -F &lt;文件&gt;]</span><br><span class="line">		&lt;标签名&gt; [&lt;头&gt;]</span><br><span class="line">  或：git tag -d &lt;标签名&gt;...</span><br><span class="line">  或：git tag -l [-n[&lt;数字&gt;]] [--contains &lt;提交&gt;] [--no-contains &lt;提交&gt;] [--points-at &lt;对象&gt;]</span><br><span class="line">		[--format&#x3D;&lt;格式&gt;] [--[no-]merged [&lt;提交&gt;]] [&lt;模式&gt;...]</span><br><span class="line">  或：git tag -v [--format&#x3D;&lt;格式&gt;] &lt;标签名&gt;...</span><br><span class="line"></span><br><span class="line">    -l, --list            列出标签名称</span><br><span class="line">    -n[&lt;n&gt;]               每个标签信息打印 &lt;n&gt; 行</span><br><span class="line">    -d, --delete          删除标签</span><br><span class="line">    -v, --verify          验证标签</span><br><span class="line"></span><br><span class="line">标签创建选项</span><br><span class="line">    -a, --annotate        附注标签，需要一个说明</span><br><span class="line">    -m, --message &lt;说明&gt;  标签说明</span><br><span class="line">    -F, --file &lt;文件&gt;     从文件中读取提交说明</span><br><span class="line">    -e, --edit            强制编辑标签说明</span><br><span class="line">    -s, --sign            附注并附加 GPG 签名的标签</span><br><span class="line">    --cleanup &lt;模式&gt;      设置如何删除提交说明里的空格和#注释</span><br><span class="line">    -u, --local-user &lt;key-id&gt;</span><br><span class="line">                          使用另外的私钥签名该标签</span><br><span class="line">    -f, --force           如果存在，替换现有的标签</span><br><span class="line">    --create-reflog       创建引用日志</span><br><span class="line"></span><br><span class="line">标签列表选项</span><br><span class="line">    --column[&#x3D;&lt;风格&gt;]     以列的方式显示标签列表</span><br><span class="line">    --contains &lt;提交&gt;     只打印包含该提交的标签</span><br><span class="line">    --no-contains &lt;提交&gt;  只打印不包含该提交的标签</span><br><span class="line">    --merged &lt;提交&gt;       只打印已经合并的标签</span><br><span class="line">    --no-merged &lt;提交&gt;    只打印尚未合并的标签</span><br><span class="line">    --sort &lt;key&gt;          排序的字段名</span><br><span class="line">    --points-at &lt;对象&gt;    只打印指向该对象的标签</span><br><span class="line">    --format &lt;格式&gt;       输出格式</span><br><span class="line">    --color[&#x3D;&lt;何时&gt;]      遵照格式中的颜色输出</span><br><span class="line">    -i, --ignore-case     排序和过滤属于大小写不敏感</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag按照version排序：</span><br><span class="line">git tag -n</span><br><span class="line"></span><br><span class="line">git tag按照时间排序</span><br><span class="line">git tag -n --sort&#x3D;taggerdate</span><br></pre></td></tr></table></figure>

<h5 id="打Tag"><a href="#打Tag" class="headerlink" title="打Tag"></a>打Tag</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -a v0.0.1 -m &quot;V0.0.1&quot; </span><br></pre></td></tr></table></figure>

<h5 id="删除Tag"><a href="#删除Tag" class="headerlink" title="删除Tag"></a>删除Tag</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -d v0.0.1</span><br></pre></td></tr></table></figure>

<h5 id="推送Tag"><a href="#推送Tag" class="headerlink" title="推送Tag"></a>推送Tag</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master --tags</span><br></pre></td></tr></table></figure>

<h4 id="Git-push"><a href="#Git-push" class="headerlink" title="Git push"></a>Git push</h4><h5 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法：git push [&lt;选项&gt;] [&lt;仓库&gt; [&lt;引用规格&gt;...]]</span><br><span class="line"></span><br><span class="line">    -v, --verbose         更加详细</span><br><span class="line">    -q, --quiet           更加安静</span><br><span class="line">    --repo &lt;仓库&gt;         仓库</span><br><span class="line">    --all                 推送所有引用</span><br><span class="line">    --mirror              镜像所有引用</span><br><span class="line">    -d, --delete          删除引用</span><br><span class="line">    --tags                推送标签（不能使用 --all or --mirror）</span><br><span class="line">    -n, --dry-run         演习</span><br><span class="line">    --porcelain           机器可读的输出</span><br><span class="line">    -f, --force           强制更新</span><br><span class="line">    --force-with-lease[&#x3D;&lt;引用名&gt;:&lt;期望值&gt;]</span><br><span class="line">                          要求引用旧的取值为设定值</span><br><span class="line">    --recurse-submodules (check|on-demand|no)</span><br><span class="line">                          控制子模组的递归推送</span><br><span class="line">    --thin                使用精简打包</span><br><span class="line">    --receive-pack &lt;receive-pack&gt;</span><br><span class="line">                          接收包程序</span><br><span class="line">    --exec &lt;receive-pack&gt;</span><br><span class="line">                          接收包程序</span><br><span class="line">    -u, --set-upstream    设置 git pull&#x2F;status 的上游</span><br><span class="line">    --progress            强制显示进度报告</span><br><span class="line">    --prune               清除本地删除的引用</span><br><span class="line">    --no-verify           绕过 pre-push 钩子</span><br><span class="line">    --follow-tags         推送缺失但有关的标签</span><br><span class="line">    --signed[&#x3D;(yes|no|if-asked)]</span><br><span class="line">                          用 GPG 为推送签名</span><br><span class="line">    --atomic              需要远端支持原子事务</span><br><span class="line">    -o, --push-option &lt;server-specific&gt;</span><br><span class="line">                          传输选项</span><br><span class="line">    -4, --ipv4            只使用 IPv4 地址</span><br><span class="line">    -6, --ipv6            只使用 IPv6 地址</span><br></pre></td></tr></table></figure>

<h4 id="Git-rebase"><a href="#Git-rebase" class="headerlink" title="Git rebase"></a>Git rebase</h4><h5 id="变基遵守的原则"><a href="#变基遵守的原则" class="headerlink" title="变基遵守的原则"></a>变基遵守的原则</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。---[官网变基](https:&#x2F;&#x2F;git-scm.com&#x2F;book&#x2F;zh&#x2F;v2&#x2F;Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA)</span><br><span class="line"></span><br><span class="line">TODO 后续更新此过程</span><br></pre></td></tr></table></figure>


<h5 id="经典用法："><a href="#经典用法：" class="headerlink" title="经典用法："></a>经典用法：</h5><blockquote>
<p>git rebase –help</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Assume the following history exists and the current branch is &quot;topic&quot;:</span><br><span class="line"></span><br><span class="line">              A---B---C topic</span><br><span class="line">             &#x2F;</span><br><span class="line">        D---E---F---G master</span><br><span class="line">From this point, the result of either of thefollowing </span><br><span class="line"></span><br><span class="line">commands:</span><br><span class="line">    git rebase master</span><br><span class="line">    git rebase master topic</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">would be:</span><br><span class="line">                      A&#39;--B&#39;--C&#39; topic</span><br><span class="line">                     &#x2F;</span><br><span class="line">        D---E---F---G master</span><br></pre></td></tr></table></figure>

<h5 id="rebase场景："><a href="#rebase场景：" class="headerlink" title="rebase场景："></a>rebase场景：</h5><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA">官网例子</a></p>
<h3 id="Git-快速场景："><a href="#Git-快速场景：" class="headerlink" title="Git 快速场景："></a>Git 快速场景：</h3><p>其实还是对上述命令的活学活用。</p>
<h4 id="Git-Reset场景"><a href="#Git-Reset场景" class="headerlink" title="Git Reset场景"></a>Git Reset场景</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 本地修改了一堆文件(并没有使用git add到暂存区)，想放弃修改。</span><br><span class="line">单个文件&#x2F;文件夹：</span><br><span class="line"></span><br><span class="line">git checkout -- filename</span><br><span class="line"></span><br><span class="line">所有文件&#x2F;文件夹：</span><br><span class="line"></span><br><span class="line">git checkout .</span><br><span class="line"> </span><br><span class="line">2. 本地新增了一堆文件(并没有git add到暂存区)，想放弃修改。</span><br><span class="line">单个文件&#x2F;文件夹：</span><br><span class="line"></span><br><span class="line">$ rm filename &#x2F; rm dir -rf</span><br><span class="line"></span><br><span class="line">所有文件&#x2F;文件夹：</span><br><span class="line"></span><br><span class="line">$ git clean -xdf</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除新增的文件，如果文件已经已经git add到暂存区，并不会删除！</span><br><span class="line"></span><br><span class="line">3. 本地修改&#x2F;新增了一堆文件，已经git add到暂存区，想放弃修改。</span><br><span class="line">单个文件&#x2F;文件夹：</span><br><span class="line"></span><br><span class="line">git reset HEAD filename</span><br><span class="line"></span><br><span class="line">所有文件&#x2F;文件夹：</span><br><span class="line"></span><br><span class="line">git reset HEAD .</span><br><span class="line"> </span><br><span class="line">4. 本地通过git add &amp; git commit 之后，想要撤销此次commit和代码</span><br><span class="line"></span><br><span class="line">git reset commit_id</span><br><span class="line"></span><br><span class="line">这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位</span><br><span class="line">&#x2F;&#x2F; 撤销之后，你所做的已经commit的修改还在工作区！</span><br><span class="line"></span><br><span class="line">git reset --hard commit_id</span><br><span class="line"></span><br><span class="line">这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位</span><br><span class="line">&#x2F;&#x2F; 撤销之后，你所做的已经commit的修改将会清除，仍在工作区&#x2F;暂存区的代码不会清除！</span><br><span class="line"></span><br><span class="line">5. git add &amp; git commit 提交后，只想回滚commit：</span><br><span class="line">	git reset --soft HEAD^</span><br><span class="line">	注意这仅仅是回滚了你的commit，代码依旧在的。</span><br></pre></td></tr></table></figure>

<h3 id="持续更新……"><a href="#持续更新……" class="headerlink" title="持续更新……"></a>持续更新……</h3>]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>「3」git cz规范提交</title>
    <url>/archives/458b44c2.html</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><a href="https://github.com/commitizen/cz-cli">官方 specification</a><br>简单的说为了代码提交更加规范</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>git commit使用<br><a href="https://github.com/commitizen/cz-cli/raw/master/meta/screenshots/add-commit.png">https://github.com/commitizen/cz-cli/raw/master/meta/screenshots/add-commit.png</a></p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul>
<li>安装nodejs，版本建议最新.<a href="https://nodejs.org/zh-cn/">官网</a> </li>
<li>打开你的命令行：<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：npm install -g commitizen</span><br><span class="line">windows应该是cmd吧。</span><br><span class="line">mac用终端或者iterm2都可以。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示以下信息即成功。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt; % sudo npm install -g commitizen</span><br><span class="line">Password:</span><br><span class="line">npm WARN deprecated resolve-url@0.2.1: https:&#x2F;&#x2F;github.com&#x2F;lydell&#x2F;resolve-url#deprecated</span><br><span class="line">npm WARN deprecated urix@0.1.0: Please see https:&#x2F;&#x2F;github.com&#x2F;lydell&#x2F;urix#deprecated</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;cz -&gt; &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;commitizen&#x2F;bin&#x2F;git-cz</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;git-cz -&gt; &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;commitizen&#x2F;bin&#x2F;git-cz</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;commitizen -&gt; &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;commitizen&#x2F;bin&#x2F;commitizen</span><br><span class="line">+ commitizen@4.2.1</span><br><span class="line">updated 1 package in 8.132s</span><br></pre></td></tr></table></figure>
3、进入git项目中，执行下面命令初始化环境。<br><code>commitizen init cz-conventional-changelog --save --save-exact</code></li>
</ul>
<p>4、在提交代码时使用</p>
<blockquote>
<p>git cz 替换 git commit命令</p>
</blockquote>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>安装方式可选择全局安装<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g commitizen cz-conventional-changelog</span><br><span class="line">echo &#39;&#123; &quot;path&quot;: &quot;cz-conventional-changelog&quot; &#125;&#39; &gt; ~&#x2F;.czrc</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>「2」vscode 常见插件及其使用</title>
    <url>/archives/8cf3cbca.html</url>
    <content><![CDATA[<blockquote>
<p>vscode中一些常见的坑点…</p>
</blockquote>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="样式方面："><a href="#样式方面：" class="headerlink" title="样式方面："></a>样式方面：</h4><ul>
<li>Indent Rainbo</li>
<li>Bracket Pair Colorizer # 括号颜色</li>
<li>Chinese Language       # 汉化<a id="more"></a>

</li>
</ul>
<h4 id="功能方面"><a href="#功能方面" class="headerlink" title="功能方面"></a>功能方面</h4><ul>
<li>Git Blame              # Git提交查看</li>
<li>Code Spell Checker     # 拼写检查</li>
<li>Reload                 # 重新加载</li>
<li>Todo Tree              # 代办事项</li>
<li>Settings Sync          # 设置同步</li>
</ul>
]]></content>
      <tags>
        <tag>vscode</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>「1」重拾那份折腾之心，坚定脚步</title>
    <url>/archives/640b5696.html</url>
    <content><![CDATA[<pre><code>从前，现在，将来...</code></pre>
]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
</search>
