<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>「18」GPM 初识/设计</title>
    <url>/archives/b885f9f7.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p>学go有一段时间了，最近总感觉忙碌无为，也该总结下前段时间读源码的一些心得和体会了。</p>
<p>GPM调度算是在Go中比较经典的了，有必要深入学习下。</p>
<blockquote>
<p><a href="https://golang.org/s/go11sched">Go GPM设计文档</a></p>
</blockquote>
<h3 id="GPM设计的由来"><a class="header-anchor" href="#GPM设计的由来">¶</a>GPM设计的由来</h3>
<p>一个好的设计，总会伴随发现现有的问题，在解决的基础上考虑场景并提高扩展性，先来了解下Go为何要重新设计GPM这个模型：</p>
<a id="more"></a>
<h4 id="现有的问题："><a class="header-anchor" href="#现有的问题：">¶</a>现有的问题：</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Single global mutex (Sched.Lock) and centralized state. The mutex protects all goroutine-related operations (creation, completion, rescheduling, etc).</span><br><span class="line">2. Goroutine (G) hand-off (G.nextg). Worker threads (M&#39;s) frequently hand-off runnable goroutines between each other, this may lead to increased latencies and additional overheads. Every M must be able to execute any runnable G, in particular the M that just created the G.</span><br><span class="line">3. Per-M memory cache (M.mcache). Memory cache and other caches (stack alloc) are associated with all M&#39;s, while they need to be associated only with M&#39;s running Go code (an M blocked inside of syscall does not need mcache). A ratio between M&#39;s running Go code and all M&#39;s can be as high as 1:100. This leads to excessive resource consumption (each MCache can suck up up to 2M) and poor data locality.</span><br><span class="line">4. Aggressive thread blocking&#x2F;unblocking. In presence of syscalls worker threads are frequently blocked and unblocked. This adds a lot of overhead.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、单一的全局锁和集中的状态.此锁所有g的操作。</span><br><span class="line">2、g退出。工作中的M频繁的交出正在running的g，导致延迟增加和额外的负载。每个M执行任何g，尤其是M自身创建的g。</span><br><span class="line">3、M的内存缓存问题。   内存缓存和其它的缓存关联这所有的M，当他们需要关联M来running code时。比率显示M运行的code和所有M的呈1:100。导致很多资源的浪费和内存的贫瘠。</span><br><span class="line">4、侵略性的加锁，在系统线程频繁的加锁和解锁。这样会造成很大的负载。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="设计改变"><a class="header-anchor" href="#设计改变">¶</a>设计改变</h3>
<blockquote>
<p>以前的设计：<br>
<img src="https://crab-1251738482.cos.accelerate.myqcloud.com/GPM-1.png" alt=""></p>
</blockquote>
<blockquote>
<p>新增Processor</p>
</blockquote>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/GPM-2.png" alt=""></p>
<h3 id="实现计划"><a class="header-anchor" href="#实现计划">¶</a>实现计划</h3>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Introduce the P struct (empty for now); implement allp&#x2F;idlep containers (idlep is mutex-protected for starters); associate a P with M running Go code. Global mutex and atomic state is still preserved.</span><br><span class="line">2. Move G freelist to P.</span><br><span class="line">3. Move mcache to P.</span><br><span class="line">4. Move stackalloc to P.</span><br><span class="line">5. Move ncgocall&#x2F;gcstats to P.</span><br><span class="line">&#x2F;&#x2F; work-steal工作窃取模式,仍然在全局锁下。</span><br><span class="line">6. Decentralize run queue, implement work-stealing. Eliminate G hand off. Still under global mutex.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 移除全局锁，实现分散的检测。</span><br><span class="line">7. Remove global mutex, implement distributed termination detection, LockOSThread.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实现自旋替代提示锁「普通锁」。</span><br><span class="line">8. Implement spinning instead of prompt blocking&#x2F;unblocking.</span><br><span class="line">The plan may turn out to not work, there are a lot of unexplored details.</span><br></pre></td></tr></table></figure>
<h3 id="Potential-Improvement"><a class="header-anchor" href="#Potential-Improvement">¶</a>Potential Improvement</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 后进先出计划。提供公平和优雅的处理g。</span><br><span class="line">1. Try out LIFO scheduling, this will improve locality. However, it still must provide some degree of fairness and gracefully handle yielding goroutines.</span><br><span class="line"></span><br><span class="line"># 不分配内存和栈空间，直到g跑起来。对于一个新创建的g，需要下面几个函数。 这将创建to完成伴随着较低内存的负载。</span><br><span class="line">2. Do not allocate G and stack until the goroutine first runs. For a newly created goroutine we need just callerpc, fn, narg, nret and args, that is, about 6 words. This will allow to create a lot of running-to-completion goroutines with significantly lower memory overhead.</span><br><span class="line"></span><br><span class="line"># 更好的G-P。尝试入队未锁定的G到P，从上一次运行。</span><br><span class="line">4. Better locality of G-to-P. Try to enqueue an unblocked G to a P on which it was last running.</span><br><span class="line"></span><br><span class="line"># 更好的P-M。尝试执行p，在同样的M最后一次运行。</span><br><span class="line">5. Better locality of P-to-M. Try to execute P on the same M it was last running.</span><br><span class="line"></span><br><span class="line"># M限流创建。调度器创建上千哥M在毫秒之间，直到OS拒绝创建更多的thread。M必须立刻创建，最多创建k*GOMAXPROCS,后续新的M会通过定时器创建。</span><br><span class="line">6. Throttling of M creation. The scheduler can be easily forced to create thousands of M&#39;s per second until OS refuses to create more threads. M’s must be created promptly up to k*GOMAXPROCS, after that new M’s may added by a timer.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="参考："><a class="header-anchor" href="#参考：">¶</a>参考：</h3>
<ul>
<li>
<p><a href="https://golang.org/s/go11scheds">GPM g11设计文档</a></p>
</li>
<li>
<p><a href="http://supertech.csail.mit.edu/papers/steal.pdf">work steal模式</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>GPM</tag>
        <tag>Go源码</tag>
      </tags>
  </entry>
  <entry>
    <title>「33」Float IEEE标准</title>
    <url>/archives/257c4ce2.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p>前几天踩坑Float类型的计算问题,今天来系统的总结下float相关的知识点.</p>
<h3 id="掌握关键点"><a class="header-anchor" href="#掌握关键点">¶</a>掌握关键点:</h3>
<ul>
<li>float的标准是什么?</li>
<li>float的位计算规则</li>
<li>float场景</li>
<li>float计算改进</li>
</ul>
<a id="more"></a>
<h3 id="Float的标准"><a class="header-anchor" href="#Float的标准">¶</a>Float的标准?</h3>
<h4 id="国际组织定义"><a class="header-anchor" href="#国际组织定义">¶</a>国际组织定义</h4>
<p><a href="https://zh.wikipedia.org/wiki/IEEE_754">wiki–&gt;float定义</a></p>
<h4 id="表示方法"><a class="header-anchor" href="#表示方法">¶</a>表示方法</h4>
<p style=""><img src="https://math.now.sh?from=value%20%3D%20%20sign%20*%20exponent%20*%20fraction%20%0A" /></p><ul>
<li>value: 实际值</li>
<li>sign bit: 符号位</li>
<li>exponent bit: 指数便宜位</li>
<li>fraction: 分数值</li>
</ul>
<p>具体表示:</p>
<p><img src="https://crab-1251738482.cos.ap-guangzhou.myqcloud.com/clipboard_20210206_104959.webp" alt=""></p>
<h4 id="单精度和双精度"><a class="header-anchor" href="#单精度和双精度">¶</a>单精度和双精度</h4>
<p><img src="https://crab-1251738482.cos.ap-guangzhou.myqcloud.com/clipboard_20210206_110116.png" alt=""></p>
<h4 id="特殊值"><a class="header-anchor" href="#特殊值">¶</a>特殊值:</h4>
<ul>
<li>无穷: Inf</li>
<li>非数值: NaN</li>
</ul>
<h3 id="Float位计算规则"><a class="header-anchor" href="#Float位计算规则">¶</a>Float位计算规则</h3>
<h4 id="原码"><a class="header-anchor" href="#原码">¶</a>原码</h4>
<ul>
<li>高位表示符号位,其余为值; ⚠️:不能直接参与计算</li>
</ul>
<h4 id="反码"><a class="header-anchor" href="#反码">¶</a>反码</h4>
<ul>
<li>正数反码为本身</li>
<li>负数保留符号位,其它位按位取反.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如 :</span><br><span class="line">[+7]原 &#x3D; 00000111 [+7]反 &#x3D; 00000111 </span><br><span class="line">[-7]原 &#x3D; 10000111 [-7]反 &#x3D; 11111000</span><br></pre></td></tr></table></figure>
<h4 id="补码"><a class="header-anchor" href="#补码">¶</a>补码</h4>
<ul>
<li>正数的补码==原码==补码</li>
<li>负数补码=反码+1</li>
</ul>
<h4 id="计算形式"><a class="header-anchor" href="#计算形式">¶</a>计算形式:</h4>
<p style=""><img src="https://math.now.sh?from=v%20%3D%20%28-1%29%5Es%20*%20M%20*%202%5EE%20%0A" /></p><h5 id="说明"><a class="header-anchor" href="#说明">¶</a>说明:</h5>
<ul>
<li><img src="https://math.now.sh?inline=%28-1%29%5Es" style="display:inline-block;margin: 0;"/>表示符号位</li>
<li>M表示有效数字</li>
<li><img src="https://math.now.sh?inline=2%5EE" style="display:inline-block;margin: 0;"/>表示指数位</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="number">-0.5</span> =&gt; <span class="number">-0.1</span>[二进制]</span><br><span class="line">=&gt; <span class="number">-1.0</span> * <span class="number">2</span>^<span class="number">-1</span></span><br><span class="line">=&gt; (<span class="number">-1</span>)^<span class="number">1</span> * <span class="number">1.0</span> * <span class="number">2</span>^<span class="number">-1</span></span><br><span class="line">=&gt; s=<span class="number">1</span>，M=<span class="number">1.0</span>，E=<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h4 id="float类型的加法"><a class="header-anchor" href="#float类型的加法">¶</a>float类型的加法:</h4>
<ul>
<li>对阶</li>
<li>尾数</li>
<li>规格化</li>
<li>舍入处理</li>
<li>溢出判断</li>
</ul>
<h4 id="0-3-1-6"><a class="header-anchor" href="#0-3-1-6">¶</a><img src="https://math.now.sh?inline=0.3%2B1.6%3D%3F" style="display:inline-block;margin: 0;"/></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;(0.3)10&#x3D;(0011 1110 1001 1001 1001 1001 1001 1010)2    Sa&#x3D;0    Ea&#x3D;011 1110 1    Ma&#x3D;1.001 1001 1001 1001 1001 1010</span><br><span class="line"></span><br><span class="line">b&#x3D;(1.6)10&#x3D;(0011 1111 1100 1100 1100 1100 1100 1101)2      Sb&#x3D;0    Eb&#x3D;011 1111 1     Mb&#x3D;1.100 1100 1100 1100 1100 1101</span><br></pre></td></tr></table></figure>
<h5 id="对阶"><a class="header-anchor" href="#对阶">¶</a>对阶</h5>
<blockquote>
<p>简单的说就是需要阶码对齐,使其尾数可以进行加减运算,即:</p>
</blockquote>
<p>$ ⊿E = E_b -E_a $</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Ea&lt;Eb   Eb-Ea=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">Ma要调整为 <span class="number">0.0</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">10</span>       <span class="number">10</span></span><br><span class="line"></span><br><span class="line">E=<span class="number">011</span> <span class="number">1111</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h5 id="尾数"><a class="header-anchor" href="#尾数">¶</a>尾数</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="number">0.01001100110011001100110</span></span><br><span class="line">+ <span class="number">1.10011001100110011001101</span></span><br><span class="line">----------------------------</span><br><span class="line">  <span class="number">1.11100110011001100110011</span></span><br></pre></td></tr></table></figure>
<h5 id="规格化"><a class="header-anchor" href="#规格化">¶</a>规格化</h5>
<p>尾数的格式 $ 1.M $,尾数可能是非规格化的,所以需要左规和右规操作:</p>
<ul>
<li>左规操作: 尾数左移,阶码减值</li>
<li>右规操作: 尾数右移,阶码+值</li>
</ul>
<p>$ 目的: 1 \leq M &lt; 2 $</p>
<ul>
<li><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0">1.11100110011001100110011‬</label></li>
</ul>
<h5 id="舍入处理"><a class="header-anchor" href="#舍入处理">¶</a>舍入处理</h5>
<blockquote>
<p>四种舍入方式:</p>
</blockquote>
<ul>
<li>就近舍入: 四舍五入</li>
<li>朝+∞舍入</li>
<li>朝-∞舍入</li>
<li>朝0舍入</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">在对阶时，Ma有右移，且第一次最高为<span class="number">1</span>，第二次为<span class="number">0</span>，</span><br><span class="line">所以按<span class="string">&quot;0舍1入&quot;</span>， ==&gt; 精度丢失的关键, </span><br><span class="line">尾数运算结果调整为 <span class="number">1.11100110011001100110100</span></span><br></pre></td></tr></table></figure>
<h5 id="溢出判断"><a class="header-anchor" href="#溢出判断">¶</a>溢出判断</h5>
<blockquote>
<p>判断结果标准: 运算结果的阶码</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a+b=(<span class="number">0</span>  <span class="number">01111111</span>  <span class="number">11100110011001100110100</span>)<span class="number">2</span></span><br><span class="line">=(<span class="number">0011</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0100</span>)<span class="number">2</span>=(<span class="number">3</span>FF33334)<span class="number">16</span></span><br><span class="line"></span><br><span class="line">转为<span class="number">10</span>进制</span><br><span class="line"></span><br><span class="line">a+b=<span class="number">1.90000010</span></span><br></pre></td></tr></table></figure>
<h3 id="float计算改进"><a class="header-anchor" href="#float计算改进">¶</a>float计算改进</h3>
<h4 id="尽量避免使用高精度且重要的数据计算-如-¥"><a class="header-anchor" href="#尽量避免使用高精度且重要的数据计算-如-¥">¶</a>尽量避免使用高精度且重要的数据计算: 如: ¥</h4>
<h4 id="统一取舍位数"><a class="header-anchor" href="#统一取舍位数">¶</a>统一取舍位数</h4>
<ul>
<li>统一保留</li>
<li>统一取舍算法</li>
</ul>
<h4 id="建议用int-string类型"><a class="header-anchor" href="#建议用int-string类型">¶</a>建议用int/string类型</h4>
<ul>
<li>缺点:
<ul>
<li>牺牲性能</li>
<li>转换复杂</li>
</ul>
</li>
<li>优点:
<ul>
<li>提高准确度</li>
<li>处理可多元化</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>Float</tag>
        <tag>IEEE</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>「32」Go  Ticker 内存泄露</title>
    <url>/archives/53e1932f.html</url>
    <content><![CDATA[<h3 id="前序："><a class="header-anchor" href="#前序：">¶</a>前序：</h3>
<p>不知道你们有没有经历过这种情况：</p>
<blockquote>
<p>测试示例图片：</p>
</blockquote>
<p><img src="https://crab-1251738482.cos.ap-guangzhou.myqcloud.com/clipboard_20210204_051425.webp" alt=""></p>
<a id="more"></a>
<blockquote>
<p>说的简单点：内存炸了呗…OOM</p>
</blockquote>
<h3 id="引言"><a class="header-anchor" href="#引言">¶</a>引言</h3>
<blockquote>
<p>go version go1.14.14 darwin/amd64</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">最近的坑是真的多，当然这种坑在大项目中，一不小心就写出来了,</span><br><span class="line"></span><br><span class="line">人多，项目大，各种各样的花式操作都出来了,在所难免，</span><br><span class="line">能做的就是分析问题，总结，记录，防止下次自己犯错，同时也可以加深理解。</span><br></pre></td></tr></table></figure>
<h3 id="起因："><a class="header-anchor" href="#起因：">¶</a>起因：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">XXX</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 业务代码 几十行...</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++&#123;</span><br><span class="line">	    ticker := time.NewTicker(<span class="number">10</span> * time.Second)</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">//模拟业务代码</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;defer close&quot;</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">                <span class="comment">// 业务代码.....</span></span><br><span class="line">                    fmt.Println(<span class="string">&quot;time 5&quot;</span>)</span><br><span class="line">                <span class="keyword">case</span> &lt;-doneChan:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 业务代码 几十行...</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="发生了什么？"><a class="header-anchor" href="#发生了什么？">¶</a>发生了什么？</h4>
<blockquote>
<p>上面的代码，不晓得看出来什么问题了么…</p>
</blockquote>
<h3 id="关键点："><a class="header-anchor" href="#关键点：">¶</a>关键点：</h3>
<p>ticker没有stop</p>
<p><a href="https://github.com/golang/go/blob/master/src/time/tick.go#L62">官方解释</a></p>
<h4 id="Ticker不能被回收导致"><a class="header-anchor" href="#Ticker不能被回收导致">¶</a>Ticker不能被回收导致</h4>
<p><img src="https://crab-1251738482.cos.ap-guangzhou.myqcloud.com/clipboard_20210204_053201.webp" alt=""></p>
<h4 id="为何不能被回收？"><a class="header-anchor" href="#为何不能被回收？">¶</a>为何不能被回收？</h4>
<h5 id="NewTicker实现："><a class="header-anchor" href="#NewTicker实现：">¶</a>NewTicker实现：</h5>
<p><a href="https://github.com/golang/go/blob/master/src/time/tick.go#L39">NewTicker官方实现</a></p>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/time.go#L203">startTimer底层实现</a></p>
<h6 id="addtimer"><a class="header-anchor" href="#addtimer">¶</a>addtimer</h6>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// addtimer adds a timer to the current P.</span></span><br><span class="line"><span class="comment">// This should only be called with a newly created timer.</span></span><br><span class="line"><span class="comment">// That avoids the risk of changing the when field of a timer in some P&#x27;s heap,</span></span><br><span class="line"><span class="comment">// which could cause the heap to become unsorted.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addtimer</span><span class="params">(t *timer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// when must never be negative; otherwise runtimer will overflow</span></span><br><span class="line">	<span class="comment">// during its delta calculation and never expire other runtime timers.</span></span><br><span class="line">	<span class="keyword">if</span> t.when &lt; <span class="number">0</span> &#123;</span><br><span class="line">		t.when = maxWhen</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.status != timerNoStatus &#123;</span><br><span class="line">		throw(<span class="string">&quot;addtimer called with initialized timer&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	t.status = timerWaiting</span><br><span class="line"></span><br><span class="line">	when := t.when</span><br><span class="line"></span><br><span class="line">	pp := getg().m.p.ptr() <span class="comment">// 获取当前的P</span></span><br><span class="line">	lock(&amp;pp.timersLock) <span class="comment">// 加锁</span></span><br><span class="line">	cleantimers(pp) <span class="comment">// 调整p.timers栈顶元素</span></span><br><span class="line">	doaddtimer(pp, t) <span class="comment">// t绑定下p</span></span><br><span class="line">	unlock(&amp;pp.timersLock) </span><br><span class="line"></span><br><span class="line">	wakeNetPoller(when)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="doaddtimer"><a class="header-anchor" href="#doaddtimer">¶</a>doaddtimer</h6>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// doaddtimer adds t to the current P&#x27;s heap.</span></span><br><span class="line"><span class="comment">// The caller must have locked the timers for pp.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doaddtimer</span><span class="params">(pp *p, t *timer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Timers rely on the network poller, so make sure the poller</span></span><br><span class="line">	<span class="comment">// has started.</span></span><br><span class="line">	<span class="keyword">if</span> netpollInited == <span class="number">0</span> &#123;</span><br><span class="line">		netpollGenericInit()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> t.pp != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;doaddtimer: P already set in timer&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	t.pp.set(pp)</span><br><span class="line">	i := <span class="built_in">len</span>(pp.timers)</span><br><span class="line">	pp.timers = <span class="built_in">append</span>(pp.timers, t) <span class="comment">// p上添加一个timer</span></span><br><span class="line">	siftupTimer(pp.timers, i) <span class="comment">// 堆调整算法</span></span><br><span class="line">	<span class="keyword">if</span> t == pp.timers[<span class="number">0</span>] &#123;</span><br><span class="line">		atomic.Store64(&amp;pp.timer0When, <span class="keyword">uint64</span>(t.when))</span><br><span class="line">	&#125;</span><br><span class="line">	atomic.Xadd(&amp;pp.numTimers, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展："><a class="header-anchor" href="#拓展：">¶</a>拓展：</h3>
<h4 id="cleantimers过程："><a class="header-anchor" href="#cleantimers过程：">¶</a>cleantimers过程：</h4>
<ul>
<li>判断长度</li>
<li>判断上一个timer状态</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cleantimers cleans up the head of the timer queue. This speeds up</span></span><br><span class="line"><span class="comment">// programs that create and delete timers; leaving them in the heap</span></span><br><span class="line"><span class="comment">// slows down addtimer. Reports whether no timer problems were found.</span></span><br><span class="line"><span class="comment">// The caller must have locked the timers for pp.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cleantimers</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(pp.timers) == <span class="number">0</span> &#123; <span class="comment">// 判断长度</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		t := pp.timers[<span class="number">0</span>] <span class="comment">//取第一个</span></span><br><span class="line">		<span class="keyword">if</span> t.pp.ptr() != pp &#123;</span><br><span class="line">			throw(<span class="string">&quot;cleantimers: bad p&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> s := atomic.Load(&amp;t.status); s &#123; <span class="comment">//需要判断状态</span></span><br><span class="line">		<span class="keyword">case</span> timerDeleted:</span><br><span class="line">			<span class="keyword">if</span> !atomic.Cas(&amp;t.status, s, timerRemoving) &#123; <span class="comment">//非删除中</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			dodeltimer0(pp) <span class="comment">//移除timer0</span></span><br><span class="line">			<span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerRemoving, timerRemoved) &#123;</span><br><span class="line">				badTimer()</span><br><span class="line">			&#125;</span><br><span class="line">			atomic.Xadd(&amp;pp.deletedTimers, <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">case</span> timerModifiedEarlier, timerModifiedLater: <span class="comment">// 修改前或者修改后的状态</span></span><br><span class="line">			<span class="keyword">if</span> !atomic.Cas(&amp;t.status, s, timerMoving) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Now we can change the when field.</span></span><br><span class="line">			t.when = t.nextwhen <span class="comment">// 指针后移</span></span><br><span class="line">			<span class="comment">// Move t to the right position.</span></span><br><span class="line">			dodeltimer0(pp) <span class="comment">// 删除最底下的元素</span></span><br><span class="line">			doaddtimer(pp, t) <span class="comment">// 重新绑定P和t的关系</span></span><br><span class="line">			<span class="keyword">if</span> s == timerModifiedEarlier &#123;</span><br><span class="line">				atomic.Xadd(&amp;pp.adjustTimers, <span class="number">-1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerMoving, timerWaiting) &#123;</span><br><span class="line">				badTimer()</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// Head of timers does not need adjustment.</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="dodeltimer0"><a class="header-anchor" href="#dodeltimer0">¶</a>dodeltimer0</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dodeltimer0 removes timer 0 from the current P&#x27;s heap.</span></span><br><span class="line"><span class="comment">// We are locked on the P when this is called.</span></span><br><span class="line"><span class="comment">// It reports whether it saw no problems due to races.</span></span><br><span class="line"><span class="comment">// The caller must have locked the timers for pp.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dodeltimer0</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t := pp.timers[<span class="number">0</span>]; t.pp.ptr() != pp &#123;</span><br><span class="line">		throw(<span class="string">&quot;dodeltimer0: wrong P&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		t.pp = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	last := <span class="built_in">len</span>(pp.timers) - <span class="number">1</span> <span class="comment">// 获取第一个timers</span></span><br><span class="line">	<span class="keyword">if</span> last &gt; <span class="number">0</span> &#123;</span><br><span class="line">		pp.timers[<span class="number">0</span>] = pp.timers[last] <span class="comment">// 栈底---&gt;栈顶</span></span><br><span class="line">	&#125;</span><br><span class="line">	pp.timers[last] = <span class="literal">nil</span> <span class="comment">// 置空</span></span><br><span class="line">	pp.timers = pp.timers[:last] <span class="comment">//重新赋值</span></span><br><span class="line">	<span class="keyword">if</span> last &gt; <span class="number">0</span> &#123;</span><br><span class="line">		siftdownTimer(pp.timers, <span class="number">0</span>)  <span class="comment">// 重新排序</span></span><br><span class="line">	&#125;</span><br><span class="line">	updateTimer0When(pp) <span class="comment">// 更新P中的when</span></span><br><span class="line">	atomic.Xadd(&amp;pp.numTimers, <span class="number">-1</span>) <span class="comment">// 更新数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h3>
<ul>
<li>
<p><a href="https://github.com/golang/go/blob/master/src/time/tick.go#L39">NewTicker官方实现</a></p>
</li>
<li>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/time.go#L203">StartTimer底层实现</a></p>
</li>
<li>
<p>atomic</p>
<ul>
<li>atomic.Store64</li>
<li>atomic.Xadd</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>ticker</tag>
        <tag>defer</tag>
      </tags>
  </entry>
  <entry>
    <title>「31」Float类型易踩的坑</title>
    <url>/archives/cb90ed2a.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p>最近快过年了吧，但是有很多需求要搞，，，，</p>
<p>突然来了个锅，被人投诉说数据统计的有问题，打开电脑一看，float类型的统计，「我慌了，float在统计中一直都很头疼。」</p>
<h3 id="触发点"><a class="header-anchor" href="#触发点">¶</a>触发点</h3>
<h4 id="先来看问题吧「写了个例子」："><a class="header-anchor" href="#先来看问题吧「写了个例子」：">¶</a>先来看问题吧「写了个例子」：</h4>
<blockquote>
<p>下面的结果，a应该是什么值？why？</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>go version go1.14.14 darwin/amd64</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> floatNumber <span class="keyword">float64</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	a := floatNumber / <span class="number">0</span></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="输出结果："><a class="header-anchor" href="#输出结果：">¶</a>输出结果：</h5>
<p>NAN</p>
<h5 id="why-「究其根源」"><a class="header-anchor" href="#why-「究其根源」">¶</a>why?「究其根源」</h5>
<p><a href="https://golang.google.cn/ref/spec#Representability">官方解释</a></p>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/clipboard_20210204_030335.png" alt=""></p>
<blockquote>
<p>简单的说就是 0/0 为负无穷大，所以为 NAN.</p>
</blockquote>
<h3 id="如何规避？"><a class="header-anchor" href="#如何规避？">¶</a>如何规避？</h3>
<ul>
<li>提前判断分母，为0，不计算「根源解决」</li>
<li>利用math.IsNaN(xxx)，选择性跳过。 「治标」</li>
</ul>
<h3 id="拓展："><a class="header-anchor" href="#拓展：">¶</a>拓展：</h3>
<h4 id="下面这个输出什么？"><a class="header-anchor" href="#下面这个输出什么？">¶</a>下面这个输出什么？</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> number <span class="keyword">int</span></span><br><span class="line">	fmt.Println(number / <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="输出结果：-v2"><a class="header-anchor" href="#输出结果：-v2">¶</a>输出结果：</h5>
<blockquote>
<p>division by zero</p>
</blockquote>
<h5 id="why"><a class="header-anchor" href="#why">¶</a>why?</h5>
<ul>
<li>除数不能为0.</li>
</ul>
<h4 id="关于float类型"><a class="header-anchor" href="#关于float类型">¶</a>关于float类型</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">这么简单，估计会被说很菜，，，，</span><br><span class="line"></span><br><span class="line">关于float类型的使用和注意事项「和语言无关」，一直都很零散，下来整理下，系统性的学习学习。</span><br></pre></td></tr></table></figure>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
<p>快过年了，提前预祝大家新年快乐。。。。</p>
<p>🧨🧨🧨🧨🧨🧨🧨🧨🧨🧨🧨🧨🧨🧨🧨</p>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>Golang</tag>
        <tag>Float</tag>
        <tag>IEEE</tag>
      </tags>
  </entry>
  <entry>
    <title>「30」redis rdb源码-1</title>
    <url>/archives/44b34745.html</url>
    <content><![CDATA[<blockquote>
<p>RDB和AOF常常被提起,好奇RDB这个到底是怎么实现的,这样才能运用的更加灵活和精准.</p>
</blockquote>
<h3 id="学完预期的目标"><a class="header-anchor" href="#学完预期的目标">¶</a>学完预期的目标:</h3>
<ul>
<li>学习数据异步处理流程</li>
<li>RDB持久化数据的关键过程</li>
<li>RDB的缺点</li>
<li>RDB适用的场景</li>
<li>RDB改进点或bug?</li>
<li>数据持久化,应该是个什么过程?</li>
</ul>
<a id="more"></a>
<h3 id="实现流程"><a class="header-anchor" href="#实现流程">¶</a>实现流程:</h3>
<ul>
<li>这里罗列了几个比较重要的过程:</li>
</ul>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/redis-rdb-1.png" alt=""></p>
<h3 id="rdbSaveKeyValuePair「2021-01-31-22-57-28」"><a class="header-anchor" href="#rdbSaveKeyValuePair「2021-01-31-22-57-28」">¶</a>rdbSaveKeyValuePair「2021-01-31 22:57:28」</h3>
<ul>
<li>错误返回-1,正常返回1,其它返回0</li>
<li>主逻辑只需负责入参和返回值「抽象」</li>
<li>优先级: expire &gt; lru &gt; lfu &gt; [&lt;key,values&gt;]</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Save a key-value pair, with expire time, type, key, value.</span></span><br><span class="line"><span class="comment"> * On error -1 is returned.</span></span><br><span class="line"><span class="comment"> * On success if the key was actually saved 1 is returned, otherwise 0</span></span><br><span class="line"><span class="comment"> * is returned (the key was already expired). */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveKeyValuePair</span><span class="params">(rio *rdb, robj *key, robj *val, <span class="keyword">long</span> <span class="keyword">long</span> expiretime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> savelru = server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU;</span><br><span class="line">    <span class="keyword">int</span> savelfu = server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  保存过期时间</span></span><br><span class="line">    <span class="comment">/* Save the expire time */</span></span><br><span class="line">    <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_EXPIRETIME_MS) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveMillisecondTime(rdb,expiretime) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LRU方式保存</span></span><br><span class="line">    <span class="comment">/* Save the LRU info. */</span></span><br><span class="line">    <span class="keyword">if</span> (savelru) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> idletime = estimateObjectIdleTime(val);</span><br><span class="line">        idletime /= <span class="number">1000</span>; <span class="comment">/* Using seconds is enough and requires less space.*/</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_IDLE) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,idletime) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LFU方式保存</span></span><br><span class="line">    <span class="comment">/* Save the LFU info. */</span></span><br><span class="line">    <span class="keyword">if</span> (savelfu) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> buf[<span class="number">1</span>];</span><br><span class="line">        buf[<span class="number">0</span>] = LFUDecrAndReturn(val);</span><br><span class="line">        <span class="comment">/* We can encode this in exactly two bytes: the opcode and an 8</span></span><br><span class="line"><span class="comment">         * bit counter, since the frequency is logarithmic with a 0-255 range.</span></span><br><span class="line"><span class="comment">         * Note that we do not store the halving time because to reset it</span></span><br><span class="line"><span class="comment">         * a single time when loading does not affect the frequency much. */</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_FREQ) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,buf,<span class="number">1</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存类型、key、value等</span></span><br><span class="line">    <span class="comment">/* Save type, key, value */</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveObjectType(rdb,val) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveStringObject(rdb,key) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveObject(rdb,val,key) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟请求</span></span><br><span class="line">    <span class="comment">/* Delay return if required (for testing) */</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_key_save_delay)</span><br><span class="line">        usleep(server.rdb_key_save_delay);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="待更ing…"><a class="header-anchor" href="#待更ing…">¶</a>待更ing…</h3>
]]></content>
      <tags>
        <tag>Day</tag>
        <tag>Redis</tag>
        <tag>RDB</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>「29」map delete Mem不释放问题</title>
    <url>/archives/2de36dd7.html</url>
    <content><![CDATA[<h3 id="Go-version"><a class="header-anchor" href="#Go-version">¶</a>Go version:</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">7384</span> ◯  <span class="keyword">go</span> version</span><br><span class="line"><span class="keyword">go</span> version go1<span class="number">.14</span><span class="number">.9</span> darwin/amd64</span><br></pre></td></tr></table></figure>
<h3 id="最近有这么个坑"><a class="header-anchor" href="#最近有这么个坑">¶</a>最近有这么个坑:</h3>
<blockquote>
<p>碰到内存泄露问题，大致是这样的：</p>
</blockquote>
<ul>
<li>1、定义一个全局map</li>
<li>2、给里面放值</li>
<li>3、用完之后删除Key/value</li>
</ul>
<h3 id="问题：map删除完key后，Mem有没有被释放？"><a class="header-anchor" href="#问题：map删除完key后，Mem有没有被释放？">¶</a>问题：map删除完key后，Mem有没有被释放？</h3>
<a id="more"></a>
<h3 id="观察内存变化："><a class="header-anchor" href="#观察内存变化：">¶</a>观察内存变化：</h3>
<h4 id="情景1-只删除Map的k-v"><a class="header-anchor" href="#情景1-只删除Map的k-v">¶</a>情景1: 只删除Map的k/v</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> cnt = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	printMemStats()</span><br><span class="line">	initMap()</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		<span class="built_in">delete</span>(intMap, i)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	<span class="comment">//intMap = nil</span></span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	intMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, cnt)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		intMap[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMemStats</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m runtime.MemStats</span><br><span class="line">	runtime.ReadMemStats(&amp;m)</span><br><span class="line">	log.Printf(<span class="string">&quot;Alloc = %v TotalAlloc = %v Sys = %v NumGC = %v\n&quot;</span>, m.Alloc/<span class="number">1024</span>, m.TotalAlloc/<span class="number">1024</span>, m.Sys/<span class="number">1024</span>, m.NumGC)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="输出："><a class="header-anchor" href="#输出：">¶</a>输出：</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">26</span> Alloc = <span class="number">162</span> TotalAlloc = <span class="number">162</span> Sys = <span class="number">69714</span> NumGC = <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">26</span> Alloc = <span class="number">471</span> TotalAlloc = <span class="number">487</span> Sys = <span class="number">70290</span> NumGC = <span class="number">1</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">26</span> <span class="number">8192</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">26</span> <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">26</span> Alloc = <span class="number">473</span> TotalAlloc = <span class="number">490</span> Sys = <span class="number">70610</span> NumGC = <span class="number">2</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">26</span> Alloc = <span class="number">475</span> TotalAlloc = <span class="number">494</span> Sys = <span class="number">70610</span> NumGC = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="情景2-删除map的k-v-并置map为nil"><a class="header-anchor" href="#情景2-删除map的k-v-并置map为nil">¶</a>情景2: 删除map的k/v,并置map为nil</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> cnt = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	printMemStats()</span><br><span class="line">	initMap()</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		<span class="built_in">delete</span>(intMap, i)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	intMap = <span class="literal">nil</span></span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	intMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, cnt)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		intMap[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMemStats</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m runtime.MemStats</span><br><span class="line">	runtime.ReadMemStats(&amp;m)</span><br><span class="line">	log.Printf(<span class="string">&quot;Alloc = %v TotalAlloc = %v Sys = %v NumGC = %v\n&quot;</span>, m.Alloc/<span class="number">1024</span>, m.TotalAlloc/<span class="number">1024</span>, m.Sys/<span class="number">1024</span>, m.NumGC)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="输出：-v2"><a class="header-anchor" href="#输出：-v2">¶</a>输出：</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">40</span> Alloc = <span class="number">161</span> TotalAlloc = <span class="number">161</span> Sys = <span class="number">69714</span> NumGC = <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">40</span> Alloc = <span class="number">469</span> TotalAlloc = <span class="number">484</span> Sys = <span class="number">71696</span> NumGC = <span class="number">1</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">40</span> <span class="number">8192</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">40</span> <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">40</span> Alloc = <span class="number">471</span> TotalAlloc = <span class="number">488</span> Sys = <span class="number">71760</span> NumGC = <span class="number">2</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">40</span> Alloc = <span class="number">160</span> TotalAlloc = <span class="number">492</span> Sys = <span class="number">71760</span> NumGC = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="情景3-map放在函数中，并删除map的k-v-不置nil"><a class="header-anchor" href="#情景3-map放在函数中，并删除map的k-v-不置nil">¶</a>情景3: map放在函数中，并删除map的k/v,不置nil</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> intMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> cnt = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	printMemStats()</span><br><span class="line">	other()</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">other</span><span class="params">()</span></span>&#123;</span><br><span class="line">	initMap()</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		<span class="built_in">delete</span>(intMap, i)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	<span class="comment">//intMap = nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	intMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, cnt)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		intMap[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMemStats</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m runtime.MemStats</span><br><span class="line">	runtime.ReadMemStats(&amp;m)</span><br><span class="line">	log.Printf(<span class="string">&quot;Alloc = %v TotalAlloc = %v Sys = %v NumGC = %v\n&quot;</span>, m.Alloc/<span class="number">1024</span>, m.TotalAlloc/<span class="number">1024</span>, m.Sys/<span class="number">1024</span>, m.NumGC)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="输出：-v3"><a class="header-anchor" href="#输出：-v3">¶</a>输出：</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">35</span> Alloc = <span class="number">161</span> TotalAlloc = <span class="number">161</span> Sys = <span class="number">69458</span> NumGC = <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">35</span> Alloc = <span class="number">469</span> TotalAlloc = <span class="number">484</span> Sys = <span class="number">71440</span> NumGC = <span class="number">1</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">35</span> <span class="number">8192</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">35</span> <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">35</span> Alloc = <span class="number">471</span> TotalAlloc = <span class="number">488</span> Sys = <span class="number">71504</span> NumGC = <span class="number">2</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">35</span> Alloc = <span class="number">473</span> TotalAlloc = <span class="number">492</span> Sys = <span class="number">71504</span> NumGC = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="情景4-map放在函数中，并删除map的k-v-map置为nil"><a class="header-anchor" href="#情景4-map放在函数中，并删除map的k-v-map置为nil">¶</a>情景4: map放在函数中，并删除map的k/v,map置为nil</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> intMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> cnt = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	printMemStats()</span><br><span class="line">	other()</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">other</span><span class="params">()</span></span>&#123;</span><br><span class="line">	initMap()</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		<span class="built_in">delete</span>(intMap, i)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	intMap = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	intMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, cnt)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		intMap[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMemStats</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m runtime.MemStats</span><br><span class="line">	runtime.ReadMemStats(&amp;m)</span><br><span class="line">	log.Printf(<span class="string">&quot;Alloc = %v TotalAlloc = %v Sys = %v NumGC = %v\n&quot;</span>, m.Alloc/<span class="number">1024</span>, m.TotalAlloc/<span class="number">1024</span>, m.Sys/<span class="number">1024</span>, m.NumGC)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="输出：-v4"><a class="header-anchor" href="#输出：-v4">¶</a>输出：</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">02</span> Alloc = <span class="number">161</span> TotalAlloc = <span class="number">161</span> Sys = <span class="number">69714</span> NumGC = <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">02</span> Alloc = <span class="number">469</span> TotalAlloc = <span class="number">484</span> Sys = <span class="number">70034</span> NumGC = <span class="number">1</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">02</span> <span class="number">8192</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">02</span> <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">02</span> Alloc = <span class="number">471</span> TotalAlloc = <span class="number">488</span> Sys = <span class="number">70098</span> NumGC = <span class="number">2</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">02</span> Alloc = <span class="number">160</span> TotalAlloc = <span class="number">492</span> Sys = <span class="number">70098</span> NumGC = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="情景5-map定义放在局部变量中："><a class="header-anchor" href="#情景5-map定义放在局部变量中：">¶</a>情景5: map定义放在局部变量中：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cnt = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	printMemStats()</span><br><span class="line">	other()</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">other</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> intMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">	intMap = initMap(intMap)</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		<span class="built_in">delete</span>(intMap, i)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="built_in">len</span>(intMap))</span><br><span class="line">	runtime.GC()</span><br><span class="line">	printMemStats()</span><br><span class="line">	<span class="comment">//intMap = nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMap</span><span class="params">(intMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span> <span class="title">map</span>[<span class="title">int</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">	intMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, cnt)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		intMap[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> intMap</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMemStats</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m runtime.MemStats</span><br><span class="line">	runtime.ReadMemStats(&amp;m)</span><br><span class="line">	log.Printf(<span class="string">&quot;Alloc = %v TotalAlloc = %v Sys = %v NumGC = %v\n&quot;</span>, m.Alloc/<span class="number">1024</span>, m.TotalAlloc/<span class="number">1024</span>, m.Sys/<span class="number">1024</span>, m.NumGC)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="输出：-v5"><a class="header-anchor" href="#输出：-v5">¶</a>输出：</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">29</span>:<span class="number">54</span> Alloc = <span class="number">161</span> TotalAlloc = <span class="number">161</span> Sys = <span class="number">69458</span> NumGC = <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">29</span>:<span class="number">54</span> Alloc = <span class="number">469</span> TotalAlloc = <span class="number">484</span> Sys = <span class="number">71440</span> NumGC = <span class="number">1</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">29</span>:<span class="number">54</span> <span class="number">8192</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">29</span>:<span class="number">54</span> <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">29</span>:<span class="number">54</span> Alloc = <span class="number">158</span> TotalAlloc = <span class="number">488</span> Sys = <span class="number">71504</span> NumGC = <span class="number">2</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">01</span>/<span class="number">06</span> <span class="number">16</span>:<span class="number">29</span>:<span class="number">54</span> Alloc = <span class="number">160</span> TotalAlloc = <span class="number">491</span> Sys = <span class="number">71504</span> NumGC = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h5 id="汇编输出："><a class="header-anchor" href="#汇编输出：">¶</a>汇编输出：</h5>
<p>比较有意思的一行：</p>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/clipboard_20210106_051000.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XORL 异或运算符 </span><br><span class="line"></span><br><span class="line">XORL AX,AX ---&gt;将AX置0值</span><br></pre></td></tr></table></figure>
<h4 id="delete函数："><a class="header-anchor" href="#delete函数：">¶</a>delete函数：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0125</span> <span class="number">00293</span> (../<span class="number">1126</span>/main.<span class="keyword">go</span>:<span class="number">26</span>)	CALL	runtime.mapdelete_fast64(SB)</span><br></pre></td></tr></table></figure>
<h5 id="mapdelete-fast64函数作用："><a class="header-anchor" href="#mapdelete-fast64函数作用：">¶</a>mapdelete_fast64函数作用：</h5>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/map_fast64.go#L272">点击Github查看</a></p>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/clipboard_20210106_052140.png" alt=""></p>
<blockquote>
<p>有意思的是：map的设计就是这样，删除key，只是把这个槽位置empty，并没有释放内存.</p>
</blockquote>
<h3 id="Others"><a class="header-anchor" href="#Others">¶</a>Others:</h3>
<h4 id="其它场景："><a class="header-anchor" href="#其它场景：">¶</a>其它场景：</h4>
<blockquote>
<p>场景有很多，这里只是逻列最简单的，至于用指针之类的，有兴趣了再研究研究，方法都是一样的。</p>
</blockquote>
<h4 id="汇编代码生成"><a class="header-anchor" href="#汇编代码生成">¶</a>汇编代码生成</h4>
<ul>
<li>详细见此文：<a href="https://blog.imrcrab.com/archives/2ce846ed.html">「15」Plan9 汇编小记</a></li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>Map</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>「28」sync-mutex传参复制问题</title>
    <url>/archives/a82ae489.html</url>
    <content><![CDATA[<h3 id="Go-version"><a class="header-anchor" href="#Go-version">¶</a>Go version:</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">7384</span> ◯  <span class="keyword">go</span> version</span><br><span class="line"><span class="keyword">go</span> version go1<span class="number">.14</span><span class="number">.9</span> darwin/amd64</span><br></pre></td></tr></table></figure>
<h3 id="起因"><a class="header-anchor" href="#起因">¶</a>起因:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sync.Mutex当参数,值传递后出错.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="现象"><a class="header-anchor" href="#现象">¶</a>现象:</h3>
<blockquote>
<p>不废话,上代码:</p>
</blockquote>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">AddAge</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	p.mux.Lock()</span><br><span class="line">	age++</span><br><span class="line">	<span class="keyword">defer</span> p.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := Person&#123;</span><br><span class="line">		mux: sync.Mutex&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Add(<span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> p1.AddAge()</span><br><span class="line">	&#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    </span><br><span class="line">	fmt.Println(age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="这个age的输出应该是多少"><a class="header-anchor" href="#这个age的输出应该是多少">¶</a>这个age的输出应该是多少?</h4>
<h4 id="不妨可以多尝试几次-结果"><a class="header-anchor" href="#不妨可以多尝试几次-结果">¶</a>不妨可以多尝试几次,结果:</h4>
<blockquote>
<p>100/99/98都有可能.</p>
</blockquote>
<h3 id="What-Lock难道不是加锁的么"><a class="header-anchor" href="#What-Lock难道不是加锁的么">¶</a>What? Lock难道不是加锁的么</h3>
<blockquote>
<p>Lock加锁难道不是这么用的么,颠覆认知!</p>
</blockquote>
<h4 id="Lock源码"><a class="header-anchor" href="#Lock源码">¶</a>Lock源码:</h4>
<p><em>A Mutex must not be copied after first use</em></p>
<h3 id="根源"><a class="header-anchor" href="#根源">¶</a>根源:</h3>
<ul>
<li>Go参数传递属于值传递</li>
<li>Mutex复制后中的state属于前一状态,没有改变</li>
<li>Mutex中的Lock和Unlock「方法」属于指针类型<sup>图1</sup></li>
</ul>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/clipboard_20210102_102753.png" alt=""><br>
<strong><center>图<sup>1</sup></center></strong></p>
<h3 id="解决办法"><a class="header-anchor" href="#解决办法">¶</a>解决办法</h3>
<ul>
<li>当然是参考源码,「图1」</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">缺点:</span><br><span class="line">    每次使用之前需要初始化,毕竟是指针类型的</span><br><span class="line"></span><br><span class="line">优点:</span><br><span class="line">    设计源于源码,追随Go的设计.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>加锁的地方尽量是全局的</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">这个就不分析了,毕竟不适用所有场景.</span><br><span class="line"></span><br><span class="line">不适用的场景:</span><br><span class="line">    临时的Map需要加锁,如果用全局锁,则效率降低.</span><br></pre></td></tr></table></figure>
<h3 id="Sync包不可复制性"><a class="header-anchor" href="#Sync包不可复制性">¶</a>Sync包不可复制性</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">使用sync包下的功能,可能得注意了,都是不可复制的.</span><br></pre></td></tr></table></figure>
<h3 id="End"><a class="header-anchor" href="#End">¶</a>End</h3>
<blockquote>
<p>每次看源码,都会有不一样的收获.「也许是我理解能力差哈」</p>
</blockquote>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>sync</tag>
        <tag>Mutex</tag>
      </tags>
  </entry>
  <entry>
    <title>「27」Time Zone时区详解</title>
    <url>/archives/513dbeba.html</url>
    <content><![CDATA[<p>时区，无关语言，在任何一个系统中都会用到：</p>
<ul>
<li>time「时间」</li>
<li>timeID「时间作为唯一标识」</li>
<li>time to unix</li>
<li>unix to time string</li>
<li>…</li>
</ul>
<blockquote>
<p>很多场景都会看到这个时间的重要性，这次看到16的特性中有一个修改项，觉得自己对time和zone了解的太少了，以此记录，以便积累。</p>
</blockquote>
<a id="more"></a>
<h3 id="Go-version"><a class="header-anchor" href="#Go-version">¶</a>Go version:</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">7384</span> ◯  <span class="keyword">go</span> version</span><br><span class="line"><span class="keyword">go</span> version go1<span class="number">.14</span><span class="number">.9</span> darwin/amd64</span><br></pre></td></tr></table></figure>
<h3 id="时区-UTC-GMT-MDT-CST"><a class="header-anchor" href="#时区-UTC-GMT-MDT-CST">¶</a>时区 UTC\GMT\MDT\CST</h3>
<blockquote>
<p>说到时间，肯定得想到时区问题，咱们国家还好，只有一个Beijing时区，美国本土。。。。四个时区「晕了」</p>
</blockquote>
<p>Ps: <a href="https://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9C%8B%E6%99%82%E5%8D%80">点击查看四个时区</a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">GMT (Greenwich Mean Time)的缩写，指的是皇家格林威治天文台的标准时间，称作格林威治时间，因为本初子午线通过此地区，因此也称为世界标准时间。然而地球的自转不是完全规律的，而且正逐渐减慢，因此自1924年开始，格林威治时间(GMT)已经不再被视为标准时间，取而代之的是&quot;世界协调时间&quot; (UTC: Coordinated Universal Time)</span><br><span class="line"></span><br><span class="line">UTC 协调世界时（Coordinated Universal Time）是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间。UTC 是一个标准，而不是一个时区</span><br><span class="line"></span><br><span class="line">CST</span><br><span class="line"> 北京时间，China Standard Time，中国标准时间，是中国的标准时间。在时区划分上，属东八区，比协调世界时早8小时，记为UTC+8</span><br></pre></td></tr></table></figure>
<h3 id="Go中的时区问题"><a class="header-anchor" href="#Go中的时区问题">¶</a>Go中的时区问题</h3>
<p>有一个函数可以说明这个时区问题：</p>
<ul>
<li>time.LoadLocation</li>
</ul>
<blockquote>
<p>如果你查查源码，就会发现这个函数上面写着时区的问题，也跟不用百度时区，有的自然支持，没有的写了就是乱写了。</p>
</blockquote>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/clipboard_20201228_112003.png" alt=""></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">查询的时区一直就在你goroot路径下的一个压缩文件中。</span><br></pre></td></tr></table></figure>
<p>具体的有兴趣可以去看看所有的时区，后续也就有一个全面的了解了：</p>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/clipboard_20201228_112408.png" alt=""></p>
<h3 id="Go-中对于时间的使用"><a class="header-anchor" href="#Go-中对于时间的使用">¶</a>Go 中对于时间的使用</h3>
<blockquote>
<p>待更新…</p>
</blockquote>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title>「26」Go 1.16 特性</title>
    <url>/archives/4f05d45d.html</url>
    <content><![CDATA[<p>Go 1.16特性：</p>
<a id="more"></a>
<h2 id="json自定义「issues-5901」"><a class="header-anchor" href="#json自定义「issues-5901」">¶</a>json自定义<a href="https://github.com/golang/go/issues/5901">「issues 5901」</a></h2>
<h3 id="「Feat」"><a class="header-anchor" href="#「Feat」">¶</a>「Feat」</h3>
<h3 id="起源："><a class="header-anchor" href="#起源：">¶</a>起源：</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">For example, if a user wants to marshal net.IP with custom code, we should provide a way</span><br><span class="line">to do that, probably a method on *Encoder. Similarly for *Decoder.</span><br><span class="line"></span><br><span class="line">Same for encoding&#x2F;xml</span><br></pre></td></tr></table></figure>
<h3 id="变更："><a class="header-anchor" href="#变更：">¶</a>变更：</h3>
<p><a href="https://go-review.googlesource.com/c/go/+/31091">coding:</a></p>
<h3 id="使用教程："><a class="header-anchor" href="#使用教程：">¶</a><a href="https://github.com/golang/go/issues/5901#issuecomment-566269861">使用教程：</a></h3>
<h2 id="GMT和MDT时区问题「issues-43354」"><a class="header-anchor" href="#GMT和MDT时区问题「issues-43354」">¶</a>GMT和MDT时区问题<a href="https://github.com/golang/go/issues/43354">「issues 43354」</a></h2>
<h3 id="「Fix」"><a class="header-anchor" href="#「Fix」">¶</a>「Fix」</h3>
<h3 id="问题："><a class="header-anchor" href="#问题：">¶</a>问题：</h3>
<blockquote>
<p>主要修复一个时区问题 MDT or GMT ？</p>
</blockquote>
<p><a href="https://github.com/golang/go/issues/43354#issuecomment-750490418">官方reply</a><br>
<a href="https://go-review.googlesource.com/c/go/+/280072/">go-review</a></p>
<h2 id="go-get-d「issues-43131」"><a class="header-anchor" href="#go-get-d「issues-43131」">¶</a>go get -d<a href="https://github.com/golang/go/issues/43131">「issues 43131」</a></h2>
<h3 id="「Feat」-v2"><a class="header-anchor" href="#「Feat」-v2">¶</a>「Feat」</h3>
<h3 id="变更：-v2"><a class="header-anchor" href="#变更：-v2">¶</a>变更：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cmd/<span class="keyword">go</span>新增：「仅下载，不使用此依赖」</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> get -d</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="go-mod-download无法指定版本「issues-42524」"><a class="header-anchor" href="#go-mod-download无法指定版本「issues-42524」">¶</a>go mod download无法指定版本<a href="https://github.com/golang/go/issues/42524">「issues 42524」</a></h2>
<h3 id="「Fix」-v2"><a class="header-anchor" href="#「Fix」-v2">¶</a>「Fix」</h3>
<h3 id="变更：-v3"><a class="header-anchor" href="#变更：-v3">¶</a>变更：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">modify 指定版本可以download</span><br></pre></td></tr></table></figure>
<h3 id="review"><a class="header-anchor" href="#review">¶</a><a href="https://go-review.googlesource.com/c/go/+/270520/">review</a></h3>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/clipboard_20201228_011910.png" alt=""></p>
<h2 id="ParseDir-指定-go作为后缀的bug「issues-42951」"><a class="header-anchor" href="#ParseDir-指定-go作为后缀的bug「issues-42951」">¶</a>ParseDir 指定.go作为后缀的bug<a href="https://github.com/golang/go/issues/42951">「issues 42951」</a></h2>
<h3 id="「Fix」-v3"><a class="header-anchor" href="#「Fix」-v3">¶</a>「Fix」</h3>
<h3 id="变更：-v4"><a class="header-anchor" href="#变更：-v4">¶</a>变更：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">以.<span class="keyword">go</span>结尾的文件夹，ParseDir无法转换</span><br></pre></td></tr></table></figure>
<h3 id="review-v2"><a class="header-anchor" href="#review-v2">¶</a><a href="https://github.com/golang/go/commit/48838c35dc7c8e938a83db66faabf3a51f4adc3d">review</a></h3>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/clipboard_20201228_013355.png" alt=""></p>
<h2 id="strconv-ParseComplex未处理32位数字「issues-40706」"><a class="header-anchor" href="#strconv-ParseComplex未处理32位数字「issues-40706」">¶</a>strconv:ParseComplex未处理32位数字<a href="https://github.com/golang/go/issues/40706">「issues 40706」</a></h2>
<h3 id="「Fix」-v4"><a class="header-anchor" href="#「Fix」-v4">¶</a>「Fix」</h3>
<h3 id="变更：-v5"><a class="header-anchor" href="#变更：-v5">¶</a>变更：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">处理<span class="number">32</span>bitsize，需要返回error。</span><br></pre></td></tr></table></figure>
<h3 id="review-v3"><a class="header-anchor" href="#review-v3">¶</a><a href="https://go-review.googlesource.com/c/go/+/248219/">review</a></h3>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/clipboard_20201228_051536.png" alt=""></p>
<h2 id="runtime-getMcache-「issues-42339」"><a class="header-anchor" href="#runtime-getMcache-「issues-42339」">¶</a>runtime {getMcache} <a href="https://github.com/golang/go/issues/42339">「issues 42339」</a></h2>
<h3 id="「Fix」-v5"><a class="header-anchor" href="#「Fix」-v5">¶</a>「Fix」</h3>
<h3 id="变更"><a class="header-anchor" href="#变更">¶</a>变更</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">runtime: <span class="built_in">make</span> getMCache inlineable</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="review-v4"><a class="header-anchor" href="#review-v4">¶</a>review</h3>
<ul>
<li>
<p><a href="https://go-review.googlesource.com/c/go/+/267158/">runtime: decouple consistent stats from mcache and allow P-less update</a></p>
</li>
<li>
<p><a href="https://go-review.googlesource.com/c/go/+/267157/">runtime: make getMCache inlineable</a></p>
</li>
</ul>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/clipboard_20201228_081048.png" alt=""></p>
<h3 id="持续更…"><a class="header-anchor" href="#持续更…">¶</a>持续更…</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>v1.16</tag>
        <tag>encoding/json</tag>
      </tags>
  </entry>
  <entry>
    <title>「25」GPM sysmon函数</title>
    <url>/archives/c770fe49.html</url>
    <content><![CDATA[<p>前面主要是了解newm的全过程和其中难过一些细节逻辑，，，<br>
如果没了解的，建议先去看下大概的过程，虽然不是非常详细，<br>
最起码得知道newm过程，主要完成了什么操作，有利于后续理解。</p>
<p>这次主要是来学学这个sysmon，系统监控调度的逻辑。</p>
<a id="more"></a>
<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p>在深入之前呢，先对下面这些变量有个概念，后续提到也就不陌生了。「摘抄自sysmon函数」</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	allglen    <span class="keyword">uintptr</span> <span class="comment">//g</span></span><br><span class="line">	allm       *m      <span class="comment">//m</span></span><br><span class="line">	allp       []*p  <span class="comment">// p     len(allp) == gomaxprocs; may change at safe points, otherwise immutable</span></span><br><span class="line">	allpLock   mutex <span class="comment">// 全局lock。   Protects P-less reads of allp and all writes</span></span><br><span class="line">	gomaxprocs <span class="keyword">int32</span> <span class="comment">//最大process数量</span></span><br><span class="line">	ncpu       <span class="keyword">int32</span> <span class="comment">//cpu个数</span></span><br><span class="line">	forcegc    forcegcstate <span class="comment">//强制GC</span></span><br><span class="line">	sched      schedt <span class="comment">//预分配的一些变量值</span></span><br><span class="line">	newprocs   <span class="keyword">int32</span>  <span class="comment">//新的process</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Information about what cpu features are available.</span></span><br><span class="line">	<span class="comment">// Packages outside the runtime should not use these</span></span><br><span class="line">	<span class="comment">// as they are not an external api.</span></span><br><span class="line">	<span class="comment">// Set on startup in asm_&#123;386,amd64&#125;.s</span></span><br><span class="line">	processorVersionInfo <span class="keyword">uint32</span></span><br><span class="line">	isIntel              <span class="keyword">bool</span></span><br><span class="line">	lfenceBeforeRdtsc    <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	goarm                <span class="keyword">uint8</span> <span class="comment">// set by cmd/link on arm systems</span></span><br><span class="line">	framepointer_enabled <span class="keyword">bool</span>  <span class="comment">// set by cmd/link</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="sysmon函数"><a class="header-anchor" href="#sysmon函数">¶</a>sysmon函数</h3>
<h4 id="概览"><a class="header-anchor" href="#概览">¶</a>概览</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lock(&amp;sched.lock)<span class="comment">//加锁</span></span><br><span class="line">	sched.nmsys++ <span class="comment">//数量+1</span></span><br><span class="line">	checkdead() <span class="comment">//检查是否dead</span></span><br><span class="line">	unlock(&amp;sched.lock) <span class="comment">//释放lock</span></span><br><span class="line"></span><br><span class="line">	lasttrace := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">	idle := <span class="number">0</span> <span class="comment">// how many cycles in succession we had not wokeup somebody</span></span><br><span class="line">	delay := <span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/GPM-sysmon-1.png" alt=""></p>
<h3 id="循环干什么？"><a class="header-anchor" href="#循环干什么？">¶</a>循环干什么？</h3>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/clipboard_20201206_085755.png" alt=""></p>
<blockquote>
<p>一个个过吧</p>
</blockquote>
<h4 id="获取系统的纳秒时间"><a class="header-anchor" href="#获取系统的纳秒时间">¶</a>获取系统的纳秒时间</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := nanotime()</span><br></pre></td></tr></table></figure>
<h4 id="timeSleepUntil"><a class="header-anchor" href="#timeSleepUntil">¶</a>timeSleepUntil</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// timeSleepUntil returns the time when the next timer should fire,</span></span><br><span class="line"><span class="comment">// and the P that holds the timer heap that that timer is on.</span></span><br><span class="line"><span class="comment">// This is only called by sysmon and checkdead.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeSleepUntil</span><span class="params">()</span> <span class="params">(<span class="keyword">int64</span>, *p)</span></span> &#123;</span><br><span class="line">	next := <span class="keyword">int64</span>(maxWhen)</span><br><span class="line">	<span class="keyword">var</span> pret *p</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prevent allp slice changes. This is like retake.</span></span><br><span class="line">	lock(&amp;allpLock)</span><br><span class="line">	<span class="keyword">for</span> _, pp := <span class="keyword">range</span> allp &#123;</span><br><span class="line">		<span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// This can happen if procresize has grown</span></span><br><span class="line">			<span class="comment">// allp but not yet created new Ps.</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		c := atomic.Load(&amp;pp.adjustTimers)</span><br><span class="line">		<span class="keyword">if</span> c == <span class="number">0</span> &#123;</span><br><span class="line">			w := <span class="keyword">int64</span>(atomic.Load64(&amp;pp.timer0When))</span><br><span class="line">			<span class="comment">//划重点</span></span><br><span class="line">			<span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; w &lt; next &#123;</span><br><span class="line">				next = w</span><br><span class="line">				pret = pp</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		lock(&amp;pp.timersLock)</span><br><span class="line">		<span class="keyword">for</span> _, t := <span class="keyword">range</span> pp.timers &#123;</span><br><span class="line">			<span class="comment">//划重点</span></span><br><span class="line">			<span class="keyword">switch</span> s := atomic.Load(&amp;t.status); s &#123;</span><br><span class="line">			<span class="keyword">case</span> timerWaiting:</span><br><span class="line">				<span class="keyword">if</span> t.when &lt; next &#123;</span><br><span class="line">					next = t.when</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">case</span> timerModifiedEarlier, timerModifiedLater:</span><br><span class="line">				<span class="keyword">if</span> t.nextwhen &lt; next &#123;</span><br><span class="line">					next = t.nextwhen</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> s == timerModifiedEarlier &#123;</span><br><span class="line">					c--</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// The timers are sorted, so we only have to check</span></span><br><span class="line">			<span class="comment">// the first timer for each P, unless there are</span></span><br><span class="line">			<span class="comment">// some timerModifiedEarlier timers. The number</span></span><br><span class="line">			<span class="comment">// of timerModifiedEarlier timers is in the adjustTimers</span></span><br><span class="line">			<span class="comment">// field, used to initialize c, above.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// We don&#x27;t worry about cases like timerModifying.</span></span><br><span class="line">			<span class="comment">// New timers can show up at any time,</span></span><br><span class="line">			<span class="comment">// so this function is necessarily imprecise.</span></span><br><span class="line">			<span class="comment">// Do a signed check here since we aren&#x27;t</span></span><br><span class="line">			<span class="comment">// synchronizing the read of pp.adjustTimers</span></span><br><span class="line">			<span class="comment">// with the check of a timer status.</span></span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">int32</span>(c) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;pp.timersLock)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;allpLock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> next, pret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sched和gomaxprocs判断「sleep-wakeup过程」"><a class="header-anchor" href="#sched和gomaxprocs判断「sleep-wakeup过程」">¶</a>sched和gomaxprocs判断「sleep&amp;wakeup过程」</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双层判断，防止在加锁这段时间值发生变化</span></span><br><span class="line"><span class="keyword">if</span> debug.schedtrace &lt;= <span class="number">0</span> &amp;&amp; (sched.gcwaiting != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="keyword">uint32</span>(gomaxprocs)) &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">if</span> atomic.Load(&amp;sched.gcwaiting) != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="keyword">uint32</span>(gomaxprocs) &#123;</span><br><span class="line">				<span class="keyword">if</span> next &gt; now &#123;</span><br><span class="line">					atomic.Store(&amp;sched.sysmonwait, <span class="number">1</span>)</span><br><span class="line">					unlock(&amp;sched.lock)</span><br><span class="line">					<span class="comment">// Make wake-up period small enough</span></span><br><span class="line">					<span class="comment">// for the sampling to be correct.</span></span><br><span class="line">					sleep := forcegcperiod / <span class="number">2</span></span><br><span class="line">					<span class="keyword">if</span> next-now &lt; sleep &#123;</span><br><span class="line">						sleep = next - now</span><br><span class="line">					&#125;</span><br><span class="line">					shouldRelax := sleep &gt;= osRelaxMinNS</span><br><span class="line">					<span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">						osRelax(<span class="literal">true</span>)</span><br><span class="line">					&#125;</span><br><span class="line">					notetsleep(&amp;sched.sysmonnote, sleep)</span><br><span class="line">					<span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">						osRelax(<span class="literal">false</span>)</span><br><span class="line">					&#125;</span><br><span class="line">					now = nanotime()</span><br><span class="line">					next, _ = timeSleepUntil()</span><br><span class="line">					lock(&amp;sched.lock)</span><br><span class="line">					atomic.Store(&amp;sched.sysmonwait, <span class="number">0</span>)</span><br><span class="line">					noteclear(&amp;sched.sysmonnote)</span><br><span class="line">				&#125;</span><br><span class="line">				idle = <span class="number">0</span></span><br><span class="line">				delay = <span class="number">20</span></span><br><span class="line">			&#125;</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h4 id="poll-network"><a class="header-anchor" href="#poll-network">¶</a>poll network</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// poll network if not polled for more than 10ms</span></span><br><span class="line">lastpoll := <span class="keyword">int64</span>(atomic.Load64(&amp;sched.lastpoll))</span><br><span class="line"><span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">	atomic.Cas64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(lastpoll), <span class="keyword">uint64</span>(now))</span><br><span class="line">	list := netpoll(<span class="number">0</span>) <span class="comment">// non-blocking - returns list of goroutines</span></span><br><span class="line">	<span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">		<span class="comment">// Need to decrement number of idle locked M&#x27;s</span></span><br><span class="line">		<span class="comment">// (pretending that one more is running) before injectglist.</span></span><br><span class="line">		<span class="comment">// Otherwise it can lead to the following situation:</span></span><br><span class="line">		<span class="comment">// injectglist grabs all P&#x27;s but before it starts M&#x27;s to run the P&#x27;s,</span></span><br><span class="line">		<span class="comment">// another M returns from syscall, finishes running its G,</span></span><br><span class="line">		<span class="comment">// observes that there is no work to do and no other running M&#x27;s</span></span><br><span class="line">		<span class="comment">// and reports deadlock.</span></span><br><span class="line">		incidlelocked(<span class="number">-1</span>)</span><br><span class="line">		injectglist(&amp;list)</span><br><span class="line">		incidlelocked(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> next &lt; now &#123;</span><br><span class="line">	<span class="comment">// There are timers that should have already run,</span></span><br><span class="line">	<span class="comment">// perhaps because there is an unpreemptible P.</span></span><br><span class="line">	<span class="comment">// Try to start an M to run them.</span></span><br><span class="line">	<span class="comment">//划重点</span></span><br><span class="line">	startm(<span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="wakeScavenger"><a class="header-anchor" href="#wakeScavenger">¶</a>wakeScavenger</h4>
<blockquote>
<p>判断需要唤醒请求</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.Load(&amp;scavenge.sysmonWake) != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="comment">// Kick the scavenger awake if someone requested it.</span></span><br><span class="line">	wakeScavenger()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wakeScavenger immediately unparks the scavenger if necessary.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// May run without a P, but it may allocate, so it must not be called</span></span><br><span class="line"><span class="comment">// on any allocation path.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// mheap_.lock, scavenge.lock, and sched.lock must not be held.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wakeScavenger</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lock(&amp;scavenge.lock)</span><br><span class="line">	<span class="keyword">if</span> scavenge.parked &#123;</span><br><span class="line">		<span class="comment">// Notify sysmon that it shouldn&#x27;t bother waking up the scavenger.</span></span><br><span class="line">		atomic.Store(&amp;scavenge.sysmonWake, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Try to stop the timer but we don&#x27;t really care if we succeed.</span></span><br><span class="line">		<span class="comment">// It&#x27;s possible that either a timer was never started, or that</span></span><br><span class="line">		<span class="comment">// we&#x27;re racing with it.</span></span><br><span class="line">		<span class="comment">// In the case that we&#x27;re racing with there&#x27;s the low chance that</span></span><br><span class="line">		<span class="comment">// we experience a spurious wake-up of the scavenger, but that&#x27;s</span></span><br><span class="line">		<span class="comment">// totally safe.</span></span><br><span class="line">		stopTimer(scavenge.timer)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Unpark the goroutine and tell it that there may have been a pacing</span></span><br><span class="line">		<span class="comment">// change. Note that we skip the scheduler&#x27;s runnext slot because we</span></span><br><span class="line">		<span class="comment">// want to avoid having the scavenger interfere with the fair</span></span><br><span class="line">		<span class="comment">// scheduling of user goroutines. In effect, this schedules the</span></span><br><span class="line">		<span class="comment">// scavenger at a &quot;lower priority&quot; but that&#x27;s OK because it&#x27;ll</span></span><br><span class="line">		<span class="comment">// catch up on the work it missed when it does get scheduled.</span></span><br><span class="line">		scavenge.parked = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Ready the goroutine by injecting it. We use injectglist instead</span></span><br><span class="line">		<span class="comment">// of ready or goready in order to allow us to run this function</span></span><br><span class="line">		<span class="comment">// without a P. injectglist also avoids placing the goroutine in</span></span><br><span class="line">		<span class="comment">// the current P&#x27;s runnext slot, which is desireable to prevent</span></span><br><span class="line">		<span class="comment">// the scavenger from interfering with user goroutine scheduling</span></span><br><span class="line">		<span class="comment">// too much.</span></span><br><span class="line">		<span class="keyword">var</span> list gList</span><br><span class="line">		list.push(scavenge.g)</span><br><span class="line">		injectglist(&amp;list)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;scavenge.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="retake夺取"><a class="header-anchor" href="#retake夺取">¶</a>retake夺取</h4>
<blockquote>
<p>夺取空闲的P</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// retake P&#x27;s blocked in syscalls</span></span><br><span class="line"><span class="comment">// and preempt long running G&#x27;s</span></span><br><span class="line"><span class="keyword">if</span> retake(now) != <span class="number">0</span> &#123;</span><br><span class="line">	idle = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	idle++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GC-判断"><a class="header-anchor" href="#GC-判断">¶</a>GC 判断</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// check if we need to force a GC</span></span><br><span class="line"><span class="comment">//划重点 t.test()</span></span><br><span class="line"><span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != <span class="number">0</span> &#123;</span><br><span class="line">	lock(&amp;forcegc.lock)</span><br><span class="line">	forcegc.idle = <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> list gList</span><br><span class="line">	list.push(forcegc.g)</span><br><span class="line">	injectglist(&amp;list)</span><br><span class="line">	unlock(&amp;forcegc.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="待续…"><a class="header-anchor" href="#待续…">¶</a>待续…</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>GPM</tag>
        <tag>Go源码</tag>
      </tags>
  </entry>
  <entry>
    <title>「24」GPM newm函数</title>
    <url>/archives/b4edbd7.html</url>
    <content><![CDATA[<p>上节看了go的入口函数，，，也就是你执行main函数前后所做的准备工作。</p>
<p>继续深入学习。「newm」第一个M，到底是怎么来的？</p>
<a id="more"></a>
<blockquote>
<p>go version: 1.14.3</p>
</blockquote>
<h3 id="入口"><a class="header-anchor" href="#入口">¶</a>入口</h3>
<p>先看下主体，主要在M创建的过程中，干了what，，，，，「PS : 关键看值得学习的点」</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a new m. It will start off with a call to fn, or else the scheduler.</span></span><br><span class="line"><span class="comment">// fn needs to be static and not a heap allocated closure.</span></span><br><span class="line"><span class="comment">// May run with m.p==nil, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm</span><span class="params">(fn <span class="keyword">func</span>()</span>, _<span class="title">p_</span> *<span class="title">p</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//分配内存</span></span><br><span class="line">	mp := allocm(_p_, fn)</span><br><span class="line">  <span class="comment">//设置p</span></span><br><span class="line">	mp.nextp.set(_p_)</span><br><span class="line">  <span class="comment">//初始化信号量</span></span><br><span class="line">	mp.sigmask = initSigmask</span><br><span class="line">  <span class="comment">//获取到gp后，判断M&amp;（系统锁定｜｜cgo执行中）；；；plan9的系统跳过下面操作....</span></span><br><span class="line">	<span class="keyword">if</span> gp := getg(); gp != <span class="literal">nil</span> &amp;&amp; gp.m != <span class="literal">nil</span> &amp;&amp; (gp.m.lockedExt != <span class="number">0</span> || gp.m.incgo) &amp;&amp; GOOS != <span class="string">&quot;plan9&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// We&#x27;re on a locked M or a thread that may have been</span></span><br><span class="line">		<span class="comment">// started by C. The kernel state of this thread may</span></span><br><span class="line">		<span class="comment">// be strange (the user may have locked it for that</span></span><br><span class="line">		<span class="comment">// purpose). We don&#x27;t want to clone that into another</span></span><br><span class="line">		<span class="comment">// thread. Instead, ask a known-good thread to create</span></span><br><span class="line">		<span class="comment">// the thread for us.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// This is disabled on Plan 9. See golang.org/issue/22227.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> This may be unnecessary on Windows, which</span></span><br><span class="line">		<span class="comment">// doesn&#x27;t model thread creation off fork.</span></span><br><span class="line">		lock(&amp;newmHandoff.lock)</span><br><span class="line">		<span class="keyword">if</span> newmHandoff.haveTemplateThread == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;on a locked thread with no template thread&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		mp.schedlink = newmHandoff.newm</span><br><span class="line">		newmHandoff.newm.set(mp)</span><br><span class="line">		<span class="keyword">if</span> newmHandoff.waiting &#123;</span><br><span class="line">			newmHandoff.waiting = <span class="literal">false</span></span><br><span class="line">			notewakeup(&amp;newmHandoff.wake)</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;newmHandoff.lock)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//new m1指第一个M的创建过程.</span></span><br><span class="line">	newm1(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="newm1"><a class="header-anchor" href="#newm1">¶</a>newm1</h3>
<blockquote>
<p>go to 「newm1」</p>
</blockquote>
<p>看起来很简短</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm1</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">  <span class="comment">//cgo程序执行中?</span></span><br><span class="line">	<span class="keyword">if</span> iscgo &#123;</span><br><span class="line">		<span class="keyword">var</span> ts cgothreadstart</span><br><span class="line">		<span class="keyword">if</span> _cgo_thread_start == <span class="literal">nil</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;_cgo_thread_start missing&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		ts.g.set(mp.g0)</span><br><span class="line">		ts.tls = (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;mp.tls[<span class="number">0</span>]))</span><br><span class="line">		ts.fn = unsafe.Pointer(funcPC(mstart))</span><br><span class="line">		<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">			msanwrite(unsafe.Pointer(&amp;ts), unsafe.Sizeof(ts))</span><br><span class="line">		&#125;</span><br><span class="line">		execLock.rlock() <span class="comment">// Prevent process clone.</span></span><br><span class="line">		asmcgocall(_cgo_thread_start, unsafe.Pointer(&amp;ts))</span><br><span class="line">		execLock.runlock()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	execLock.rlock() <span class="comment">// Prevent process clone.</span></span><br><span class="line">  <span class="comment">//涉及到系统进程创建</span></span><br><span class="line">	newosproc(mp)</span><br><span class="line">	execLock.runlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="newosproc"><a class="header-anchor" href="#newosproc">¶</a>newosproc</h3>
<blockquote>
<p>M创建之前，系统的操作和相关地址的变化</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// May run with m.p==nil, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newosproc</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line"><span class="comment">//这个stk操作很奇怪，有兴趣的可以研究下....[看起来啥也没干那]</span></span><br><span class="line">	stk := unsafe.Pointer(mp.g0.stack.hi)</span><br><span class="line">	<span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;newosproc stk=&quot;</span>, stk, <span class="string">&quot; m=&quot;</span>, mp, <span class="string">&quot; g=&quot;</span>, mp.g0, <span class="string">&quot; id=&quot;</span>, mp.id, <span class="string">&quot; ostk=&quot;</span>, &amp;mp, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize an attribute object.</span></span><br><span class="line">	<span class="keyword">var</span> attr pthreadattr</span><br><span class="line">	<span class="keyword">var</span> err <span class="keyword">int32</span></span><br><span class="line">  <span class="comment">//汇编，变量初始化</span></span><br><span class="line">	err = pthread_attr_init(&amp;attr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line">		write(<span class="number">2</span>, unsafe.Pointer(&amp;failthreadcreate[<span class="number">0</span>]), <span class="keyword">int32</span>(<span class="built_in">len</span>(failthreadcreate)))</span><br><span class="line">		exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find out OS stack size for our own stack guard.</span></span><br><span class="line">	<span class="keyword">var</span> stacksize <span class="keyword">uintptr</span></span><br><span class="line">	<span class="keyword">if</span> pthread_attr_getstacksize(&amp;attr, &amp;stacksize) != <span class="number">0</span> &#123;</span><br><span class="line">		write(<span class="number">2</span>, unsafe.Pointer(&amp;failthreadcreate[<span class="number">0</span>]), <span class="keyword">int32</span>(<span class="built_in">len</span>(failthreadcreate)))</span><br><span class="line">		exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//M对应的g0的高位空间栈地址</span></span><br><span class="line">	mp.g0.stack.hi = stacksize <span class="comment">// for mstart</span></span><br><span class="line">	<span class="comment">//mSysStatInc(&amp;memstats.stacks_sys, stacksize) //<span class="doctag">TODO:</span> do this?</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Tell the pthread library we won&#x27;t join with this thread.</span></span><br><span class="line">	<span class="keyword">if</span> pthread_attr_setdetachstate(&amp;attr, _PTHREAD_CREATE_DETACHED) != <span class="number">0</span> &#123;</span><br><span class="line">		write(<span class="number">2</span>, unsafe.Pointer(&amp;failthreadcreate[<span class="number">0</span>]), <span class="keyword">int32</span>(<span class="built_in">len</span>(failthreadcreate)))</span><br><span class="line">		exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Finally, create the thread. It starts at mstart_stub, which does some low-level</span></span><br><span class="line">	<span class="comment">// setup and then calls mstart.</span></span><br><span class="line">	<span class="keyword">var</span> oset sigset</span><br><span class="line">  <span class="comment">//所有的mask初始化</span></span><br><span class="line">	sigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)</span><br><span class="line">	err = pthread_create(&amp;attr, funcPC(mstart_stub), unsafe.Pointer(mp))</span><br><span class="line">  <span class="comment">// oset地址置nil</span></span><br><span class="line">	sigprocmask(_SIG_SETMASK, &amp;oset, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line">		write(<span class="number">2</span>, unsafe.Pointer(&amp;failthreadcreate[<span class="number">0</span>]), <span class="keyword">int32</span>(<span class="built_in">len</span>(failthreadcreate)))</span><br><span class="line">		exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pthread-attr-init细节"><a class="header-anchor" href="#pthread-attr-init细节">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/sys_darwin_arm64.s#L402">pthread_attr_init细节</a></h4>
<blockquote>
<p>汇编代码：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TEXT runtime·pthread_attr_init_trampoline(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">	MOVD	<span class="number">0</span>(R0), R0	<span class="comment">// arg 1 attr</span></span><br><span class="line">	BL	libc_pthread_attr_init(SB)</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>
<h4 id="pthread-attr-getstacksize细节"><a class="header-anchor" href="#pthread-attr-getstacksize细节">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/sys_darwin_arm64.s#L407">pthread_attr_getstacksize细节</a></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TEXT runtime·pthread_attr_getstacksize_trampoline(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">	MOVD	<span class="number">8</span>(R0), R1	<span class="comment">// arg 2 size</span></span><br><span class="line">	MOVD	<span class="number">0</span>(R0), R0	<span class="comment">// arg 1 attr</span></span><br><span class="line">	BL	libc_pthread_attr_getstacksize(SB)</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>
<h4 id="sigprocmask-trampoline细节"><a class="header-anchor" href="#sigprocmask-trampoline细节">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/sys_darwin_arm64.s#L266">sigprocmask_trampoline细节</a></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TEXT runtime·sigprocmask_trampoline(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">	MOVD	<span class="number">8</span>(R0), R1	<span class="comment">// arg 2 new</span></span><br><span class="line">	MOVD	<span class="number">16</span>(R0), R2	<span class="comment">// arg 3 old</span></span><br><span class="line">	MOVW	<span class="number">0</span>(R0), R0	<span class="comment">// arg 1 how</span></span><br><span class="line">	BL	libc_pthread_sigmask(SB)</span><br><span class="line">	CMP	$<span class="number">0</span>, R0</span><br><span class="line">	BEQ	<span class="number">2</span>(PC)</span><br><span class="line">	BL	notok&lt;&gt;(SB)</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>
<h4 id="pthread-create细节"><a class="header-anchor" href="#pthread-create细节">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/sys_darwin_arm64.s#L342">pthread_create细节</a></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mstart_stub is the first function executed on a new thread started by pthread_create.</span></span><br><span class="line"><span class="comment">// It just does some low-level setup and then calls mstart.</span></span><br><span class="line"><span class="comment">// Note: called with the C calling convention.</span></span><br><span class="line">TEXT runtime·mstart_stub(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">	<span class="comment">// DI points to the m.</span></span><br><span class="line">	<span class="comment">// We are already on m&#x27;s g0 stack.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save callee-save registers.</span></span><br><span class="line">	SUBQ	$<span class="number">40</span>, SP</span><br><span class="line">	MOVQ	BX, <span class="number">0</span>(SP)</span><br><span class="line">	MOVQ	R12, <span class="number">8</span>(SP)</span><br><span class="line">	MOVQ	R13, <span class="number">16</span>(SP)</span><br><span class="line">	MOVQ	R14, <span class="number">24</span>(SP)</span><br><span class="line">	MOVQ	R15, <span class="number">32</span>(SP)</span><br><span class="line"></span><br><span class="line">	MOVQ	m_g0(DI), DX <span class="comment">// g</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize TLS entry.</span></span><br><span class="line">	<span class="comment">// See cmd/link/internal/ld/sym.go:computeTLSOffset.</span></span><br><span class="line">	MOVQ	DX, <span class="number">0x30</span>(GS)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Someday the convention will be D is always cleared.</span></span><br><span class="line">	CLD</span><br><span class="line"></span><br><span class="line">	CALL	runtime·mstart(SB)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Restore callee-save registers.</span></span><br><span class="line">	MOVQ	<span class="number">0</span>(SP), BX</span><br><span class="line">	MOVQ	<span class="number">8</span>(SP), R12</span><br><span class="line">	MOVQ	<span class="number">16</span>(SP), R13</span><br><span class="line">	MOVQ	<span class="number">24</span>(SP), R14</span><br><span class="line">	MOVQ	<span class="number">32</span>(SP), R15</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Go is all done with this OS thread.</span></span><br><span class="line">	<span class="comment">// Tell pthread everything is ok (we never join with this thread, so</span></span><br><span class="line">	<span class="comment">// the value here doesn&#x27;t really matter).</span></span><br><span class="line">	XORL	AX, AX</span><br><span class="line"></span><br><span class="line">	ADDQ	$<span class="number">40</span>, SP</span><br><span class="line">	RET</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="execLock-rlock"><a class="header-anchor" href="#execLock-rlock">¶</a>execLock.rlock()</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// rlock locks rw for reading.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *rwmutex)</span> <span class="title">rlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// The reader must not be allowed to lose its P or else other</span></span><br><span class="line">	<span class="comment">// things blocking on the lock may consume all of the Ps and</span></span><br><span class="line">	<span class="comment">// deadlock (issue #20903). Alternatively, we could drop the P</span></span><br><span class="line">	<span class="comment">// while sleeping.</span></span><br><span class="line">	acquirem()</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;rw.readerCount, <span class="number">1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// A writer is pending. Park on the reader queue.</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			lockWithRank(&amp;rw.rLock, lockRankRwmutexR)</span><br><span class="line">			<span class="keyword">if</span> rw.readerPass &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// Writer finished.</span></span><br><span class="line">				rw.readerPass -= <span class="number">1</span></span><br><span class="line">				unlock(&amp;rw.rLock)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Queue this reader to be woken by</span></span><br><span class="line">				<span class="comment">// the writer.</span></span><br><span class="line">				m := getg().m</span><br><span class="line">				m.schedlink = rw.readers</span><br><span class="line">				rw.readers.set(m)</span><br><span class="line">				unlock(&amp;rw.rLock)</span><br><span class="line">				notesleep(&amp;m.park)</span><br><span class="line">				noteclear(&amp;m.park)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="acquirem"><a class="header-anchor" href="#acquirem">¶</a>acquirem()</h4>
<blockquote>
<p>加锁获取M</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquirem</span><span class="params">()</span> *<span class="title">m</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line">	_g_.m.locks++</span><br><span class="line">	<span class="keyword">return</span> _g_.m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="notesleep"><a class="header-anchor" href="#notesleep">¶</a>notesleep()</h4>
<blockquote>
<p>比较有趣的是sleep是用队列实现,前后加锁</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notesleep</span><span class="params">(n *note)</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Queued. Sleep.</span></span><br><span class="line">	gp.m.blocked = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">if</span> *cgo_yield == <span class="literal">nil</span> &#123;</span><br><span class="line">		semasleep(<span class="number">-1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Sleep for an arbitrary-but-moderate interval to poll libc interceptors.</span></span><br><span class="line">		<span class="keyword">const</span> ns = <span class="number">10e6</span></span><br><span class="line">		<span class="keyword">for</span> atomic.Loaduintptr(&amp;n.key) == <span class="number">0</span> &#123;</span><br><span class="line">			semasleep(ns)</span><br><span class="line">			asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	gp.m.blocked = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="execLock-runlock"><a class="header-anchor" href="#execLock-runlock">¶</a>execLock.runlock()</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// runlock undoes a single rlock call on rw.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *rwmutex)</span> <span class="title">runlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r := <span class="keyword">int32</span>(atomic.Xadd(&amp;rw.readerCount, <span class="number">-1</span>)); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">		....</span><br><span class="line">	&#125;</span><br><span class="line">	releasem(getg().m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="releasem"><a class="header-anchor" href="#releasem">¶</a>releasem</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">//lock数量➖1，恢复到preempt的状态.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releasem</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line">	mp.locks--</span><br><span class="line">	<span class="keyword">if</span> mp.locks == <span class="number">0</span> &amp;&amp; _g_.preempt &#123;</span><br><span class="line">		<span class="comment">// restore the preemption request in case we&#x27;ve cleared it in newstack</span></span><br><span class="line">		_g_.stackguard0 = stackPreempt</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先分析到这儿吧…关于这一节的流程图，会整理出来的，，，，</p>
<p>不然就白分析这么多了，及时学习，及时总结。</p>
<p>晚安😴…</p>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>GPM</tag>
        <tag>Go源码</tag>
      </tags>
  </entry>
  <entry>
    <title>「23」GPM main入口函数</title>
    <url>/archives/9bb71eca.html</url>
    <content><![CDATA[<p>前面g0和m0瞎扯了部分的入口和一些关键的点。</p>
<p>本来应该扯扯shedule调度方面的知识，但是这个先往后放一节吧，</p>
<p>先学习下这个「入口函数」，毕竟对于每一个项目都会有一个入口的相关逻辑，那么go源码是怎么处理的？</p>
<p>有没有什么可以借鉴的嘞？！</p>
<a id="more"></a>
<p>接下来该到main函数的相关处理。</p>
<blockquote>
<p>go version: 1.14.3</p>
</blockquote>
<h3 id="code分析"><a class="header-anchor" href="#code分析">¶</a>code分析</h3>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/proc.go#L113">main函数入口</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// The main goroutine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	g := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Racectx of m0-&gt;g0 is used only as the parent of the main goroutine.</span></span><br><span class="line">	<span class="comment">// It must not be used for anything else.</span></span><br><span class="line">	g.m.g0.racectx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.</span></span><br><span class="line">	<span class="comment">// Using decimal instead of binary GB and MB because</span></span><br><span class="line">    <span class="comment">// they look nicer in the stack overflow failure message.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最大栈空间限制</span></span><br><span class="line">	<span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">		maxstacksize = <span class="number">1000000000</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		maxstacksize = <span class="number">250000000</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow newproc to start new Ms.</span></span><br><span class="line">	mainStarted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是wasm，就不要调度程序了.</span></span><br><span class="line">    <span class="keyword">if</span> GOARCH != <span class="string">&quot;wasm&quot;</span> &#123; <span class="comment">// no threads on wasm yet, so no sysmon</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//系统栈调用</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// newm的回调函数，，，一个M一个sysmon P</span></span><br><span class="line">			newm(sysmon, <span class="literal">nil</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lock the main goroutine onto this, the main OS thread,</span></span><br><span class="line">	<span class="comment">// during initialization. Most programs won&#x27;t care, but a few</span></span><br><span class="line">	<span class="comment">// do require certain calls to be made by the main thread.</span></span><br><span class="line">	<span class="comment">// Those can arrange for main.main to run in the main thread</span></span><br><span class="line">	<span class="comment">// by calling runtime.LockOSThread during initialization</span></span><br><span class="line">	<span class="comment">// to preserve the lock.</span></span><br><span class="line">	lockOSThread()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> g.m != &amp;m0 &#123;</span><br><span class="line">		throw(<span class="string">&quot;runtime.main not on m0&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	doInit(&amp;runtime_inittask) <span class="comment">// must be before defer</span></span><br><span class="line">	<span class="keyword">if</span> nanotime() == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;nanotime returning zero&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Defer unlock so that runtime.Goexit during init does the unlock too.</span></span><br><span class="line">	needUnlock := <span class="literal">true</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> needUnlock &#123;</span><br><span class="line">			unlockOSThread()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Record when the world started.</span></span><br><span class="line">	runtimeInitTime = nanotime()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动GC</span></span><br><span class="line">	gcenable()</span><br><span class="line"></span><br><span class="line">	main_init_done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">if</span> iscgo &#123;</span><br><span class="line">		<span class="keyword">if</span> _cgo_thread_start == <span class="literal">nil</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;_cgo_thread_start missing&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> GOOS != <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> _cgo_setenv == <span class="literal">nil</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;_cgo_setenv missing&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> _cgo_unsetenv == <span class="literal">nil</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;_cgo_unsetenv missing&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> _cgo_notify_runtime_init_done == <span class="literal">nil</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;_cgo_notify_runtime_init_done missing&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Start the template thread in case we enter Go from</span></span><br><span class="line">		<span class="comment">// a C-created thread and need to create a new thread.</span></span><br><span class="line">		startTemplateThread()</span><br><span class="line">		cgocall(_cgo_notify_runtime_init_done, <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	doInit(&amp;main_inittask)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(main_init_done)</span><br><span class="line"></span><br><span class="line">	needUnlock = <span class="literal">false</span></span><br><span class="line">	unlockOSThread()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> isarchive || islibrary &#123;</span><br><span class="line">		<span class="comment">// A program compiled with -buildmode=c-archive or c-shared</span></span><br><span class="line">		<span class="comment">// has a main, but it is not executed.</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对于main函数的回调，也就是用户写的main程序</span></span><br><span class="line">	fn := main_main <span class="comment">// make an indirect call, as the linker doesn&#x27;t know the address of the main package when laying down the runtime</span></span><br><span class="line">	fn()</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		racefini()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make racy client program work: if panicking on</span></span><br><span class="line">	<span class="comment">// another goroutine at the same time as main returns,</span></span><br><span class="line">	<span class="comment">// let the other goroutine finish printing the panic trace.</span></span><br><span class="line">    <span class="comment">// Once it does, it will exit. See issues 3934 and 20018.</span></span><br><span class="line">    <span class="comment">//判断panicDefer函数，，，，，，</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;runningPanicDefers) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Running deferred functions should not take long.</span></span><br><span class="line">		<span class="keyword">for</span> c := <span class="number">0</span>; c &lt; <span class="number">1000</span>; c++ &#123;</span><br><span class="line">			<span class="keyword">if</span> atomic.Load(&amp;runningPanicDefers) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			Gosched()</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断panic</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;panicking) != <span class="number">0</span> &#123;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonPanicWait, traceEvGoStop, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//正常退出了那.....</span></span><br><span class="line">	exit(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> x *<span class="keyword">int32</span></span><br><span class="line">		*x = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="systemstack"><a class="header-anchor" href="#systemstack">¶</a>systemstack</h3>
<blockquote>
<p>这个函数，在整个系统中较为重要，来看看官方说明</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// systemstack runs fn on a system stack.</span></span><br><span class="line"><span class="comment">// If systemstack is called from the per-OS-thread (g0) stack, or</span></span><br><span class="line"><span class="comment">// if systemstack is called from the signal handling (gsignal) stack,</span></span><br><span class="line"><span class="comment">// systemstack calls fn directly and returns.</span></span><br><span class="line"><span class="comment">//g0 stack或者信号处理的，就直接调用并返回。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Otherwise, systemstack is being called from the limited stack</span></span><br><span class="line"><span class="comment">// of an ordinary goroutine. In this case, systemstack switches</span></span><br><span class="line"><span class="comment">// to the per-OS-thread stack, calls fn, and switches back.</span></span><br><span class="line"><span class="comment">// It is common to use a func literal as the argument, in order</span></span><br><span class="line"><span class="comment">// to share inputs and outputs with the code around the call</span></span><br><span class="line"><span class="comment">// to system stack:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	... set up y ...</span></span><br><span class="line"><span class="comment">//	systemstack(func() &#123;</span></span><br><span class="line"><span class="comment">//		x = bigcall(y)</span></span><br><span class="line"><span class="comment">//	&#125;)</span></span><br><span class="line"><span class="comment">//	... use x ...</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:noescape</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">systemstack</span><span class="params">(fn <span class="keyword">func</span>()</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="newm"><a class="header-anchor" href="#newm">¶</a>newm</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a new m. It will start off with a call to fn, or else the scheduler.</span></span><br><span class="line"><span class="comment">// fn needs to be static and not a heap allocated closure.</span></span><br><span class="line"><span class="comment">// May run with m.p==nil, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于创建新的M，fn:sysmon函数，类似于事件驱动类型的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm</span><span class="params">(fn <span class="keyword">func</span>()</span>, _<span class="title">p_</span> *<span class="title">p</span>)</span> &#123;</span><br><span class="line">	<span class="comment">//分配内存</span></span><br><span class="line">	mp := allocm(_p_, fn)</span><br><span class="line">	mp.nextp.set(_p_)</span><br><span class="line">	mp.sigmask = initSigmask</span><br><span class="line">	<span class="keyword">if</span> gp := getg(); gp != <span class="literal">nil</span> &amp;&amp; gp.m != <span class="literal">nil</span> &amp;&amp; (gp.m.lockedExt != <span class="number">0</span> || gp.m.incgo) &amp;&amp; GOOS != <span class="string">&quot;plan9&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// We&#x27;re on a locked M or a thread that may have been</span></span><br><span class="line">		<span class="comment">// started by C. The kernel state of this thread may</span></span><br><span class="line">		<span class="comment">// be strange (the user may have locked it for that</span></span><br><span class="line">		<span class="comment">// purpose). We don&#x27;t want to clone that into another</span></span><br><span class="line">		<span class="comment">// thread. Instead, ask a known-good thread to create</span></span><br><span class="line">		<span class="comment">// the thread for us.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// This is disabled on Plan 9. See golang.org/issue/22227.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> This may be unnecessary on Windows, which</span></span><br><span class="line">		<span class="comment">// doesn&#x27;t model thread creation off fork.</span></span><br><span class="line">		lock(&amp;newmHandoff.lock)</span><br><span class="line">		<span class="keyword">if</span> newmHandoff.haveTemplateThread == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;on a locked thread with no template thread&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		mp.schedlink = newmHandoff.newm</span><br><span class="line">		newmHandoff.newm.set(mp)</span><br><span class="line">		<span class="keyword">if</span> newmHandoff.waiting &#123;</span><br><span class="line">			newmHandoff.waiting = <span class="literal">false</span></span><br><span class="line">			notewakeup(&amp;newmHandoff.wake)</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;newmHandoff.lock)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	newm1(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主要是以下几个函数：</p>
</blockquote>
<ul>
<li>allocm</li>
<li>notewakeup</li>
<li>newm1</li>
</ul>
<h3 id="sysmon"><a class="header-anchor" href="#sysmon">¶</a>sysmon</h3>
<p>学习系统监控之前，先学下部分函数的使用和其大概含义：</p>
<ul>
<li>checkdead</li>
<li>usleep</li>
<li>timeSleepUntil</li>
<li>nanotime</li>
<li>netpollinited</li>
<li>startm</li>
<li>retake</li>
<li>gcTrigger</li>
<li>injectglist</li>
</ul>
<blockquote>
<p>先看下主体流程</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Always runs without a P, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	sched.nmsys++</span><br><span class="line">	<span class="comment">//基于running中的M，检查死锁，，，，</span></span><br><span class="line">	checkdead()</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	lasttrace := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">	idle := <span class="number">0</span> <span class="comment">// how many cycles in succession we had not wokeup somebody</span></span><br><span class="line">	delay := <span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> idle == <span class="number">0</span> &#123; <span class="comment">// start with 20us sleep...</span></span><br><span class="line">			delay = <span class="number">20</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> idle &gt; <span class="number">50</span> &#123; <span class="comment">// start doubling the sleep after 1ms...</span></span><br><span class="line">			delay *= <span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> delay &gt; <span class="number">10</span>*<span class="number">1000</span> &#123; <span class="comment">// up to 10ms</span></span><br><span class="line">			delay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//休眠时间</span></span><br><span class="line">		usleep(delay)</span><br><span class="line">		<span class="comment">//获取时间</span></span><br><span class="line">		now := nanotime()</span><br><span class="line">		<span class="comment">// 休眠等待唤醒信号</span></span><br><span class="line">		next, _ := timeSleepUntil()</span><br><span class="line">		<span class="keyword">if</span> debug.schedtrace &lt;= <span class="number">0</span> &amp;&amp; (sched.gcwaiting != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="keyword">uint32</span>(gomaxprocs)) &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">if</span> atomic.Load(&amp;sched.gcwaiting) != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="keyword">uint32</span>(gomaxprocs) &#123;</span><br><span class="line">				<span class="keyword">if</span> next &gt; now &#123;</span><br><span class="line">					atomic.Store(&amp;sched.sysmonwait, <span class="number">1</span>)</span><br><span class="line">					unlock(&amp;sched.lock)</span><br><span class="line">					<span class="comment">// Make wake-up period small enough</span></span><br><span class="line">					<span class="comment">// for the sampling to be correct.</span></span><br><span class="line">					sleep := forcegcperiod / <span class="number">2</span></span><br><span class="line">					<span class="keyword">if</span> next-now &lt; sleep &#123;</span><br><span class="line">						sleep = next - now</span><br><span class="line">					&#125;</span><br><span class="line">					shouldRelax := sleep &gt;= osRelaxMinNS</span><br><span class="line">					<span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">						osRelax(<span class="literal">true</span>)</span><br><span class="line">					&#125;</span><br><span class="line">					notetsleep(&amp;sched.sysmonnote, sleep)</span><br><span class="line">					<span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">						osRelax(<span class="literal">false</span>)</span><br><span class="line">					&#125;</span><br><span class="line">					now = nanotime()</span><br><span class="line">					next, _ = timeSleepUntil()</span><br><span class="line">					lock(&amp;sched.lock)</span><br><span class="line">					atomic.Store(&amp;sched.sysmonwait, <span class="number">0</span>)</span><br><span class="line">					noteclear(&amp;sched.sysmonnote)</span><br><span class="line">				&#125;</span><br><span class="line">				idle = <span class="number">0</span></span><br><span class="line">				delay = <span class="number">20</span></span><br><span class="line">			&#125;</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125;</span><br><span class="line">		lock(&amp;sched.sysmonlock)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// If we spent a long time blocked on sysmonlock</span></span><br><span class="line">			<span class="comment">// then we want to update now and next since it&#x27;s</span></span><br><span class="line">			<span class="comment">// likely stale.</span></span><br><span class="line">			now1 := nanotime()</span><br><span class="line">			<span class="keyword">if</span> now1-now &gt; <span class="number">50</span>*<span class="number">1000</span> <span class="comment">/* 50µs */</span> &#123;</span><br><span class="line">				next, _ = timeSleepUntil()</span><br><span class="line">			&#125;</span><br><span class="line">			now = now1</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// trigger libc interceptors if needed</span></span><br><span class="line">		<span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">			asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// poll network if not polled for more than 10ms</span></span><br><span class="line">		<span class="comment">//在队列中等待调度超过10ms，就给交给global抢渡了</span></span><br><span class="line">		lastpoll := <span class="keyword">int64</span>(atomic.Load64(&amp;sched.lastpoll))</span><br><span class="line">		<span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">			atomic.Cas64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(lastpoll), <span class="keyword">uint64</span>(now))</span><br><span class="line">			list := netpoll(<span class="number">0</span>) <span class="comment">// non-blocking - returns list of goroutines</span></span><br><span class="line">			<span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">				<span class="comment">// Need to decrement number of idle locked M&#x27;s</span></span><br><span class="line">				<span class="comment">// (pretending that one more is running) before injectglist.</span></span><br><span class="line">				<span class="comment">// Otherwise it can lead to the following situation:</span></span><br><span class="line">				<span class="comment">// injectglist grabs all P&#x27;s but before it starts M&#x27;s to run the P&#x27;s,</span></span><br><span class="line">				<span class="comment">// another M returns from syscall, finishes running its G,</span></span><br><span class="line">				<span class="comment">// observes that there is no work to do and no other running M&#x27;s</span></span><br><span class="line">				<span class="comment">// and reports deadlock.</span></span><br><span class="line">				incidlelocked(<span class="number">-1</span>)</span><br><span class="line">				<span class="comment">//注入全局g队列中</span></span><br><span class="line">				injectglist(&amp;list)</span><br><span class="line">				incidlelocked(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> next &lt; now &#123;</span><br><span class="line">			<span class="comment">// There are timers that should have already run,</span></span><br><span class="line">			<span class="comment">// perhaps because there is an unpreemptible P.</span></span><br><span class="line">			<span class="comment">// Try to start an M to run them.</span></span><br><span class="line">			<span class="comment">//需要一个新的M来跑P上面的G。</span></span><br><span class="line">			startm(<span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.Load(&amp;scavenge.sysmonWake) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Kick the scavenger awake if someone requested it.</span></span><br><span class="line">			wakeScavenger()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// retake P&#x27;s blocked in syscalls</span></span><br><span class="line">		<span class="comment">// and preempt long running G&#x27;s</span></span><br><span class="line">		<span class="comment">// 循环所有的allp，进行抢夺。</span></span><br><span class="line">		<span class="keyword">if</span> retake(now) != <span class="number">0</span> &#123;</span><br><span class="line">			idle = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			idle++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// check if we need to force a GC</span></span><br><span class="line">		<span class="comment">//强行GC</span></span><br><span class="line">		<span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != <span class="number">0</span> &#123;</span><br><span class="line">			lock(&amp;forcegc.lock)</span><br><span class="line">			forcegc.idle = <span class="number">0</span></span><br><span class="line">			<span class="keyword">var</span> list gList</span><br><span class="line">			list.push(forcegc.g)</span><br><span class="line">			injectglist(&amp;list)</span><br><span class="line">			unlock(&amp;forcegc.lock)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> debug.schedtrace &gt; <span class="number">0</span> &amp;&amp; lasttrace+<span class="keyword">int64</span>(debug.schedtrace)*<span class="number">1000000</span> &lt;= now &#123;</span><br><span class="line">			lasttrace = now</span><br><span class="line">			schedtrace(debug.scheddetail &gt; <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;sched.sysmonlock)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="doInit"><a class="header-anchor" href="#doInit">¶</a>doInit</h3>
<blockquote>
<p>这一部分在源码看来，没有具体的作用，，，，，，，，todo标签吧。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doInit</span><span class="params">(t *initTask)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> t.state &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// fully initialized</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// initialization in progress</span></span><br><span class="line">		throw(<span class="string">&quot;recursive call during initialization - linker skew&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">// not initialized yet</span></span><br><span class="line">		t.state = <span class="number">1</span> <span class="comment">// initialization in progress</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; t.ndeps; i++ &#123;</span><br><span class="line">			p := add(unsafe.Pointer(t), (<span class="number">3</span>+i)*sys.PtrSize)</span><br><span class="line">			t2 := *(**initTask)(p)</span><br><span class="line">			doInit(t2)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; t.nfns; i++ &#123;</span><br><span class="line">			p := add(unsafe.Pointer(t), (<span class="number">3</span>+t.ndeps+i)*sys.PtrSize)</span><br><span class="line">			f := *(*<span class="function"><span class="keyword">func</span><span class="params">()</span>)<span class="params">(unsafe.Pointer(&amp;p)</span>)</span></span><br><span class="line">			f()</span><br><span class="line">		&#125;</span><br><span class="line">		t.state = <span class="number">2</span> <span class="comment">// initialization done</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gcenable"><a class="header-anchor" href="#gcenable">¶</a>gcenable</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcenable is called after the bulk of the runtime initialization,</span></span><br><span class="line"><span class="comment">// just before we&#x27;re about to start letting user code run.</span></span><br><span class="line"><span class="comment">// It kicks off the background sweeper goroutine, the background</span></span><br><span class="line"><span class="comment">// scavenger goroutine, and enables GC.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcenable</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Kick off sweeping and scavenging.</span></span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> bgsweep(c)</span><br><span class="line">	<span class="keyword">go</span> bgscavenge(c)</span><br><span class="line">	&lt;-c</span><br><span class="line">	&lt;-c</span><br><span class="line">	memstats.enablegc = <span class="literal">true</span> <span class="comment">// now that runtime is initialized, GC is okay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Gosched"><a class="header-anchor" href="#Gosched">¶</a>Gosched</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Gosched yields the processor, allowing other goroutines to run. It does not</span></span><br><span class="line"><span class="comment">// suspend the current goroutine, so execution resumes automatically.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Gosched</span><span class="params">()</span></span> &#123;</span><br><span class="line">	checkTimeouts()</span><br><span class="line">	mcall(gosched_m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gopark"><a class="header-anchor" href="#gopark">¶</a>gopark</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Puts the current goroutine into a waiting state and calls unlockf.</span></span><br><span class="line"><span class="comment">// If unlockf returns false, the goroutine is resumed.</span></span><br><span class="line"><span class="comment">// unlockf must not access this G&#x27;s stack, as it may be moved between</span></span><br><span class="line"><span class="comment">// the call to gopark and the call to unlockf.</span></span><br><span class="line"><span class="comment">// Reason explains why the goroutine has been parked.</span></span><br><span class="line"><span class="comment">// It is displayed in stack traces and heap dumps.</span></span><br><span class="line"><span class="comment">// Reasons should be unique and descriptive.</span></span><br><span class="line"><span class="comment">// Do not re-use reasons, add new ones.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopark</span><span class="params">(unlockf <span class="keyword">func</span>(*g, unsafe.Pointer)</span> <span class="title">bool</span>, <span class="title">lock</span> <span class="title">unsafe</span>.<span class="title">Pointer</span>, <span class="title">reason</span> <span class="title">waitReason</span>, <span class="title">traceEv</span> <span class="title">byte</span>, <span class="title">traceskip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> reason != waitReasonSleep &#123;</span><br><span class="line">		checkTimeouts() <span class="comment">// timeouts may expire while two goroutines keep the scheduler busy</span></span><br><span class="line">	&#125;</span><br><span class="line">	mp := acquirem()</span><br><span class="line">	gp := mp.curg</span><br><span class="line">	status := readgstatus(gp)</span><br><span class="line">	<span class="keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;</span><br><span class="line">		throw(<span class="string">&quot;gopark: bad g status&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mp.waitlock = lock</span><br><span class="line">	mp.waitunlockf = unlockf</span><br><span class="line">	gp.waitreason = reason</span><br><span class="line">	mp.waittraceev = traceEv</span><br><span class="line">	mp.waittraceskip = traceskip</span><br><span class="line">	<span class="comment">//mp解绑</span></span><br><span class="line">	releasem(mp)</span><br><span class="line">	<span class="comment">// can&#x27;t do anything that might move the G between Ms here.</span></span><br><span class="line">	mcall(park_m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后续"><a class="header-anchor" href="#后续">¶</a>后续</h3>
<blockquote>
<p>关于里面的重要部分实现细节，不是本次关注的重点，，，，</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">这次主要看到的是Go围绕main函数，为了程序的正常启动，所做的工作.</span><br><span class="line"></span><br><span class="line">无论是g的启动还是调度监控方面，也就是从整个生命周期来考虑，，，，，，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">还有一个就是关于panic的处理，采用事件驱动的方式，很好的获取到panic,进行后续的处理。</span><br><span class="line"></span><br><span class="line">最后还有一个关于全局locktrhead，，，，，，粒度尽量细小，有利于提高性能。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>GPM</tag>
        <tag>Go源码</tag>
      </tags>
  </entry>
  <entry>
    <title>「22」GPM g0和m0</title>
    <url>/archives/392d66f0.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p>GPM算是经典的调度模型，但是每个程序都需要一个启动的函数或者入口；<br>
GPM也不例外。<br>
直接分析源码，显得很枯燥，如果说要你设计GPM中的G和M的执行关系，你应该怎么设计呢？</p>
<a id="more"></a>
<blockquote>
<p>go version: 1.14.3</p>
</blockquote>
<h3 id="尝试设计"><a class="header-anchor" href="#尝试设计">¶</a>尝试设计</h3>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/GPM202011182201.png" alt=""><br>
如果只是这样的话，那总体的G和M是否需要管理者，毕竟在1.1版本之前只有GM模型，，，<br>
那么为了好管理M和G，就需要第一个M和G成为管理者，类似于大总管这样的存在。</p>
<h3 id="再次设计"><a class="header-anchor" href="#再次设计">¶</a>再次设计</h3>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/GPM202011182219.png" alt=""></p>
<h3 id="关键点："><a class="header-anchor" href="#关键点：">¶</a>关键点：</h3>
<ul>
<li>p先启动</li>
<li>g0的创建；用于创建新的G</li>
<li>m0的创建；用于创建新的M</li>
<li>启动main调度整个系统</li>
</ul>
<blockquote>
<p>上述这样比较合理点。</p>
</blockquote>
<h3 id="Go源码的如何实现？"><a class="header-anchor" href="#Go源码的如何实现？">¶</a>Go源码的如何实现？</h3>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/proc.go#L524">bootstrap sequence</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The bootstrap sequence is:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	call osinit</span></span><br><span class="line"><span class="comment">//	call schedinit</span></span><br><span class="line"><span class="comment">//	make &amp; queue new G</span></span><br><span class="line"><span class="comment">//	call runtime·mstart</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The new G calls runtime·main.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/asm_amd64.s#L194">g0和m0初始化过程</a></p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set the per-goroutine and per-mach &quot;registers&quot;</span></span><br><span class="line">	get_tls(BX)</span><br><span class="line">	LEAQ	runtime·g0(SB), CX</span><br><span class="line">	MOVQ	CX, g(BX)</span><br><span class="line">	LEAQ	runtime·m0(SB), AX</span><br><span class="line"></span><br><span class="line">	<span class="comment">// save m-&gt;g0 = g0</span></span><br><span class="line">	MOVQ	CX, m_g0(AX)</span><br><span class="line">	<span class="comment">// save m0 to g0-&gt;m</span></span><br><span class="line">	MOVQ	AX, g_m(CX)</span><br><span class="line"></span><br><span class="line">	CLD				<span class="comment">// convention is D is always left cleared</span></span><br><span class="line">	CALL	runtime·check(SB)</span><br><span class="line"></span><br><span class="line">	MOVL	<span class="number">16</span>(SP), AX		<span class="comment">// copy argc</span></span><br><span class="line">	MOVL	AX, <span class="number">0</span>(SP)</span><br><span class="line">	MOVQ	<span class="number">24</span>(SP), AX		<span class="comment">// copy argv</span></span><br><span class="line">	MOVQ	AX, <span class="number">8</span>(SP)</span><br><span class="line">	CALL	runtime·args(SB)</span><br><span class="line">	CALL	runtime·osinit(SB)</span><br><span class="line">	CALL	runtime·schedinit(SB)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a new goroutine to start program</span></span><br><span class="line">	MOVQ	$runtime·mainPC(SB), AX		<span class="comment">// entry</span></span><br><span class="line">	PUSHQ	AX</span><br><span class="line">	PUSHQ	$<span class="number">0</span>			<span class="comment">// arg size</span></span><br><span class="line">	CALL	runtime·newproc(SB)</span><br><span class="line">	POPQ	AX</span><br><span class="line">	POPQ	AX</span><br><span class="line"></span><br><span class="line">	<span class="comment">// start this M</span></span><br><span class="line">	CALL	runtime·mstart(SB)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>到这里了，初始化思路基本确定了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、initP</span><br><span class="line">2、m0和g0的绑定</span><br><span class="line">3、new groutine for main主线程启动</span><br><span class="line">4、mstart</span><br></pre></td></tr></table></figure>
<h3 id="m-init涉及到的函数"><a class="header-anchor" href="#m-init涉及到的函数">¶</a>m init涉及到的函数</h3>
<ul>
<li>mstart</li>
<li>mstart1</li>
<li>mstartm0</li>
</ul>
<h4 id="mstart"><a class="header-anchor" href="#mstart">¶</a>mstart</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mstart is the entry-point for new Ms.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This must not split the stack because we may not even have stack</span></span><br><span class="line"><span class="comment">// bounds set up yet.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// May run during STW (because it doesn&#x27;t have a P yet), so write</span></span><br><span class="line"><span class="comment">// barriers are not allowed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//低位判断</span></span><br><span class="line">	osStack := _g_.stack.lo == <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> osStack &#123;</span><br><span class="line">		<span class="comment">// Initialize stack bounds from system stack.</span></span><br><span class="line">		<span class="comment">// Cgo may have left stack size in stack.hi.</span></span><br><span class="line">		<span class="comment">// minit may update the stack bounds.</span></span><br><span class="line">		size := _g_.stack.hi</span><br><span class="line">		<span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">			size = <span class="number">8192</span> * sys.StackGuardMultiplier</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//g0的stack空间是真的大</span></span><br><span class="line">		_g_.stack.hi = <span class="keyword">uintptr</span>(noescape(unsafe.Pointer(&amp;size)))</span><br><span class="line">		_g_.stack.lo = _g_.stack.hi - size + <span class="number">1024</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Initialize stack guard so that we can start calling regular</span></span><br><span class="line">	<span class="comment">// Go code.</span></span><br><span class="line">	_g_.stackguard0 = _g_.stack.lo + _StackGuard</span><br><span class="line">	<span class="comment">// This is the g0, so we can also call go:systemstack</span></span><br><span class="line">	<span class="comment">// functions, which check stackguard1.</span></span><br><span class="line">	_g_.stackguard1 = _g_.stackguard0</span><br><span class="line">	mstart1()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Exit this thread.</span></span><br><span class="line">	<span class="keyword">switch</span> GOOS &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;windows&quot;</span>, <span class="string">&quot;solaris&quot;</span>, <span class="string">&quot;illumos&quot;</span>, <span class="string">&quot;plan9&quot;</span>, <span class="string">&quot;darwin&quot;</span>, <span class="string">&quot;aix&quot;</span>:</span><br><span class="line">		<span class="comment">// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate</span></span><br><span class="line">		<span class="comment">// the stack, but put it in _g_.stack before mstart,</span></span><br><span class="line">		<span class="comment">// so the logic above hasn&#x27;t set osStack yet.</span></span><br><span class="line">		osStack = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	mexit(osStack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mstart1"><a class="header-anchor" href="#mstart1">¶</a>mstart1</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动非g0就崩盘了</span></span><br><span class="line">	<span class="keyword">if</span> _g_ != _g_.m.g0 &#123;</span><br><span class="line">		throw(<span class="string">&quot;bad runtime·mstart&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">	<span class="comment">// Record the caller for use as the top of stack in mcall and</span></span><br><span class="line">	<span class="comment">// for terminating the thread.</span></span><br><span class="line">	<span class="comment">// We&#x27;re never coming back to mstart1 after we call schedule,</span></span><br><span class="line">	<span class="comment">// so other calls can reuse the current frame.</span></span><br><span class="line">	save(getcallerpc(), getcallersp())</span><br><span class="line">	asminit()</span><br><span class="line">	minit()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Install signal handlers; after minit so that minit can</span></span><br><span class="line">    <span class="comment">// prepare the thread to be able to handle the signals.</span></span><br><span class="line">    <span class="comment">//m0启动</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m == &amp;m0 &#123;</span><br><span class="line">		mstartm0()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fn := _g_.m.mstartfn; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">		fn()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m != &amp;m0 &#123;</span><br><span class="line">		acquirep(_g_.m.nextp.ptr())</span><br><span class="line">		_g_.m.nextp = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始调度</span></span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mstartm0"><a class="header-anchor" href="#mstartm0">¶</a>mstartm0</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mstart1的具体实现，仅run在m0上</span></span><br><span class="line"><span class="comment">// mstartm0 implements part of mstart1 that only runs on the m0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write barriers are allowed here because we know the GC can&#x27;t be</span></span><br><span class="line"><span class="comment">// running yet, so they&#x27;ll be no-ops.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:yeswritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstartm0</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Create an extra M for callbacks on threads not created by Go.</span></span><br><span class="line">	<span class="comment">// An extra M is also needed on Windows for callbacks created by</span></span><br><span class="line">    <span class="comment">// syscall.NewCallback. See issue #6751 for details.</span></span><br><span class="line">    <span class="comment">//windows下需要一个额外的M</span></span><br><span class="line">	<span class="keyword">if</span> (iscgo || GOOS == <span class="string">&quot;windows&quot;</span>) &amp;&amp; !cgoHasExtraM &#123;</span><br><span class="line">		cgoHasExtraM = <span class="literal">true</span></span><br><span class="line">		newextram()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化信号量,用于后续调度</span></span><br><span class="line">	initsig(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后续schedule函数"><a class="header-anchor" href="#后续schedule函数">¶</a><a href="https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/proc.go#L1119">后续schedule函数</a></h4>
<blockquote>
<p>管家有了，那么开始调度吧…。</p>
</blockquote>
<h3 id="下节："><a class="header-anchor" href="#下节：">¶</a>下节：</h3>
<ul>
<li>schedule</li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>GPM</tag>
        <tag>Go源码</tag>
      </tags>
  </entry>
  <entry>
    <title>「21」linux select源码</title>
    <url>/archives/ba7b70bf.html</url>
    <content><![CDATA[<blockquote>
<p>select poll epoll三个老生长谈的问题.这次不是来讲区别的，后续会更新一篇关于三者区别的。</p>
</blockquote>
<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p>select属于linux系列的文件系统「fs」的范畴，每次的系统调用、打开软件、启动程序等等都会涉及到文件的读写，<br>
这个是在所难免的。</p>
<p>那么I/O事件的基本思路：文件准备ok，开始读写，等函数返回，根据结果继续运行.</p>
<p>如果是自己实现，大体上无非以下思路：</p>
<a id="more"></a>
<ul>
<li>创建多个进程/线程来监听</li>
<li>Non-blocking读写监听的轮询</li>
<li>异步I/O与Unix Signal事件机制</li>
</ul>
<p>先来学习下linux源码是怎么处理select机制的：</p>
<blockquote>
<p>linux version: 5.10-r5</p>
</blockquote>
<h3 id="概览图"><a class="header-anchor" href="#概览图">¶</a>概览图</h3>
<p>梳理了下，大概整理成了流程图：</p>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/linux%E6%BA%90%E7%A0%81-select-1.png" alt=""></p>
<h3 id="select切入点"><a class="header-anchor" href="#select切入点">¶</a>select切入点</h3>
<p>既然知道了select属于fs系列的，那就很容易找到:[fs/select.c]</p>
<p>查看select命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man 2 select</span><br></pre></td></tr></table></figure>
<p>下面按照以下顺序来解读，一起学习：</p>
<ul>
<li>入口 SYSCALL_DEFINE5</li>
<li>核心函数 do_select</li>
<li>设备驱动的操作函数</li>
<li>poll_wait与设备的等待队列</li>
<li>fd数量限制「why」</li>
<li>select与poll</li>
</ul>
<h3 id="SYSCALL-DEFINE5"><a class="header-anchor" href="#SYSCALL-DEFINE5">¶</a>SYSCALL_DEFINE5</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE5(select, <span class="keyword">int</span>, n, fd_set __user *, inp, fd_set __user *, outp,</span><br><span class="line">		fd_set __user *, <span class="built_in">exp</span>, struct __kernel_old_timeval __user *, tvp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> kern_select(n, inp, outp, <span class="built_in">exp</span>, tvp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数：core_sys_select中主要的do_select处理其中的逻辑</p>
<h3 id="do-select"><a class="header-anchor" href="#do-select">¶</a>do_select</h3>
<p>关键性的结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> *in, *out, *ex; <span class="comment">//输出 、输入、异常</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> *res_in, *res_out, *res_ex;</span><br><span class="line">&#125; fd_set_bits;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, struct timespec64 *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">ktime_t</span> expire, *to = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">	poll_table *wait;</span><br><span class="line">	<span class="keyword">int</span> retval, i, timed_out = <span class="number">0</span>;</span><br><span class="line">	u64 slack = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">__poll_t</span> busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> busy_start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">    <span class="comment">//找出文件的最大描述符</span></span><br><span class="line">	retval = max_select_fd(n, fds);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	n = retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">	poll_initwait(&amp;table);</span><br><span class="line">	wait = &amp;table.pt;</span><br><span class="line">	<span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;</span><br><span class="line">		wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">		timed_out = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (end_time &amp;&amp; !timed_out)</span><br><span class="line">		slack = select_estimate_accuracy(end_time);</span><br><span class="line"></span><br><span class="line">	retval = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</span><br><span class="line">		<span class="keyword">bool</span> can_busy_loop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</span><br><span class="line">		rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历所有的fd.......同步等.....</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> in, out, ex, all_bits, <span class="built_in">bit</span> = <span class="number">1</span>, j;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">__poll_t</span> mask;</span><br><span class="line"></span><br><span class="line">			in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</span><br><span class="line">			all_bits = in | out | ex;</span><br><span class="line">            <span class="comment">//没有任何注册事件</span></span><br><span class="line">			<span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;</span><br><span class="line">				i += BITS_PER_LONG;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BITS_PER_LONG; ++j, ++i, <span class="built_in">bit</span> &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">				<span class="keyword">if</span> (i &gt;= n)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//跳过未注册的</span></span><br><span class="line">				<span class="keyword">if</span> (!(<span class="built_in">bit</span> &amp; all_bits))</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				f = fdget(i);</span><br><span class="line">				<span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">					wait_key_set(wait, in, out, <span class="built_in">bit</span>,</span><br><span class="line">						     busy_flag);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//对每一个fd进行检测</span></span><br><span class="line">					mask = vfs_poll(f.file, wait);</span><br><span class="line"></span><br><span class="line">					fdput(f);</span><br><span class="line">					<span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; <span class="built_in">bit</span>)) &#123;</span><br><span class="line">						res_in |= <span class="built_in">bit</span>;</span><br><span class="line">						retval++;</span><br><span class="line">						wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; <span class="built_in">bit</span>)) &#123;</span><br><span class="line">						res_out |= <span class="built_in">bit</span>;</span><br><span class="line">						retval++;</span><br><span class="line">						wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; <span class="built_in">bit</span>)) &#123;</span><br><span class="line">						res_ex |= <span class="built_in">bit</span>;</span><br><span class="line">						retval++;</span><br><span class="line">						wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">/* got something, stop busy polling */</span></span><br><span class="line">					<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">						can_busy_loop = <span class="literal">false</span>;</span><br><span class="line">						busy_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					 * only remember a returned</span></span><br><span class="line"><span class="comment">					 * POLL_BUSY_LOOP if we asked for it</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> (busy_flag &amp; mask)</span><br><span class="line">						can_busy_loop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (res_in)</span><br><span class="line">				*rinp = res_in;</span><br><span class="line">			<span class="keyword">if</span> (res_out)</span><br><span class="line">				*routp = res_out;</span><br><span class="line">			<span class="keyword">if</span> (res_ex)</span><br><span class="line">				*rexp = res_ex;</span><br><span class="line">			cond_resched();</span><br><span class="line">		&#125;</span><br><span class="line">		wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//退出循环，条件： 事件就绪/超时/收到信号</span></span><br><span class="line">		<span class="keyword">if</span> (retval || timed_out || signal_pending(current))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (table.error) &#123;</span><br><span class="line">			retval = table.error;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* only if found POLL_BUSY_LOOP sockets &amp;&amp; not out of time */</span></span><br><span class="line">		<span class="keyword">if</span> (can_busy_loop &amp;&amp; !need_resched()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!busy_start) &#123;</span><br><span class="line">				busy_start = busy_loop_current_time();</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!busy_loop_timeout(busy_start))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		busy_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If this is the first loop and we have a timeout</span></span><br><span class="line"><span class="comment">		 * given, then we convert to ktime_t and set the to</span></span><br><span class="line"><span class="comment">		 * pointer to the expiry value.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;</span><br><span class="line">			expire = timespec64_to_ktime(*end_time);</span><br><span class="line">			to = &amp;expire;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//超时就休眠一会儿「中断会儿」</span></span><br><span class="line">		<span class="keyword">if</span> (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,</span><br><span class="line">					   to, slack))</span><br><span class="line">			timed_out = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">poll_schedule_timeout</span><span class="params">(struct poll_wqueues *pwq, <span class="keyword">int</span> state,</span></span></span><br><span class="line"><span class="function"><span class="params">			  <span class="keyword">ktime_t</span> *expires, <span class="keyword">unsigned</span> <span class="keyword">long</span> slack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rc = -EINTR;</span><br><span class="line"></span><br><span class="line">	set_current_state(state);</span><br><span class="line">	<span class="keyword">if</span> (!pwq-&gt;triggered)</span><br><span class="line">		rc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);</span><br><span class="line">	__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Prepare for the next iteration.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The following smp_store_mb() serves two purposes.  First, it&#x27;s</span></span><br><span class="line"><span class="comment">	 * the counterpart rmb of the wmb in pollwake() such that data</span></span><br><span class="line"><span class="comment">	 * written before wake up is always visible after wake up.</span></span><br><span class="line"><span class="comment">	 * Second, the full barrier guarantees that triggered clearing</span></span><br><span class="line"><span class="comment">	 * doesn&#x27;t pass event check of the next iteration.  Note that</span></span><br><span class="line"><span class="comment">	 * this problem doesn&#x27;t exist for the first iteration as</span></span><br><span class="line"><span class="comment">	 * add_wait_queue() has full barrier semantics.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_store_mb(pwq-&gt;triggered, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="poll-wait"><a class="header-anchor" href="#poll-wait">¶</a>poll_wait</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * structures and helpers for f_op-&gt;poll implementations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//类似一个回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*poll_queue_proc)</span><span class="params">(struct file *, <span class="keyword">wait_queue_head_t</span> *, struct poll_table_struct *)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">	poll_queue_proc _qproc; <span class="comment">//callback机制</span></span><br><span class="line">	<span class="keyword">__poll_t</span> _key;</span><br><span class="line">&#125; poll_table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poll_wait</span><span class="params">(struct file * filp, <span class="keyword">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p &amp;&amp; p-&gt;_qproc &amp;&amp; wait_address)</span><br><span class="line">		p-&gt;_qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fd数量问题"><a class="header-anchor" href="#fd数量问题">¶</a>fd数量问题</h3>
<blockquote>
<p>include/uapi/linux/posix_types.h</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FD_SETSIZE	1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">//__FD_SETSIZE当下标使？？？what！</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> fds_bits[__FD_SETSIZE / (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">long</span>))];</span><br><span class="line">&#125; __kernel_fd_set;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面看来文件描述符只是一个整数值，用来操作下标的，主要是每一个进程file数组的下标。理解do_select是核心。</p>
</blockquote>
<h3 id="select-与poll"><a class="header-anchor" href="#select-与poll">¶</a>select 与poll</h3>
<blockquote>
<p>poll取消了最大数量的限制,返回结果还是需要轮询来获取就绪的描述符。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">short</span> events; <span class="comment">//request</span></span><br><span class="line">	<span class="keyword">short</span> revents; <span class="comment">// return</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>具体见后续更新「poll源码」</p>
<h3 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h3>
<p><a href="https://www.oreilly.com/openbook/linuxdrive3/book/">Linux Device Drivers, Third Edition</a><br>
<a href="https://stackoverflow.com/questions/11496059/how-do-system-calls-like-select-or-poll-work-under-the-hood">How do system calls like select() or poll() work under the hood?</a></p>
]]></content>
      <tags>
        <tag>Day</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>「20」博客诡异事件</title>
    <url>/archives/5ce14ff5.html</url>
    <content><![CDATA[<h3 id="博客CI-CD崩了"><a class="header-anchor" href="#博客CI-CD崩了">¶</a>博客CI CD崩了</h3>
<blockquote>
<p>就在刚才修改了部分的config配置，后打了tag push了上去,</p>
</blockquote>
<blockquote>
<p>oh…GG了</p>
</blockquote>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">err: FATAL Something&#39;s wrong. Maybe you can find the solution here: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html</span><br><span class="line">err: TypeError: Cannot read property &#39;enable&#39; of undefined</span><br><span class="line">err:     at ***&#x2F;themes&#x2F;nextTheme&#x2F;scripts&#x2F;filters&#x2F;comment&#x2F;disqus.js:11:21</span><br><span class="line">err:     at Filter.execSync (&#x2F;***&#x2F;node_modules&#x2F;hexo&#x2F;lib&#x2F;extend&#x2F;filter.js:74:28)</span><br><span class="line">err:     at Hexo.execFilterSync (&#x2F;***&#x2F;node_modules&#x2F;hexo&#x2F;lib&#x2F;hexo&#x2F;index.js:432:29)</span><br><span class="line">err:     at module.exports (***&#x2F;themes&#x2F;nextTheme&#x2F;scripts&#x2F;events&#x2F;lib&#x2F;injects.js:58:8)</span><br><span class="line">err:     at Hexo.&lt;anonymous&gt; (***&#x2F;themes&#x2F;nextTheme&#x2F;scripts&#x2F;events&#x2F;index.js:9:27)</span><br><span class="line">err:     at Hexo.emit (events.js:314:20)</span><br><span class="line">err:     at Hexo._generate (&#x2F;***&#x2F;node_modules&#x2F;hexo&#x2F;lib&#x2F;hexo&#x2F;index.js:399:8)</span><br><span class="line">err:     at &#x2F;***&#x2F;node_modules&#x2F;hexo&#x2F;lib&#x2F;hexo&#x2F;index.js:249:***</span><br><span class="line">err:     at tryCatcher (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;util.js:16:23)</span><br><span class="line">err:     at Promise._settlePromiseFromHandler (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:547:31)</span><br><span class="line">err:     at Promise._settlePromise (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:604:18)</span><br><span class="line">err:     at Promise._settlePromise0 (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:649:10)</span><br><span class="line">err:     at Promise._settlePromises (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:729:18)</span><br><span class="line">err:     at Promise._fulfill (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:673:18)</span><br><span class="line">err:     at PromiseArray._resolve (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise_array.js:127:19)</span><br><span class="line">err:     at PromiseArray._promiseFulfilled (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise_array.js:145:14)</span><br><span class="line">err:     at Promise._settlePromise (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:609:26)</span><br><span class="line">err:     at Promise._settlePromise0 (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:649:10)</span><br><span class="line">err:     at Promise._settlePromises (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:729:18)</span><br><span class="line">err:     at Promise._fulfill (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:673:18)</span><br><span class="line">err:     at Promise._resolveCallback (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:466:57)</span><br><span class="line">err:     at Promise._settlePromiseFromHandler (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:559:17)</span><br><span class="line">out: INFO  Start processing</span><br><span class="line">err: FATAL Something&#39;s wrong. Maybe you can find the solution here: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html</span><br><span class="line">err: TypeError: Cannot read property &#39;enable&#39; of undefined</span><br><span class="line">err:     at ***&#x2F;themes&#x2F;nextTheme&#x2F;scripts&#x2F;filters&#x2F;comment&#x2F;disqus.js:11:21</span><br><span class="line">err:     at Filter.execSync (&#x2F;***&#x2F;node_modules&#x2F;hexo&#x2F;lib&#x2F;extend&#x2F;filter.js:74:28)</span><br><span class="line">err:     at Hexo.execFilterSync (&#x2F;***&#x2F;node_modules&#x2F;hexo&#x2F;lib&#x2F;hexo&#x2F;index.js:432:29)</span><br><span class="line">err:     at module.exports (***&#x2F;themes&#x2F;nextTheme&#x2F;scripts&#x2F;events&#x2F;lib&#x2F;injects.js:58:8)</span><br><span class="line">err:     at Hexo.&lt;anonymous&gt; (***&#x2F;themes&#x2F;nextTheme&#x2F;scripts&#x2F;events&#x2F;index.js:9:27)</span><br><span class="line">err:     at Hexo.emit (events.js:314:20)</span><br><span class="line">err:     at Hexo._generate (&#x2F;***&#x2F;node_modules&#x2F;hexo&#x2F;lib&#x2F;hexo&#x2F;index.js:399:8)</span><br><span class="line">err:     at &#x2F;***&#x2F;node_modules&#x2F;hexo&#x2F;lib&#x2F;hexo&#x2F;index.js:249:***</span><br><span class="line">err:     at tryCatcher (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;util.js:16:23)</span><br><span class="line">err:     at Promise._settlePromiseFromHandler (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:547:31)</span><br><span class="line">err:     at Promise._settlePromise (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:604:18)</span><br><span class="line">err:     at Promise._settlePromise0 (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:649:10)</span><br><span class="line">err:     at Promise._settlePromises (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:729:18)</span><br><span class="line">err:     at Promise._fulfill (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:673:18)</span><br><span class="line">err:     at PromiseArray._resolve (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise_array.js:127:19)</span><br><span class="line">err:     at PromiseArray._promiseFulfilled (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise_array.js:145:14)</span><br><span class="line">err:     at Promise._settlePromise (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:609:26)</span><br><span class="line">err:     at Promise._settlePromise0 (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:649:10)</span><br><span class="line">err:     at Promise._settlePromises (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:729:18)</span><br><span class="line">err:     at Promise._fulfill (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:673:18)</span><br><span class="line">err:     at Promise._resolveCallback (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:466:57)</span><br><span class="line">err:     at Promise._settlePromiseFromHandler (&#x2F;***&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:559:17)</span><br></pre></td></tr></table></figure>
<p>简单点，显示没有enable这个属性，，，，我懵了，这部署了多少次了，没有出现这么个错误啊。</p>
<p>先删了js，本地跑ok了，远端挂了，又提示另一个js错误。<br>
再删一个错误的js,再跑…又挂了!</p>
<h3 id="排查…"><a class="header-anchor" href="#排查…">¶</a>排查…</h3>
<blockquote>
<p>初步定位为文件没有更到最新</p>
</blockquote>
<p>本地ok,服务器部署不起来…</p>
<p>查下文件scp copy的工作流</p>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120201117-000817@2x.png" alt=""></p>
<p>看起来很简单，也很好用，但是呢，大坑来了…<br>
当时没有选择是否选择覆盖文件：</p>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120201117-001054@2x.png" alt=""></p>
<h3 id="问题点"><a class="header-anchor" href="#问题点">¶</a>问题点</h3>
<p>没有覆盖配置文件，导致残留或者修改不彻底，同名的始终不修改，导致的问题。</p>
<p>PS：花了半个小时定位这么个rewrite的问题！ 记着吧，提醒自己…</p>
<h3 id="参考："><a class="header-anchor" href="#参考：">¶</a>参考：</h3>
<p><a href="https://github.com/appleboy/scp-action/blob/master/action.yml#L44">copy workflow Github</a><br>
<a href="https://github.com/marketplace/actions/scp-files">scp copy workflow</a></p>
]]></content>
      <tags>
        <tag>Day</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>「19」GPM 调度流程</title>
    <url>/archives/5c6a362f.html</url>
    <content><![CDATA[<p>工欲善其事，必先知其所以然…<br>
学习GPM调度之前，先看下源码部分的准备工作吧，不然一脸茫然的看源码，基本不会有太多的收获.</p>
<h3 id="函数-变量初识"><a class="header-anchor" href="#函数-变量初识">¶</a>函数&amp; 变量初识</h3>
<blockquote></blockquote>
<a id="more"></a>
<blockquote>
<p>go version: 1.14.3</p>
</blockquote>
<h4 id="函数"><a class="header-anchor" href="#函数">¶</a>函数</h4>
<blockquote>
<p>/proc.go</p>
</blockquote>
<ul>
<li>main</li>
<li>sysmon</li>
<li>findrunnable</li>
<li>gopark「1.1」</li>
<li>gosched 「1.2」</li>
<li>mstart</li>
<li>wakep</li>
<li>schedule</li>
<li>cpuinit</li>
<li>schedinit</li>
<li>ready</li>
<li>readgstatus</li>
<li>startm</li>
<li>pollWork</li>
<li>injectglist</li>
<li>park_m</li>
<li>goyield</li>
<li>retake</li>
<li>globrunqput</li>
<li>globrunqputbatch</li>
<li>globrunqputhead</li>
</ul>
<h4 id="变量"><a class="header-anchor" href="#变量">¶</a>变量</h4>
<blockquote>
<p>/proc.go</p>
</blockquote>
<ul>
<li>m0</li>
<li>g0</li>
<li>allgs</li>
<li>allglock</li>
</ul>
<blockquote>
<p>/runtime2.go</p>
</blockquote>
<ul>
<li>g</li>
<li>p</li>
<li>m</li>
<li>allglen</li>
<li>allm</li>
<li>allp</li>
<li>allpLock</li>
<li>gomaxprocs</li>
<li>sched</li>
</ul>
<blockquote>
<p>/runtime2.go 常量</p>
</blockquote>
<ul>
<li>_Grunnable/_Grunning/_Gwaiting…</li>
</ul>
<h3 id="上述这些函数-变量-常量-what？"><a class="header-anchor" href="#上述这些函数-变量-常量-what？">¶</a>上述这些函数/变量/常量 what？</h3>
<p>写这么多，肯定不是简单的从源码仓库里面超出来，这些是一些比较重要的函数，当然还有很多没有罗列，这里主要想记录，也是思考的点：</p>
<ul>
<li>GPM为何会有这么多的状态</li>
<li>这些状态之间是如何配合和协调的</li>
<li>著名的工作偷取「P」是怎么操作的</li>
<li>如果让你设计，你应该会怎么设计GPM这个调度的过程「🏁重点」</li>
</ul>
<h3 id="切入点"><a class="header-anchor" href="#切入点">¶</a>切入点</h3>
<ul>
<li>main:入口函数</li>
<li>sysmon：监控调度线程</li>
<li>schedule：真实的调度器逻辑</li>
<li>m0/g0：特殊的存在体</li>
</ul>
<h3 id="如何开始？"><a class="header-anchor" href="#如何开始？">¶</a>如何开始？</h3>
<blockquote>
<p>简单点，从main开始.</p>
</blockquote>
<h3 id="瞎扯"><a class="header-anchor" href="#瞎扯">¶</a>瞎扯</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">看了很长时间的go源码了，觉得一个好的设计，从来不是简单的学习别人的源码，</span><br><span class="line">更多的是学习源码的设计思路和当时设计时是基于哪种场景下的。</span><br><span class="line"></span><br><span class="line">考虑更多的场景，有没有其它的设计思路，可能没有现有的设计更出色，但更加适合别的场景。</span><br></pre></td></tr></table></figure>
<h3 id="未完待续"><a class="header-anchor" href="#未完待续">¶</a>未完待续.</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>GPM</tag>
        <tag>Go源码</tag>
      </tags>
  </entry>
  <entry>
    <title>「17」chrome headless「截图/PDF/DOM...」</title>
    <url>/archives/5544baea.html</url>
    <content><![CDATA[<blockquote>
<p>最近在搞一个需求：html「文件」渲染成png/jpg；chrome不能装在服务器中，可以打成docker镜像。<br>
说到这个，很多人肯定说很容易啊，chrome headless有现成的，直接用，它是不香么。<br>
然而事情并没有这么简单；</p>
</blockquote>
<h3 id="难点："><a class="header-anchor" href="#难点：">¶</a>难点：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、服务器中不能装chrome</span><br><span class="line"><span class="number">2</span>、chrome必须打在docker里面</span><br><span class="line"><span class="number">3</span>、渲染效果要和在本地效果一样：图片不能丢失字体，不能失真。</span><br><span class="line"><span class="number">4</span>、不能启动新的服务</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="切入点："><a class="header-anchor" href="#切入点：">¶</a>切入点：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">docker &amp;&amp; chrome</span><br></pre></td></tr></table></figure>
<blockquote>
<p>so先去搜一把有没有现成的可用？</p>
</blockquote>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/20201110-193745.png" alt=""></p>
<p>分析分析吧：</p>
<ul>
<li><a href="https://github.com/browserless/chrome">browserless</a></li>
<li><a href="https://github.com/puppeteer/puppeteer">puppeteer</a></li>
<li><a href="https://github.com/prisma-archive/chromeless">prisma-archive</a><br>
…
<ul>
<li>适合启动服务，然后进行测试或者跑服务</li>
<li>入参数为url</li>
</ul>
</li>
</ul>
<blockquote>
<p>所以上述的基本不符合需求，再寻找…</p>
</blockquote>
<h3 id="Zenika-alpine-chrome"><a class="header-anchor" href="#Zenika-alpine-chrome">¶</a><a href="https://github.com/Zenika/alpine-chrome">Zenika/alpine-chrome</a></h3>
<blockquote>
<p>看起来可行：</p>
</blockquote>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/20201110-194452.png" alt=""></p>
<p>这个经过验证总会有一个错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1110&#x2F;031547.366909:ERROR:bus.cc(393)] Failed to connect to the bus: Failed to connect to socket &#x2F;var&#x2F;run&#x2F;dbus&#x2F;system_bus_socket: No such file or directory</span><br><span class="line">[1110&#x2F;031547.367451:WARNING:dns_config_service_posix.cc(342)] Failed to read DnsConfig.</span><br><span class="line">[1110&#x2F;031547.437879:WARNING:dns_config_service_posix.cc(342)] Failed to read DnsConfig.</span><br><span class="line">[1110&#x2F;031549.073431:ERROR:headless_shell.cc(591)] Writing to file code&#x2F;ss.png was unsuccessful, could not open file: FILE_ERROR_ACCESS_DENIED</span><br></pre></td></tr></table></figure>
<p>文件没权限哦，尴尬了,再修正：</p>
<blockquote>
<p>发现源码有一段添加了用户，汗，太搞了.</p>
</blockquote>
<p><a href="https://github.com/Zenika/alpine-chrome/blob/master/Dockerfile#L38">点击查看</a></p>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/20201110-194711.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">很郁闷这个chrome用户干嘛的，如果真用这个，那得确定你跑的环境要允许你添加一个user出来，很明显不行,</span><br><span class="line">这样导致整个alpine-chrome服务权限都是乱的「chrome用户的」,最明显的是无法读写文件，因为你这个add chrome没权限。</span><br><span class="line"></span><br><span class="line">最直接的，去掉就好了。</span><br><span class="line"></span><br><span class="line">果然去掉后，跑docker就可以了</span><br></pre></td></tr></table></figure>
<p><a href="https://hub.docker.com/r/zenika/alpine-chrome">docker镜像地址</a></p>
<p>这个是可以了，但是有一个新的问题，图像失真了，再去查github源码，坑那，压根没有装全文字库，只简单装了lib***的库。</p>
<h3 id="再尝试「自己搞个docker-images」"><a class="header-anchor" href="#再尝试「自己搞个docker-images」">¶</a>再尝试「自己搞个docker images」</h3>
<blockquote>
<p>别人都能搞，为何我不可以勒</p>
</blockquote>
<h3 id="分析："><a class="header-anchor" href="#分析：">¶</a>分析：</h3>
<ul>
<li>本地跑这个服务是ok的，那chrome就是依赖macos/linux系统的</li>
<li>那可以搞个linux系统，再装个chrome</li>
<li>最后把字体装完就ok了</li>
<li>最后的最后，想办法直接可以用这个docker，不用启动服务，也就是说docker run之后有了结果，直接rm掉。</li>
</ul>
<h3 id="思路："><a class="header-anchor" href="#思路：">¶</a>思路：</h3>
<ul>
<li>1、搞个docker debain系统</li>
<li>2、想办法把chrome装上</li>
<li>3、在里面跑一个测试，看能否生成图片</li>
<li>4、安装缺失的字体</li>
<li>5、container跑起来</li>
<li>6、导出container，再导入到本地的images；让container变成images</li>
<li>7、自己搞个Dockerfile，把「RUN」接口留出来，方便可以直接跑起来</li>
<li>8、再把搞好的images导出来用就可以了。</li>
</ul>
<h3 id="步骤："><a class="header-anchor" href="#步骤：">¶</a>步骤：</h3>
<h4 id="1"><a class="header-anchor" href="#1">¶</a>1</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull debian</span><br></pre></td></tr></table></figure>
<h4 id="2-3-4-5"><a class="header-anchor" href="#2-3-4-5">¶</a>2/3/4/5</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、进入系统</span><br><span class="line">docker exec -it XXXXX &#x2F;bin&#x2F;bash</span><br><span class="line">2、更新源</span><br><span class="line">apt-get update</span><br><span class="line">3、下载wget</span><br><span class="line">apt-get install wget</span><br><span class="line">4、下载chrome linux版本的</span><br><span class="line">wget https:&#x2F;&#x2F;dl.google.com&#x2F;linux&#x2F;direct&#x2F;google-chrome-stable_current_amd64.deb</span><br><span class="line">5、安装chrome</span><br><span class="line"> dpkg -i ******.deb</span><br><span class="line"> 解决依赖关系：</span><br><span class="line">    apt-get -f install</span><br><span class="line">6、跑一把发现汉字变问好「？」了</span><br><span class="line">7、安装缺失的字体</span><br><span class="line">apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy</span><br></pre></td></tr></table></figure>
<h4 id="6导出container"><a class="header-anchor" href="#6导出container">¶</a>6导出container</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、导出container</span><br><span class="line">docker export container_name &gt; chrome.tar</span><br><span class="line">2、导入到images中</span><br><span class="line">docker load &lt; chrome.tar</span><br></pre></td></tr></table></figure>
<h4 id="7自己搞Dockerfile-预留「RUN」接口"><a class="header-anchor" href="#7自己搞Dockerfile-预留「RUN」接口">¶</a>7自己搞Dockerfile,预留「RUN」接口</h4>
<p>Dockerfile文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#这个是上一步导入的images</span><br><span class="line">FROM gogoowang&#x2F;chrome:v1</span><br><span class="line">RUN mkdir -p &#x2F;home</span><br><span class="line">WORKDIR &#x2F;home</span><br><span class="line">ENTRYPOINT [&quot;chrome&quot;,&quot;--headless&quot;,&quot;--disable-gpu&quot;]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>构建成镜像：docker build -t gogoo/chrome:v2 .</p>
</blockquote>
<p>PS:「/home」的含义就是这个images的工作目录是/home文件夹下面</p>
<h4 id="8跑一把，收工"><a class="header-anchor" href="#8跑一把，收工">¶</a>8跑一把，收工</h4>
<h3 id="注意点："><a class="header-anchor" href="#注意点：">¶</a>注意点：</h3>
<h4 id="PS-1"><a class="header-anchor" href="#PS-1">¶</a>PS-1</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、错误❌</span><br><span class="line">docker container run -it --rm -v &#x2F;tmp:&#x2F;home gogoowang&#x2F;chrome:v1 --no-sandbox --screenshot --hide-scrollbars &#x2F;XXXX&#x2F;XXXX.html</span><br><span class="line">2、正确</span><br><span class="line">docker container run -i --rm -v &#x2F;tmp:&#x2F;home gogoowang&#x2F;chrome:v1 --no-sandbox --screenshot&#x3D;&#x2F;home&#x2F;xx.png --hide-scrollbars &#x2F;XXXX&#x2F;XXXX.html</span><br><span class="line"></span><br><span class="line">少一个 -t，这个 -t：再搞一个临时的TTy来跑程序，既然是后台跑的，那就没必要了</span><br></pre></td></tr></table></figure>
<h4 id="PS-2"><a class="header-anchor" href="#PS-2">¶</a>PS-2</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container run -i --rm -v &#x2F;tmp:&#x2F;home gogoowang&#x2F;chrome:v1 --no-sandbox --screenshot&#x3D;&#x2F;home&#x2F;xx.png --hide-scrollbars &#x2F;XXXX&#x2F;XXXX.html</span><br><span class="line"></span><br><span class="line">1、关于这个-v的问题,后面就固定了，具体见Dockerfile中</span><br><span class="line">2、--screenshot路径问题，既然是docker镜像，那就得填个docker镜像中的地址，那就是&#x2F;home下面了</span><br></pre></td></tr></table></figure>
<h3 id="优化后一键脚本"><a class="header-anchor" href="#优化后一键脚本">¶</a>优化后一键脚本</h3>
<p>Dockerfile文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM debian</span><br><span class="line">RUN apt-get update </span><br><span class="line">RUN apt-get install -y wget </span><br><span class="line">RUN wget https:&#x2F;&#x2F;dl.google.com&#x2F;linux&#x2F;direct&#x2F;google-chrome-stable_current_amd64.deb </span><br><span class="line">RUN dpkg -i google-chrome-stable_current_amd64.deb || true</span><br><span class="line">RUN apt-get -f -y install</span><br><span class="line">RUN apt-get install -y ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy</span><br><span class="line">RUN mkdir -p &#x2F;home</span><br><span class="line">WORKDIR &#x2F;home</span><br><span class="line">ENTRYPOINT [&quot;&#x2F;opt&#x2F;google&#x2F;chrome&#x2F;chrome&quot;,&quot;--headless&quot;,&quot;--disable-gpu&quot;]</span><br></pre></td></tr></table></figure>
<p>构建：</p>
<blockquote>
<p>docker build -t google-chrome:latest .</p>
</blockquote>
]]></content>
      <tags>
        <tag>Day</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>「16」go源码words归纳</title>
    <url>/archives/425d5e80.html</url>
    <content><![CDATA[<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<p>好久没有更新了，不是不更新，最近感冒严重，一直没好，太影响身体了…「身体还是很重要的!」</p>
<p>当然了，在生病期间也看了很多东西，更多的思考了许多：人生规划的、如何学习技术、后续的生涯发展之类的。「思考的方式很多种，不建议去生病了才去思考.」</p>
<blockquote>
<p>后续会更新一篇，主要是结合之前的成长和技术的壁垒来说说后续想怎么学，怎么发展，生涯规划吧。</p>
</blockquote>
<p>不扯了，这篇主要想记录一些词汇，主要还是在阅读Go源码中的一些词汇，毕竟英文有点差，再不积累就更差了。</p>
<h3 id="Words"><a class="header-anchor" href="#Words">¶</a>Words</h3>
<h4 id="全称"><a class="header-anchor" href="#全称">¶</a>全称</h4>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">「<span class="number">11</span>/<span class="number">3</span>」</span><br><span class="line">Preempt  v 抢占、掠夺                                   --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">retake   v 重新获取「重新分配」                           --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">syscall  v 系统调用                                     --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">decrement v 递减                                       --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">pretending  v 假装、伪装                                --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">contended  v 竞争                                      --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">procresize  v 扩大                                     --&gt; /proc.<span class="keyword">go</span> </span><br><span class="line">corruption  n 腐败，译：损坏</span><br><span class="line">infinite  adj 无限的  </span><br><span class="line">reproduce v  复制</span><br><span class="line">consists  v 组成</span><br><span class="line">reproducer  v 复制</span><br><span class="line">allocating v 分配</span><br><span class="line">embed   v 嵌入 </span><br><span class="line"></span><br><span class="line">「<span class="number">11</span>/<span class="number">5</span>」</span><br><span class="line">assembly  n  装配                                      --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">amortizes  v  缓冲                                     --&gt; /proc.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">「<span class="number">11</span>/<span class="number">25</span>」</span><br><span class="line">guard  v. 看守																				 --&gt; /proc.<span class="keyword">go</span></span><br><span class="line">Alternatively  或者																		--&gt;  /runtime/rwmutex.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">「later」</span><br><span class="line">demonstrate  v 演示</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="简写"><a class="header-anchor" href="#简写">¶</a>简写</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">「<span class="number">11</span>/<span class="number">3</span>」</span><br><span class="line">sysmon -&gt; system monitor 系统监控                                               /proc.<span class="keyword">go</span></span><br><span class="line">incidlelocked  --&gt; increment idle locked   增加空闲锁                           /proc.<span class="keyword">go</span></span><br><span class="line">sysmontick  --&gt; system monitor ticket   系统监控数量                            /proc.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<h3 id="持续更新…"><a class="header-anchor" href="#持续更新…">¶</a>持续更新…</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
      </tags>
  </entry>
  <entry>
    <title>「15」Plan9 汇编小记</title>
    <url>/archives/2ce846ed.html</url>
    <content><![CDATA[<h4 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h4>
<blockquote>
<p>平常coding时，偶尔会查看计算机的具体执行过程，那最基本的就是汇编了，了解汇编是调试过程中必不可少的，尤其是一些细节的处理方面.Go的汇编是Plan 9(贝尔实验室的产物)，和汇编很类似。</p>
</blockquote>
<h4 id="如何得到汇编结果？"><a class="header-anchor" href="#如何得到汇编结果？">¶</a>如何得到汇编结果？</h4>
<ul>
<li>官网文档</li>
<li>Google</li>
</ul>
<h5 id="3种方式："><a class="header-anchor" href="#3种方式：">¶</a>3种方式：</h5>
<blockquote>
<p>第一种</p>
</blockquote>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> tool compile -N -l -S ***.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>第二种</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、先编译：</span><br><span class="line">    <span class="keyword">go</span> tool compile -N -l ***.<span class="keyword">go</span></span><br><span class="line"><span class="number">2</span>、再反编译：</span><br><span class="line">    <span class="keyword">go</span> tool objdump ***.o</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三种</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> build -gcflags -S ***.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<h4 id="常用寄存器"><a class="header-anchor" href="#常用寄存器">¶</a>常用寄存器</h4>
<h5 id="AX-BX-CX-DX-BP-SI-SP-IP"><a class="header-anchor" href="#AX-BX-CX-DX-BP-SI-SP-IP">¶</a>AX BX CX DX BP SI SP IP</h5>
<table>
<thead>
<tr>
<th style="text-align:left">寄存器</th>
<th style="text-align:left">16位</th>
<th style="text-align:left">32位</th>
<th style="text-align:left">64位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">累加寄存器</td>
<td style="text-align:left">AX</td>
<td style="text-align:left">EAX</td>
<td style="text-align:left">RAX</td>
</tr>
<tr>
<td style="text-align:left">基址寄存器</td>
<td style="text-align:left">BX</td>
<td style="text-align:left">EBX</td>
<td style="text-align:left">RBX</td>
</tr>
<tr>
<td style="text-align:left">计数寄存器</td>
<td style="text-align:left">CX</td>
<td style="text-align:left">ECX</td>
<td style="text-align:left">RCX</td>
</tr>
<tr>
<td style="text-align:left">数据寄存器</td>
<td style="text-align:left">DX</td>
<td style="text-align:left">EDX</td>
<td style="text-align:left">RDX</td>
</tr>
<tr>
<td style="text-align:left">堆栈基指针</td>
<td style="text-align:left">BP</td>
<td style="text-align:left">EBP</td>
<td style="text-align:left">RBP</td>
</tr>
<tr>
<td style="text-align:left">变址寄存器</td>
<td style="text-align:left">SI</td>
<td style="text-align:left">ESI</td>
<td style="text-align:left">RSI</td>
</tr>
<tr>
<td style="text-align:left">堆栈顶指针</td>
<td style="text-align:left">SP</td>
<td style="text-align:left">ESP</td>
<td style="text-align:left">RSP</td>
</tr>
<tr>
<td style="text-align:left">指令寄存器</td>
<td style="text-align:left">IP</td>
<td style="text-align:left">EIP</td>
<td style="text-align:left">RIP</td>
</tr>
</tbody>
</table>
<h5 id="MOV"><a class="header-anchor" href="#MOV">¶</a>MOV</h5>
<blockquote>
<p>movb（8位）、movw（16位）、movl（32位）、movq（64位）</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MOVSS: 移动单精度浮点数</span><br></pre></td></tr></table></figure>
<h4 id="查询地址"><a class="header-anchor" href="#查询地址">¶</a>查询地址</h4>
<p><a href="https://c9x.me/x86/html/file_module_x86_id_205.html">MOVSS</a><br>
<a href="https://www.felixcloutier.com/x86/index.html">Intel汇编指令查询</a><br>
<a href="https://plan9.io/sources/contrib/ericvh/go-plan9/src/pkg/runtime/slice.c">Plan9查询</a></p>
<h4 id="持续更新…"><a class="header-anchor" href="#持续更新…">¶</a>持续更新…</h4>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Day</tag>
        <tag>Plan9</tag>
      </tags>
  </entry>
  <entry>
    <title>「14」hexo-安装&amp;插件</title>
    <url>/archives/ae4aba0d.html</url>
    <content><![CDATA[<p>hexo安装及其第三方插件包下载总结，以便后续CI一次到位。</p>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> npm install -g hexo-cli</span><br><span class="line"> npm install hexo-renderer-sass --save</span><br><span class="line"> npm install hexo-generator-searchdb --save</span><br><span class="line"> npm install hexo-generator-sitemap --save</span><br><span class="line"> npm install hexo-generator-baidu-sitemap --save</span><br><span class="line"> npm install request --save</span><br><span class="line"> npm install xml-parser --save</span><br><span class="line"> npm install yamljs --save</span><br><span class="line"> npm install md5 --save</span><br><span class="line"> npm install request --save</span><br><span class="line"> npm install xml-parser --save</span><br><span class="line"> npm install yamljs --save</span><br><span class="line"> npm install cheerio --save</span><br><span class="line"> npm install blueimp-md5 --save</span><br><span class="line"> npm install hexo-abbrlink --save</span><br><span class="line"> npm audit fix</span><br><span class="line"></span><br><span class="line"> npm uninstall hexo-generator-index --save</span><br><span class="line"> npm install hexo-generator-index-pin-top --save</span><br><span class="line"> npm audit fix</span><br><span class="line"> </span><br><span class="line"> npm install hexo-neat --save</span><br><span class="line"> npm audit fix</span><br><span class="line"> npm install --save hexo-admin</span><br><span class="line"> npm audit fix</span><br><span class="line"> npm install hexo-deployer-git --save</span><br><span class="line"> npm audit fix</span><br><span class="line"></span><br><span class="line"> sudo npm install hexo-toc --save</span><br><span class="line"> npm audit fix</span><br><span class="line"></span><br><span class="line"><span class="comment">//猫咪模型</span></span><br><span class="line"> sudo npm install --save hexo-helper-live2d </span><br><span class="line"> npm audit fix</span><br><span class="line"> sudo npm install --save live2d-widget-model-z16</span><br></pre></td></tr></table></figure>
<blockquote>
<p>update: 2021-02-05 19:25:42</p>
</blockquote>
<p>hexo next解析插件更换：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked -S</span><br><span class="line"></span><br><span class="line"> npm uninstall hexo-renderer-marked --save</span><br><span class="line"></span><br><span class="line">再安装下面插件：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">npm install --save markdown-it-abbr</span><br><span class="line">npm install --save markdown-it-footnote</span><br><span class="line">npm install --save markdown-it-ins</span><br><span class="line">npm install --save markdown-it-sub</span><br><span class="line">npm install --save markdown-it-sup</span><br><span class="line">npm install --save markdown-it-anchor</span><br><span class="line">npm install --save markdown-it-deflist</span><br><span class="line">npm install --save markdown-it-mark</span><br><span class="line">npm install --save markdown-it-container</span><br><span class="line"></span><br><span class="line">npm install --save markdown-it-emoji</span><br><span class="line">npm install --save markdown-it-attrs</span><br><span class="line">npm install --save markdown-it-task-lists</span><br><span class="line">npm install --save markdown-it<span class="number">-68</span>tygbv </span><br><span class="line"></span><br><span class="line">npm install markdown-it-mathjax --save</span><br><span class="line">npm audit fix</span><br><span class="line">npm i markdown-it-latex2img --save</span><br><span class="line">npm audit fix</span><br><span class="line">npm install markdown-it-texmath</span><br><span class="line">npm audit fix</span><br><span class="line"></span><br><span class="line">最后更新下hexo更目录下的_config.yaml</span><br><span class="line"></span><br><span class="line"># Markdown-it config</span><br><span class="line">## Docs: https:<span class="comment">//github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class="line">markdown:</span><br><span class="line">  render:</span><br><span class="line">    # Enable HTML tags in source</span><br><span class="line">    html: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    # Use <span class="string">&#x27;/&#x27;</span> to <span class="built_in">close</span> single tags (&lt;br /&gt;). This is only <span class="keyword">for</span> full CommonMark compatibility.</span><br><span class="line">    xhtmlOut: <span class="literal">true</span>        </span><br><span class="line"></span><br><span class="line">    # Convert <span class="string">&#x27;\n&#x27;</span> in paragraphs into &lt;br&gt; </span><br><span class="line">    breaks: <span class="literal">true</span>      </span><br><span class="line"></span><br><span class="line">    # CSS language prefix <span class="keyword">for</span> fenced blocks. Can be useful <span class="keyword">for</span> external highlighters.</span><br><span class="line">    langPrefix: <span class="string">&#x27;language-&#x27;</span>  </span><br><span class="line"></span><br><span class="line">    # Autoconvert URL-like text to links </span><br><span class="line">    linkify: <span class="literal">true</span>        </span><br><span class="line"></span><br><span class="line">    # Enable some language-neutral replacement + quotes beautification</span><br><span class="line">    typographer: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    # Double + single quotes replacement pairs, when typographer enabled,</span><br><span class="line">    # and smartquotes on. Could be either a String or an Array.</span><br><span class="line">    #</span><br><span class="line">    # For example, you can use <span class="string">&#x27;«»„“&#x27;</span> <span class="keyword">for</span> Russian, <span class="string">&#x27;„“‚‘&#x27;</span> <span class="keyword">for</span> German,</span><br><span class="line">    # and [<span class="string">&#x27;«\xA0&#x27;</span>, <span class="string">&#x27;\xA0»&#x27;</span>, <span class="string">&#x27;‹\xA0&#x27;</span>, <span class="string">&#x27;\xA0›&#x27;</span>] <span class="keyword">for</span> French (including nbsp).</span><br><span class="line">    quotes: <span class="string">&#x27;“”‘’&#x27;</span></span><br><span class="line"></span><br><span class="line">  # Plugins</span><br><span class="line">  plugins:</span><br><span class="line">    - markdown-it-abbr</span><br><span class="line">    - markdown-it-footnote</span><br><span class="line">    - markdown-it-ins</span><br><span class="line">    - markdown-it-sub</span><br><span class="line">    - markdown-it-sup</span><br><span class="line">    - markdown-it-anchor</span><br><span class="line">    - markdown-it-deflist</span><br><span class="line">    - markdown-it-mark</span><br><span class="line">    - markdown-it-container</span><br><span class="line"></span><br><span class="line">    - markdown-it-emoji</span><br><span class="line">    - markdown-it-named-headings</span><br><span class="line">    - markdown-it-toc</span><br><span class="line">    - markdown-it-attrs</span><br><span class="line">    - name: markdown-it-task-lists</span><br><span class="line">      options:</span><br><span class="line">        enabled: <span class="literal">false</span></span><br><span class="line">        label: <span class="literal">true</span></span><br><span class="line">        labelAfter: <span class="literal">false</span></span><br><span class="line">  </span><br><span class="line">  # Automatic Headline ID<span class="string">&#x27;s</span></span><br><span class="line"><span class="string">  anchors:</span></span><br><span class="line"><span class="string">    # Minimum level for ID creation. (Ex. h2 to h6)</span></span><br><span class="line"><span class="string">    level: 2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # A suffix that is prepended to the number given if the ID is repeated.</span></span><br><span class="line"><span class="string">    collisionSuffix: &#x27;</span>v<span class="string">&#x27;           </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # If `true`, creates an anchor tag with a permalink besides the heading.</span></span><br><span class="line"><span class="string">    permalink: false              </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # Class used for the permalink anchor tag.</span></span><br><span class="line"><span class="string">    permalinkClass: header-anchor </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # The symbol used to make the permalink</span></span><br><span class="line"><span class="string">    permalinkSymbol: ¶</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>hexo gulp兼容es5:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp --save</span><br><span class="line">npm audit fix</span><br><span class="line">npm install gulp-minify-css --save</span><br><span class="line">npm audit fix</span><br><span class="line">npm install gulp-uglify --save</span><br><span class="line">npm audit fix</span><br><span class="line">npm install gulp-htmlmin --save</span><br><span class="line">npm audit fix</span><br><span class="line">npm install gulp-htmlclean --save</span><br><span class="line">npm audit fix</span><br><span class="line">npm install gulp-imagemin --save</span><br><span class="line">npm audit fix</span><br><span class="line"></span><br><span class="line">npm install babel-core@6.26.3 --save</span><br><span class="line">npm install gulp-babel@7.0.1 --save</span><br><span class="line">npm install babel-preset-es2015@6.24.1 --save</span><br><span class="line">npm audit fix</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>未完待续…</p>
</blockquote>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>「13」Linux 进程</title>
    <url>/archives/ba455c1d.html</url>
    <content><![CDATA[<p>进程这是个老生常谈的问题，当然我不是那个老生，我只是个loser。</p>
<p>今天用chrome，占用很多的内存和资源，查了查，说chrome是多进程的，于是就想了解下进程一些相关的内容。<br>
主要从以下几个角度了解下进程：</p>
<ul>
<li>来源</li>
<li>定义</li>
<li>特征</li>
<li>多进程如何工作？</li>
<li>通信</li>
</ul>
<a id="more"></a>
<h3 id="来源"><a class="header-anchor" href="#来源">¶</a>来源</h3>
<p>抽象正在运行的程序，或者说是对计算机系统存储器的调度和管理。</p>
<h3 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h3>
<p>进程：并发程序在执行过程中资源分配和管理的最基本的单元（资源分配的最小单元，执行的最小单元）。一个程序一旦开始执行，就是一个进程。每一个进程都有自己的独立空间，系统会分配一定的地址空间和完整的数据段空间。</p>
<p>ps:[线程：程序执行的最小单位。]</p>
<p>组成：程序、数据、控制块组成。</p>
<h3 id="特征"><a class="header-anchor" href="#特征">¶</a>特征</h3>
<ul>
<li>动态性 ： 多个程序执行过程中的一次执行过程，进程是动态产生，动态销毁的。</li>
<li>并发性 ： 任何进程可以和其它进程并发执行。</li>
<li>独立性 ： 是独立运行的基本单元，也是资源分配和调度的独立单元。</li>
<li>异步性 ： 由于进程间的相互制约，进程间是各自独立，各自向前。</li>
</ul>
<h3 id="多进程工作："><a class="header-anchor" href="#多进程工作：">¶</a>多进程工作：</h3>
<h4 id="进程的状态："><a class="header-anchor" href="#进程的状态：">¶</a>进程的状态：</h4>
<blockquote>
<p>3种状态：</p>
</blockquote>
<ul>
<li>就绪</li>
<li>运行</li>
<li>阻塞</li>
</ul>
<h5 id="3态图："><a class="header-anchor" href="#3态图：">¶</a>3态图：</h5>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/linux_process_3.1.png" alt=""></p>
<h5 id="5态图："><a class="header-anchor" href="#5态图：">¶</a>5态图：</h5>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/linux_p3.png" alt=""></p>
<h5 id="7态图："><a class="header-anchor" href="#7态图：">¶</a>7态图：</h5>
<p>新增两种状态：</p>
<ul>
<li>挂起就绪状态：表明进程具备了运行的条件，目前在二级存储器里面。</li>
<li>挂起等待状态：表明进程正在等待某一个事件的结束且目前在二级存储器里面。</li>
</ul>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/linux_process_7.png" alt=""></p>
<h3 id="进程间通信"><a class="header-anchor" href="#进程间通信">¶</a>进程间通信</h3>
<h4 id="共享内存"><a class="header-anchor" href="#共享内存">¶</a>共享内存</h4>
<p>映射一段能被其它进程访问的内存，一个进程创建，其它进程可访问。共享内存是最快的IPC方式，往往和信号量一起使用，达到进程间的同步和互斥。</p>
<h4 id="管道"><a class="header-anchor" href="#管道">¶</a>管道</h4>
<p>实质就是一个缓冲区。<br>
管道限制：</p>
<ul>
<li>半双工</li>
<li>只能在亲缘进程间通信</li>
</ul>
<p><strong>特点:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">写满时，不能再写，读空时，不能再读</span><br><span class="line">没写满，不能读，没读空，不能写</span><br></pre></td></tr></table></figure>
<h4 id="消息队列"><a class="header-anchor" href="#消息队列">¶</a>消息队列</h4>
<p>是一种消息的链表，解决了信号传递信息少，管道只能承载无格式字节流及管道大小限制的缺点。</p>
<h4 id="信号"><a class="header-anchor" href="#信号">¶</a>信号</h4>
<p>通知和接受进程某个事件已经发生了的。</p>
<h4 id="信号量"><a class="header-anchor" href="#信号量">¶</a>信号量</h4>
<p>实质上就是个计数器，用来控制多个进程对于共享资源的访问情况。</p>
<h4 id="套接字（Socket）"><a class="header-anchor" href="#套接字（Socket）">¶</a>套接字（Socket）</h4>
<p>进程间通信的一种机制，多用于不同机器进程间的通信。</p>
<h4 id="优缺点："><a class="header-anchor" href="#优缺点：">¶</a>优缺点：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、管道：速度慢，容量有限，只有父子进程能通讯.</span><br><span class="line"><span class="number">2</span>、FIFO：任何进程间都能通讯，但速度慢.</span><br><span class="line"><span class="number">3</span>、消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题.</span><br><span class="line"><span class="number">4</span>、信号量：不能传递复杂消息，只能用来同步.</span><br><span class="line"><span class="number">5</span>、共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存.</span><br></pre></td></tr></table></figure>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>「12」go 指针和引用</title>
    <url>/archives/1191d613.html</url>
    <content><![CDATA[<p>今写代码时，传函数无意间想到一个问题，slice通过参数传递给函数，为何可以改变具体的值呢？</p>
<p>如何解决这个问题？</p>
<ul>
<li>官方查文档</li>
<li>看源码</li>
<li>google看看有没有好的见解</li>
<li>思考🤔+冥想🧘‍♂️</li>
</ul>
<p>（ps:解决问题，主要不是看结果是怎么样的，主要是考虑问题的角度）</p>
<a id="more"></a>
<h3 id="查资料"><a class="header-anchor" href="#查资料">¶</a>查资料</h3>
<p><a href="https://golang.google.cn/doc/effective_go.html#slices">官网指南之Slice</a><br>
有一段是这么描述：<br>
<em>Slices hold references to an underlying array, and if you assign one slice to another, both refer to the same array.</em></p>
<h3 id="查源码"><a class="header-anchor" href="#查源码">¶</a>查源码</h3>
<h4 id="src-runtime-slice-go"><a class="header-anchor" href="#src-runtime-slice-go">¶</a>/src/runtime/slice.go</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer  <span class="comment">//指针类型哦</span></span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思考"><a class="header-anchor" href="#思考">¶</a>思考</h3>
<blockquote>
<p>原来下层是用过array这个指针，指向具体的数据的</p>
</blockquote>
<blockquote>
<p>那么其他的引用类型呢？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map?</span><br><span class="line">chan?</span><br><span class="line">interface?</span><br><span class="line">&#x2F;&#x2F;Slice?</span><br></pre></td></tr></table></figure>
<h3 id="引用类型之Map"><a class="header-anchor" href="#引用类型之Map">¶</a>引用类型之Map</h3>
<h4 id="看源码-src-runtime-map-go："><a class="header-anchor" href="#看源码-src-runtime-map-go：">¶</a>看源码 /src/runtime/map.go：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.</span></span><br><span class="line">	<span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span></span><br><span class="line">	count     <span class="keyword">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">	flags     <span class="keyword">uint8</span></span><br><span class="line">	B         <span class="keyword">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">	noverflow <span class="keyword">uint16</span> <span class="comment">// approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line">	hash0     <span class="keyword">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过此指针类型</span></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">	nevacuate  <span class="keyword">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用类型之Chan"><a class="header-anchor" href="#引用类型之Chan">¶</a>引用类型之Chan</h3>
<h4 id="源码-src-runtime-chan-go"><a class="header-anchor" href="#源码-src-runtime-chan-go">¶</a>源码:/src/runtime/chan.go</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">    <span class="comment">//通过此指针类型来处理</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">	<span class="comment">// with stack shrinking.</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用类型之Interface"><a class="header-anchor" href="#引用类型之Interface">¶</a>引用类型之Interface</h3>
<h4 id="源码-src-runtime-runtime2-go"><a class="header-anchor" href="#源码-src-runtime-runtime2-go">¶</a>源码/src/runtime/runtime2.go</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab</span><br><span class="line">    <span class="comment">//指针类型</span></span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    <span class="comment">//指针类型</span></span><br><span class="line">	data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结论？通过指针？"><a class="header-anchor" href="#结论？通过指针？">¶</a>结论？通过指针？</h3>
<p>从上述源码看来，内部结构中都是用指针类型来指向具体的值，</p>
<blockquote>
<p>So：形同这类的结构，肯定是引用类型的，具体是指针指向别的地址，从而来引用值。</p>
</blockquote>
<p>其实这个特性很早就晓得了，只是今天又看到了，觉得还是记录着吧，也许后续哪一天就有了创新的灵感来着~~.</p>
<p>[睡觉了～最近有点乏～ZZzzz…]</p>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go Package</tag>
        <tag>Day</tag>
      </tags>
  </entry>
  <entry>
    <title>「11」hexo 主题&amp;评论&amp;进度条&amp;背景效果</title>
    <url>/archives/e18c94ab.html</url>
    <content><![CDATA[<p>晚上折腾了下博客，稍微装饰了下，主要还是加了个评论吧，其它非常秀的插件就没有接入了，懒得折腾，好好写博客，内容才是精华。<br>
记录下折腾史：</p>
<h3 id="gitalk评论插件"><a class="header-anchor" href="#gitalk评论插件">¶</a>gitalk评论插件</h3>
<h4 id="步骤："><a class="header-anchor" href="#步骤：">¶</a>步骤：</h4>
<h5 id="申请id和secret"><a class="header-anchor" href="#申请id和secret">¶</a>申请id和secret</h5>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/36f31671-8ada-4cbe-b60b-d1595dd701ee.png" alt=""></p>
<a id="more"></a>
<h4 id="配置文件："><a class="header-anchor" href="#配置文件：">¶</a>配置文件：</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  github_id: crab21 # GitHub repo owner</span><br><span class="line">  repo: blog # Repository name to store issues</span><br><span class="line">  client_id: XXX # GitHub Application Client ID</span><br><span class="line">  client_secret: XXX # GitHub Application Client Secret</span><br><span class="line">  admin_user: crab21 # GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span><br><span class="line">  distraction_free_mode: true # Facebook-like distraction free mode</span><br><span class="line">  perPage: 15 #每页多少个评论</span><br><span class="line">  pagerDirection: last  #排序方式是从旧到新（first）还是从新到旧（last）</span><br><span class="line">  createIssueManually: true #如果当前页面没有相应的 isssue ，且登录的用户属于 admin，则会自动创建 issue。如果设置为 true，则显示一个初始化页面，创建 issue 需要点击 init 按钮。</span><br><span class="line">  distractionFreeMode: true #是否启用快捷键(cmd|ctrl + enter) 提交评论.</span><br><span class="line"></span><br><span class="line">  # Gitalk&#39;s display language depends on user&#39;s browser or system environment</span><br><span class="line">  # If you want everyone visiting your site to see a uniform language, you can set a force language value</span><br><span class="line">  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span><br><span class="line">  language:</span><br></pre></td></tr></table></figure>
<h3 id="pac阅读进度百分比"><a class="header-anchor" href="#pac阅读进度百分比">¶</a>pac阅读进度百分比</h3>
<p>1、github地址： https://github.com/HubSpot/pace，可以看下介绍<br>
2、修改值：<br>
修改主题下面的_config.yml：<br>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pace:</span><br><span class="line">    enable: <span class="literal">true</span></span><br><span class="line">    # Themes list:</span><br><span class="line">    # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span><br><span class="line">    # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span><br><span class="line">    theme: minimal</span><br></pre></td></tr></table></figure></p>
<h3 id="reading-progress"><a class="header-anchor" href="#reading-progress">¶</a>reading_progress</h3>
<p>github地址：https://github.com/theme-next/theme-next-reading-progress</p>
<p>包含使用说明和具体的步骤，就不搬运了，及时调整。</p>
<h3 id="文章字数和阅读时间统计："><a class="header-anchor" href="#文章字数和阅读时间统计：">¶</a>文章字数和阅读时间统计：</h3>
<p>hexo配置文件中修改：<br>
<code>symbols_count_time</code> 为true.</p>
<h3 id="back2top"><a class="header-anchor" href="#back2top">¶</a>back2top</h3>
<p>开启模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: true</span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure>
<h3 id="持续更新…"><a class="header-anchor" href="#持续更新…">¶</a>持续更新…</h3>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>hexo插件</tag>
      </tags>
  </entry>
  <entry>
    <title>「10」go mutex解读</title>
    <url>/archives/ff0d6c2b.html</url>
    <content><![CDATA[<p>上次说到rwmutex读写锁，其实就是加强了锁的粒度，区分读和写时不同的情况，核心思想：写优先于读。<br>
这次来看看mutex，go中的锁是如何实现的，用一张图来概括整个流程：</p>
<a id="more"></a>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/mutex.png" alt=""></p>
<blockquote>
<p>核心思想：饥饿和队列，正常流程都是加入到队列尾部，如果超过一定的时间限制则加入到队列头部。</p>
</blockquote>
<h3 id="前序"><a class="header-anchor" href="#前序">¶</a>前序</h3>
<blockquote>
<p>开始看代码或者分析之前，先看下文档说明及其相关的资料。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">◯  go version</span><br><span class="line">go version go1.14.9 darwin&#x2F;amd64</span><br></pre></td></tr></table></figure>
<h3 id="src-sync-mutex-go"><a class="header-anchor" href="#src-sync-mutex-go">¶</a>src/sync/mutex.go</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked      state &amp; mutexLocked 1==加锁  0==未加锁</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	mutexWoken                                      <span class="comment">//state &amp; mutexWoken 1==唤醒  0==未唤醒</span></span><br><span class="line">	mutexStarving                                   <span class="comment">// state &amp; mutexStarving 1==饥饿状态   0==正常状态</span></span><br><span class="line">	mutexWaiterShift = <span class="literal">iota</span>                         <span class="comment">// state &gt;&gt; mutexWaiterShift得到当前的goroutine数量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mutex fairness.</span></span><br><span class="line">	<span class="comment">// 两种模式：正常或饥饿</span></span><br><span class="line">    <span class="comment">// Mutex can be in 2 modes of operations: normal and starvation.</span></span><br><span class="line">    <span class="comment">//  正常模式就是FIFO队列。</span></span><br><span class="line">	<span class="comment">// In normal mode waiters are queued in FIFO order, but a woken up waiter</span></span><br><span class="line">	<span class="comment">// does not own the mutex and competes with new arriving goroutines over</span></span><br><span class="line">	<span class="comment">// the ownership. New arriving goroutines have an advantage -- they are</span></span><br><span class="line">	<span class="comment">// already running on CPU and there can be lots of them, so a woken up</span></span><br><span class="line">	<span class="comment">// waiter has good chances of losing. In such case it is queued at front</span></span><br><span class="line">	<span class="comment">// of the wait queue. If a waiter fails to acquire the mutex for more than 1ms,  //获取锁的时间超过1ms，切换到饥饿模式</span></span><br><span class="line">	<span class="comment">// it switches mutex to the starvation mode.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// In starvation mode ownership of the mutex is directly handed off from        //饥饿模式下锁的所有权直接从解锁goroutine的waiter手中移交到队列的前面。</span></span><br><span class="line">	<span class="comment">// the unlocking goroutine to the waiter at the front of the queue.</span></span><br><span class="line">	<span class="comment">// New arriving goroutines don&#x27;t try to acquire the mutex even if it appears</span></span><br><span class="line">	<span class="comment">// to be unlocked, and don&#x27;t try to spin. Instead they queue themselves at</span></span><br><span class="line">	<span class="comment">// the tail of the wait queue.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If a waiter receives ownership of the mutex and sees that either         //如果一个锁的所有权的等待者是以下两种情况之一的：1、处于队列的最后一个2、等待时间少于1ms，则切换到正常模式</span></span><br><span class="line">	<span class="comment">// (1) it is the last waiter in the queue, or (2) it waited for less than 1 ms,</span></span><br><span class="line">	<span class="comment">// it switches mutex back to normal operation mode.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Normal mode has considerably better performance as a goroutine can acquire</span></span><br><span class="line">	<span class="comment">// a mutex several times in a row even if there are blocked waiters.</span></span><br><span class="line">	<span class="comment">// Starvation mode is important to prevent pathological cases of tail latency.</span></span><br><span class="line">	starvationThresholdNs = <span class="number">1e6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="加锁流程"><a class="header-anchor" href="#加锁流程">¶</a>加锁流程</h3>
<blockquote>
<p>加锁过程图如上图提到的流程。</p>
</blockquote>
<blockquote>
<p>加锁代码具体流程：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">		<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">			race.Acquire(unsafe.Pointer(m))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">	m.lockSlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">lockSlow</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> waitStartTime <span class="keyword">int64</span> <span class="comment">//等待时间</span></span><br><span class="line">	starving := <span class="literal">false</span>       <span class="comment">//是否处于饥饿状态</span></span><br><span class="line">	awoke := <span class="literal">false</span>          <span class="comment">//唤醒状态</span></span><br><span class="line">	iter := <span class="number">0</span>               <span class="comment">//自旋次数</span></span><br><span class="line">	old := m.state          <span class="comment">//当前状态copy</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Don&#x27;t spin in starvation mode, ownership is handed off to waiters</span></span><br><span class="line">        <span class="comment">// so we won&#x27;t be able to acquire the mutex anyway.</span></span><br><span class="line">        <span class="comment">//加锁且能够自旋</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">			<span class="comment">// Active spinning makes sense.</span></span><br><span class="line">			<span class="comment">// Try to set mutexWoken flag to inform Unlock</span></span><br><span class="line">            <span class="comment">// to not wake other blocked goroutines.</span></span><br><span class="line">            <span class="comment">//自旋过程发现没有被置woken标识，设置标识，将自己置为唤醒</span></span><br><span class="line">			<span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">				awoke = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			runtime_doSpin()    <span class="comment">//自旋</span></span><br><span class="line">			iter++              </span><br><span class="line">			old = m.state       <span class="comment">//状态重置</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新状态</span></span><br><span class="line">		<span class="built_in">new</span> := old</span><br><span class="line">        <span class="comment">// Don&#x27;t try to acquire starving mutex, new arriving goroutines must queue.</span></span><br><span class="line">        <span class="comment">//非饥饿模式，则置锁</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> |= mutexLocked</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处于饥饿模式下，新来的goroutine进入队列中</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// The current goroutine switches mutex to starvation mode.</span></span><br><span class="line">		<span class="comment">// But if the mutex is currently unlocked, don&#x27;t do the switch.</span></span><br><span class="line">		<span class="comment">// Unlock expects that starving mutex has waiters, which will not</span></span><br><span class="line">        <span class="comment">// be true in this case.</span></span><br><span class="line">        <span class="comment">//切换到饥饿模式下</span></span><br><span class="line">		<span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> |= mutexStarving</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前处于唤醒状态，则重置清除唤醒状态。</span></span><br><span class="line">		<span class="keyword">if</span> awoke &#123;</span><br><span class="line">			<span class="comment">// The goroutine has been woken from sleep,</span></span><br><span class="line">			<span class="comment">// so we need to reset the flag in either case.</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//CAS更新状态。</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">//获取到锁</span></span><br><span class="line">			<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// If we were already waiting before, queue at the front of the queue.</span></span><br><span class="line">            <span class="comment">//等待队列的时间</span></span><br><span class="line">			queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">			<span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">				waitStartTime = runtime_nanotime()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//acquire阻塞队列....</span></span><br><span class="line">            <span class="comment">// 新来的 goroutine, queueLifo=false, 加入到等待队列的尾部，耐心等待</span></span><br><span class="line">            <span class="comment">// 唤醒的 goroutine, queueLifo=true, 加入到等待队列的头部</span></span><br><span class="line">			runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">            old = m.state</span><br><span class="line">            <span class="comment">//处于饥饿模式</span></span><br><span class="line">			<span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// If this goroutine was woken and mutex is in starvation mode,</span></span><br><span class="line">				<span class="comment">// ownership was handed off to us but mutex is in somewhat</span></span><br><span class="line">				<span class="comment">// inconsistent state: mutexLocked is not set and we are still</span></span><br><span class="line">				<span class="comment">// accounted as waiter. Fix that.</span></span><br><span class="line">				<span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">					throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//等待的goroutine-1</span></span><br><span class="line">                delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">                <span class="comment">// 处于队列中最后一个或者请求锁的时间未超过starvationThresholdNs，则回退到正常模式。</span></span><br><span class="line">				<span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">					<span class="comment">// Exit starvation mode.</span></span><br><span class="line">					<span class="comment">// Critical to do it here and consider wait time.</span></span><br><span class="line">					<span class="comment">// Starvation mode is so inefficient, that two goroutines</span></span><br><span class="line">					<span class="comment">// can go lock-step infinitely once they switch mutex</span></span><br><span class="line">					<span class="comment">// to starvation mode.</span></span><br><span class="line">					delta -= mutexStarving</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新状态</span></span><br><span class="line">				atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重置迭代器和唤醒表示，继续获取锁</span></span><br><span class="line">			awoke = <span class="literal">true</span></span><br><span class="line">			iter = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//CAS失败，则更新状态，继续获取。</span></span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Acquire(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="解锁过程"><a class="header-anchor" href="#解锁过程">¶</a>解锁过程</h3>
<p>用一个流程图来表示解锁过程：</p>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/mutex-unlock.png" alt=""></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//state 不是处于锁的状态, 那么就是 Unlock 根本没有加锁的 mutex, panic</span></span><br><span class="line">    <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁，并通知其它等待者</span></span><br><span class="line">    <span class="comment">// 锁如果处于饥饿状态，直接交给等待队列的第一个, 唤醒它，让它去获取锁</span></span><br><span class="line">    <span class="comment">// mutex 正常模式</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">        old := <span class="built_in">new</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有等待者，或者已经存在一个 goroutine 被唤醒或得到锁、或处于饥饿模式</span></span><br><span class="line">            <span class="comment">// 直接返回.</span></span><br><span class="line">            <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将等待的 goroutine-1，并设置 woken 标识</span></span><br><span class="line">            <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">            <span class="comment">// 设置新的 state, 这里通过信号量会唤醒一个阻塞的 goroutine 去获取锁.</span></span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">                runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// mutex 饥饿模式，直接将 mutex 拥有权移交给等待队列最前端的 goroutine</span></span><br><span class="line">        <span class="comment">// 注意此时 state 的 mutex 还没有加锁，唤醒的 goroutine 会设置它。</span></span><br><span class="line">        <span class="comment">// 在此期间，如果有新的 goroutine 来请求锁， 因为 mutex 处于饥饿状态， mutex 还是被认为处于锁状态，</span></span><br><span class="line">        <span class="comment">// 新来的 goroutine 不会把锁抢过去.</span></span><br><span class="line">        runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="关键点"><a class="header-anchor" href="#关键点">¶</a>关键点</h3>
<ul>
<li>不要重复锁定互斥锁</li>
<li>不要忘记解锁互斥锁</li>
<li>不要在多个函数之间直接传递互斥锁</li>
</ul>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go源码</tag>
        <tag>Go Package</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>「9」Go reflect ~ DeepEqual</title>
    <url>/archives/e2e7cc4e.html</url>
    <content><![CDATA[<p>今天无意中看到Go101发了一个推特:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  fmt.Print(<span class="string">&quot;:&quot;</span>, reflect.DeepEqual(a, b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := [<span class="number">1</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;&#125;&#125;</span><br><span class="line">  p(a, a)</span><br><span class="line">  p(a[:], a[:])</span><br><span class="line">  b := a</span><br><span class="line">  p(a[:], b[:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果？？ :true:true:false</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>正确答案 :false:true:false</p>
</blockquote>
<h3 id="错误来源"><a class="header-anchor" href="#错误来源">¶</a>错误来源</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一个为啥想着为true,第一眼看过去，比较两个a的函数，那两个函数肯定是相等的，这是第一直觉(狗屁直觉).</span><br><span class="line">第二个两个都为nil了，这个是没有什么问题，两个nil肯定是deep相等的。</span><br><span class="line">第三个虽然是重新初始化了，所以两个肯定不是deep相等的。</span><br></pre></td></tr></table></figure>
<h3 id="思路比对（错在哪里）"><a class="header-anchor" href="#思路比对（错在哪里）">¶</a>思路比对（错在哪里）</h3>
<p>查阅文档之后，发现理解错了：</p>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/20200918-124746.png" alt=""></p>
<h3 id="DeepEqual正确理解"><a class="header-anchor" href="#DeepEqual正确理解">¶</a>DeepEqual正确理解</h3>
<blockquote>
<p>源码也很简洁：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeepEqual</span><span class="params">(x, y <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">//同nil</span></span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> || y == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x == y</span><br><span class="line">	&#125;</span><br><span class="line">	v1 := ValueOf(x)</span><br><span class="line">  v2 := ValueOf(y)</span><br><span class="line">  <span class="comment">//属于同一类型</span></span><br><span class="line">	<span class="keyword">if</span> v1.Type() != v2.Type() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> deepValueEqual(v1, v2, <span class="built_in">make</span>(<span class="keyword">map</span>[visit]<span class="keyword">bool</span>), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了上面看源码，主要还是要看官方的文档和说明性的，这个算是理解源码的前提把：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DeepEqual reports whether x and y are ``deeply equal,&#x27;&#x27; defined as follows.</span></span><br><span class="line"><span class="comment">// Two values of identical type are deeply equal if one of the following cases applies.</span></span><br><span class="line"><span class="comment">// Values of distinct types are never deeply equal.</span></span><br><span class="line"><span class="comment">//  条件：数组深度相等，相应的元素都是相等的。</span></span><br><span class="line"><span class="comment">// Array values are deeply equal when their corresponding elements are deeply equal.</span></span><br><span class="line"><span class="comment">//  条件：结构体相对应的字段都是相等的。</span></span><br><span class="line"><span class="comment">// Struct values are deeply equal if their corresponding fields,</span></span><br><span class="line"><span class="comment">// both exported and unexported, are deeply equal.</span></span><br><span class="line"><span class="comment">// 条件：函数都是nil，则为深度相等，其它情况下都是不相等的。</span></span><br><span class="line"><span class="comment">// Func values are deeply equal if both are nil; otherwise they are not deeply equal.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 条件：两个interface持有深度相同的值。</span></span><br><span class="line"><span class="comment">// Interface values are deeply equal if they hold deeply equal concrete values.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    条件：下面条件为<span class="literal">true</span>，则深度相等：</span><br><span class="line">    两个全是<span class="literal">nil</span>，或者全non-<span class="literal">nil</span>，有相同的长度并且有相同的对象/key对应的值是相等的。</span><br><span class="line"><span class="comment">// Map values are deeply equal when all of the following are true:</span></span><br><span class="line"><span class="comment">// they are both nil or both non-nil, they have the same length,</span></span><br><span class="line"><span class="comment">// and either they are the same map object or their corresponding keys</span></span><br><span class="line"><span class="comment">// (matched using Go equality) map to deeply equal values.</span></span><br><span class="line">    条件：用 == 比较或者 point的</span><br><span class="line"><span class="comment">// Pointer values are deeply equal if they are equal using Go&#x27;s == operator</span></span><br><span class="line"><span class="comment">// or if they point to deeply equal values.</span></span><br><span class="line">    条件：下面条件为<span class="literal">true</span>，则深度相等：</span><br><span class="line">    两个全是<span class="literal">nil</span>，或者全non-<span class="literal">nil</span>，有相同的长度，指向相同的初始化节点（即：相同的数组）或相同的元素深度相等。</span><br><span class="line">    注意：empty和<span class="literal">nil</span> slice不是深度相等的。</span><br><span class="line"><span class="comment">// Slice values are deeply equal when all of the following are true:</span></span><br><span class="line"><span class="comment">// they are both nil or both non-nil, they have the same length,</span></span><br><span class="line"><span class="comment">// and either they point to the same initial entry of the same underlying array</span></span><br><span class="line"><span class="comment">// (that is, &amp;x[0] == &amp;y[0]) or their corresponding elements (up to length) are deeply equal.</span></span><br><span class="line"><span class="comment">// Note that a non-nil empty slice and a nil slice (for example, []byte&#123;&#125; and []byte(nil))</span></span><br><span class="line"><span class="comment">// are not deeply equal.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Other values - numbers, bools, strings, and channels - are deeply equal</span></span><br><span class="line"><span class="comment">// if they are equal using Go&#x27;s == operator.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In general DeepEqual is a recursive relaxation of Go&#x27;s == operator.</span></span><br><span class="line"><span class="comment">// However, this idea is impossible to implement without some inconsistency.</span></span><br><span class="line"><span class="comment">// Specifically, it is possible for a value to be unequal to itself,</span></span><br><span class="line"><span class="comment">// either because it is of func type (uncomparable in general)</span></span><br><span class="line"><span class="comment">// or because it is a floating-point NaN value (not equal to itself in floating-point comparison),</span></span><br><span class="line"><span class="comment">// or because it is an array, struct, or interface containing</span></span><br><span class="line"><span class="comment">// such a value.</span></span><br><span class="line"><span class="comment">// On the other hand, pointer values are always equal to themselves,</span></span><br><span class="line"><span class="comment">// even if they point at or contain such problematic values,</span></span><br><span class="line"><span class="comment">// because they compare equal using Go&#x27;s == operator, and that</span></span><br><span class="line"><span class="comment">// is a sufficient condition to be deeply equal, regardless of content.</span></span><br><span class="line"><span class="comment">// DeepEqual has been defined so that the same short-cut applies</span></span><br><span class="line"><span class="comment">// to slices and maps: if x and y are the same slice or the same map,</span></span><br><span class="line"><span class="comment">// they are deeply equal regardless of content.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// As DeepEqual traverses the data values it may find a cycle. The</span></span><br><span class="line"><span class="comment">// second and subsequent times that DeepEqual compares two pointer</span></span><br><span class="line"><span class="comment">// values that have been compared before, it treats the values as</span></span><br><span class="line"><span class="comment">// equal rather than examining the values to which they point.</span></span><br><span class="line"><span class="comment">// This ensures that DeepEqual terminates.</span></span><br></pre></td></tr></table></figure>
<p>再看看详细的deepValueEqual,大致的过程：<br>
<img src="https://crab-1251738482.cos.accelerate.myqcloud.com/20200920-103516@2x.png" alt=""></p>
<blockquote>
<p>大致分为三个过程：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、判断类型和值</span><br><span class="line">2、hard回调</span><br><span class="line">3、按照kind分类处理</span><br></pre></td></tr></table></figure>
<h4 id="数组："><a class="header-anchor" href="#数组：">¶</a>数组：</h4>
<p>比较每一个元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v1.Len(); i++ &#123;</span><br><span class="line">	<span class="keyword">if</span> !deepValueEqual(v1.Index(i), v2.Index(i), visited, depth+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="Slice"><a class="header-anchor" href="#Slice">¶</a>Slice</h4>
<ul>
<li>比较为nil</li>
<li>比较长度</li>
<li>比较地址</li>
<li>比较每一个元素</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> v1.IsNil() != v2.IsNil() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v1.Len() != v2.Len() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v1.Pointer() == v2.Pointer() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v1.Len(); i++ &#123;</span><br><span class="line">	<span class="keyword">if</span> !deepValueEqual(v1.Index(i), v2.Index(i), visited, depth+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="Interface"><a class="header-anchor" href="#Interface">¶</a>Interface</h4>
<ul>
<li>比较nil</li>
<li>递归比较</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> v1.IsNil() || v2.IsNil() &#123;</span><br><span class="line">	<span class="keyword">return</span> v1.IsNil() == v2.IsNil()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> deepValueEqual(v1.Elem(), v2.Elem(), visited, depth+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Ptr"><a class="header-anchor" href="#Ptr">¶</a>Ptr</h4>
<ul>
<li>地址</li>
<li>递归比较</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> v1.Pointer() == v2.Pointer() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> deepValueEqual(v1.Elem(), v2.Elem(), visited, depth+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="struct"><a class="header-anchor" href="#struct">¶</a>struct</h4>
<ul>
<li>比较每一个元素</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> i, n := <span class="number">0</span>, v1.NumField(); i &lt; n; i++ &#123;</span><br><span class="line">	<span class="keyword">if</span> !deepValueEqual(v1.Field(i), v2.Field(i), visited, depth+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="Map"><a class="header-anchor" href="#Map">¶</a>Map</h4>
<ul>
<li>比较Nil</li>
<li>比较长度</li>
<li>地址比较</li>
<li>每一个key对应的value</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> v1.IsNil() != v2.IsNil() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v1.Len() != v2.Len() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v1.Pointer() == v2.Pointer() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> v1.MapKeys() &#123;</span><br><span class="line">	val1 := v1.MapIndex(k)</span><br><span class="line">	val2 := v2.MapIndex(k)</span><br><span class="line">	<span class="keyword">if</span> !val1.IsValid() || !val2.IsValid() || !deepValueEqual(val1, val2, visited, depth+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="Func"><a class="header-anchor" href="#Func">¶</a>Func</h4>
<ul>
<li>非nil，为不等。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> v1.IsNil() &amp;&amp; v2.IsNil() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Can&#x27;t do better than this:</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="painc注意点："><a class="header-anchor" href="#painc注意点：">¶</a>painc注意点：</h3>
<p>deepValueEqual函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> .....</span><br><span class="line"> ....</span><br><span class="line"> ...</span><br><span class="line"> ..</span><br><span class="line"> .</span><br><span class="line"> 递归次数超过<span class="number">10</span>次则会painc....</span><br><span class="line"> <span class="comment">// if depth &gt; 10 &#123; panic(&quot;deepValueEqual&quot;) &#125;	// for debugging</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We want to avoid putting more in the visited map than we need to.</span></span><br><span class="line"><span class="comment">// For any possible reference cycle that might be encountered,</span></span><br><span class="line"><span class="comment">// hard(v1, v2) needs to return true for at least one of the types in the cycle,</span></span><br><span class="line"><span class="comment">// and it&#x27;s safe and valid to get Value&#x27;s internal pointer.</span></span><br><span class="line">hard := <span class="function"><span class="keyword">func</span><span class="params">(v1, v2 Value)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> v1.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> Map, Slice, Ptr, Interface:</span><br><span class="line">		<span class="comment">// Nil pointers cannot be cyclic. Avoid putting them in the visited map.</span></span><br><span class="line">		<span class="keyword">return</span> !v1.IsNil() &amp;&amp; !v2.IsNil()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"> &#125;</span><br><span class="line"> .</span><br><span class="line"> ..</span><br><span class="line"> ...</span><br><span class="line"> ....</span><br><span class="line"> .....</span><br><span class="line"> ......</span><br></pre></td></tr></table></figure>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go Package</tag>
        <tag>Day</tag>
        <tag>Go reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>「8」go rwmutex解读</title>
    <url>/archives/3038b6c3.html</url>
    <content><![CDATA[<pre><code>好久没有更新文章了，表达能力生疏了许多😄....
今天扯扯:rwmutex 被称为读写锁。一说到【锁】最直接的联想可能就是lock()、Rlock()、unlock()、Runlock()之类的，但是作为程序猿，还是要了解下底层的设计和相关的逻辑实现，以便于把这种锁的设计思想应用到其它场景中，好了，不废话了，开题吧。
从锁的结构设计--&gt;加锁的过程---&gt;加锁的粒度----&gt;解锁释放，整个生命周期来看rwmutex的具体实现。
</code></pre>
<a id="more"></a>
<h3 id="版本"><a class="header-anchor" href="#版本">¶</a>版本</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">◯  go version</span><br><span class="line">go version go1.14.9 darwin&#x2F;amd64</span><br></pre></td></tr></table></figure>
<h3 id="同向对比rwmutex锁的设计"><a class="header-anchor" href="#同向对比rwmutex锁的设计">¶</a>同向对比rwmutex锁的设计</h3>
<pre><code>java实现：AQS(AbstractQueuedSynchronizer)
</code></pre>
<h3 id="结构设计"><a class="header-anchor" href="#结构设计">¶</a>结构设计</h3>
<blockquote>
<p>原则：读写互斥，优先写。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	w           Mutex  <span class="comment">// held if there are pending writers</span></span><br><span class="line">	writerSem   <span class="keyword">uint32</span> <span class="comment">// semaphore for writers to wait for completing readers  写信号量</span></span><br><span class="line">	readerSem   <span class="keyword">uint32</span> <span class="comment">// semaphore for readers to wait for completing writers  读信号量</span></span><br><span class="line">	readerCount <span class="keyword">int32</span>  <span class="comment">// number of pending readers 读计数</span></span><br><span class="line">	readerWait  <span class="keyword">int32</span>  <span class="comment">// number of departing readers   读等待（write进行）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span>   <span class="comment">//最大读锁的个数</span></span><br></pre></td></tr></table></figure>
<p>其它再分类就是四个主要的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RLock</span><br><span class="line">RUnLock</span><br><span class="line">Lock</span><br><span class="line">UnLock</span><br></pre></td></tr></table></figure>
<h3 id="加锁过程"><a class="header-anchor" href="#加锁过程">¶</a>加锁过程</h3>
<h4 id="RLock过程"><a class="header-anchor" href="#RLock过程">¶</a>RLock过程</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Disable()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果写锁被获取的，则readerCount&lt;0的，阻塞状态</span></span><br><span class="line">    <span class="comment">//如果写锁没有被获取，则readerCount &gt;0的，获取读锁，不阻塞</span></span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// A writer is pending, wait for it. </span></span><br><span class="line">        <span class="comment">//写锁被获取了，加到G队列后面，挂起。</span></span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Lock过程"><a class="header-anchor" href="#Lock过程">¶</a>Lock过程</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lock locks rw for writing.</span></span><br><span class="line"><span class="comment">// If the lock is already locked for reading or writing,</span></span><br><span class="line"><span class="comment">// Lock blocks until the lock is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// First, resolve competition with other writers.</span></span><br><span class="line">    <span class="comment">//使用mutex锁</span></span><br><span class="line">	rw.w.Lock()</span><br><span class="line">	<span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">	<span class="comment">// Wait for active readers.</span></span><br><span class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//等待活跃的reader结束后，再给一个写的信号量，保证此刻之后的reader挂起。</span></span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加锁的粒度"><a class="header-anchor" href="#加锁的粒度">¶</a>加锁的粒度</h3>
<blockquote>
<p>读 &amp; 写 互不干扰.</p>
</blockquote>
<h3 id="解锁释放"><a class="header-anchor" href="#解锁释放">¶</a>解锁释放</h3>
<h4 id="RUnLock"><a class="header-anchor" href="#RUnLock">¶</a>RUnLock</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">		race.Disable()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写锁等待状态，检查当前是否可以进行获取</span></span><br><span class="line">	<span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Outlined slow-path to allow the fast-path to be inlined</span></span><br><span class="line">		rw.rUnlockSlow(r)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">rUnlockSlow</span><span class="params">(r <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// r + 1 == 0表示直接执行RUnlock()</span></span><br><span class="line">	<span class="comment">// r + 1 == -rwmutexMaxReaders表示执行Lock()再执行RUnlock()</span></span><br><span class="line">	<span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		throw(<span class="string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// A writer is pending.</span></span><br><span class="line">    <span class="comment">// 当读锁释放完毕后，通知写锁</span></span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// The last reader unblocks the writer.</span></span><br><span class="line">		runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="UnLock"><a class="header-anchor" href="#UnLock">¶</a>UnLock</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Release(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Announce to readers there is no active writer.</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">    <span class="comment">//说明这个没有枷锁，没法再次释放</span></span><br><span class="line">	<span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		throw(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// Unblock blocked readers, if any.</span></span><br><span class="line">    <span class="comment">//释放所有的锁。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</span><br><span class="line">		runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Allow other writers to proceed.</span></span><br><span class="line">	rw.w.Unlock()</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3>
<blockquote>
<p>读&amp;写，互不干扰。</p>
</blockquote>
<ul>
<li>
<p>读锁不能阻塞读锁，引入readerCount.</p>
</li>
<li>
<p>读锁需要阻塞写锁，直到所以读锁都释放，引入readerSem.</p>
</li>
<li>
<p>写锁需要阻塞读锁，直到所以写锁都释放，引入wirterSem.</p>
</li>
<li>
<p>写锁需要阻塞写锁，引入Metux.</p>
</li>
</ul>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go源码</tag>
        <tag>Go Package</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>「7」Go Context包使用</title>
    <url>/archives/410dfaec.html</url>
    <content><![CDATA[<h3 id="版本"><a class="header-anchor" href="#版本">¶</a>版本</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">◯  go version</span><br><span class="line">go version go1.14.9 darwin&#x2F;amd64</span><br></pre></td></tr></table></figure>
<h3 id="用Go的都离不开Context，引用官网的一句话来描述Context包："><a class="header-anchor" href="#用Go的都离不开Context，引用官网的一句话来描述Context包：">¶</a>用Go的都离不开Context，引用官网的一句话来描述Context包：</h3>
<blockquote>
<p>Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.</p>
</blockquote>
<p>主要掌握四个方法的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WithCancel</span><br><span class="line">WithDeadline</span><br><span class="line">WithTimeout</span><br><span class="line">WithValue</span><br></pre></td></tr></table></figure>
<h3 id="前期ready"><a class="header-anchor" href="#前期ready">¶</a>前期ready</h3>
<p>要用下面的方法，先了解下部分结构和逻辑：</p>
<blockquote>
<p>既然context全部都是和取消相关的，最起码Go在设计时会有这么一个结构。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>具体的取消设计结构</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type cancelCtx struct &#123;</span><br><span class="line">	Context</span><br><span class="line"></span><br><span class="line">	mu       sync.Mutex            &#x2F;&#x2F; protects following fields  加锁用</span><br><span class="line">	done     chan struct&#123;&#125;         &#x2F;&#x2F; created lazily, closed by first cancel call   控制channel</span><br><span class="line">	children map[canceler]struct&#123;&#125; &#x2F;&#x2F; set to nil by the first cancel call  cancel函数调用后，释放子类</span><br><span class="line">	err      error                 &#x2F;&#x2F; set to non-nil by the first cancel call</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>timer控制死锁时间结构：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; A timerCtx carries a timer and a deadline. It embeds a cancelCtx to</span><br><span class="line">&#x2F;&#x2F; implement Done and Err. It implements cancel by stopping its timer then</span><br><span class="line">&#x2F;&#x2F; delegating to cancelCtx.cancel.</span><br><span class="line"></span><br><span class="line">type timerCtx struct &#123;</span><br><span class="line">	cancelCtx  </span><br><span class="line">	timer *time.Timer &#x2F;&#x2F; Under cancelCtx.mu.</span><br><span class="line"></span><br><span class="line">	deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WithCancel"><a class="header-anchor" href="#WithCancel">¶</a>WithCancel</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">    if parent &#x3D;&#x3D; nil &#123;  &#x2F;&#x2F;日常判空</span><br><span class="line">		panic(&quot;cannot create context from nil parent&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	c :&#x3D; newCancelCtx(parent) &#x2F;&#x2F;cancelCtx new</span><br><span class="line">	propagateCancel(parent, &amp;c)  &#x2F;&#x2F;循环传播取消函数for ctx</span><br><span class="line">	return &amp;c, func() &#123; c.cancel(true, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看似很简单，四行解决，但是更重要的是学会看注释说明和相关的设计思路：<br>
TODO</p>
</blockquote>
<p>引用官方的语言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; WithCancel returns a copy of parent with a new Done channel. The returned</span><br><span class="line">&#x2F;&#x2F; context&#39;s Done channel is closed when the returned cancel function is called</span><br><span class="line">&#x2F;&#x2F; or when the parent context&#39;s Done channel is closed, whichever happens first.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Canceling this context releases resources associated with it, so code should</span><br><span class="line">&#x2F;&#x2F; call cancel as soon as the operations running in this Context complete.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Withcancel 返回的是一个parent的镜像&#x2F;复制，伴随一个Done channel通道。</span><br><span class="line">Done关闭状态取决于</span><br><span class="line">1、返回的cancel函数。</span><br><span class="line">2、parent的Done Channel关闭。</span><br><span class="line">这两个哪个先符合条件了。</span><br></pre></td></tr></table></figure>
<h3 id="WithDeadline-WithTimeout"><a class="header-anchor" href="#WithDeadline-WithTimeout">¶</a>WithDeadline/WithTimeout</h3>
<p>自己梳理的逻辑执行顺序：</p>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/20200907-152032.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Deadline&#x2F;WithTimeout区别：</span><br><span class="line"></span><br><span class="line">* deadline:的入参是一个具体的截止时间：Time.time</span><br><span class="line">* withTimeout:入参是一个多少时间后超时：Time.Duration</span><br></pre></td></tr></table></figure>
<h3 id="WithValue"><a class="header-anchor" href="#WithValue">¶</a>WithValue</h3>
<blockquote>
<p>Withvalue和value是成对出现的:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、给ctx设置k,v：withvalue(ctx,k,v)</span><br><span class="line">2、获取ctx中k的值value(ctx,k)</span><br></pre></td></tr></table></figure>
<h3 id="TODO"><a class="header-anchor" href="#TODO">¶</a>TODO</h3>
<h4 id="timerCtx详细的设计思路和结构文档"><a class="header-anchor" href="#timerCtx详细的设计思路和结构文档">¶</a>timerCtx详细的设计思路和结构文档</h4>
<h4 id="框架图整理"><a class="header-anchor" href="#框架图整理">¶</a>框架图整理</h4>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Go Package</tag>
      </tags>
  </entry>
  <entry>
    <title>「6」git 初阶:安装配置 ～1</title>
    <url>/archives/bddc30f6.html</url>
    <content><![CDATA[<blockquote>
<p>自盘古开天辟地～～～～<br>
扯远了…<br>
完整的分享下Git的使用和学习的知识点，之前章节中的<a href="http://blog.imrcrab.com/2020/09/01/Git%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">Git常用技巧</a>是我之前部分快速使用的场景，适合于有经验的开发者，现在来系统的分享下对于Git的理解，也算是自己学习的记录。</p>
</blockquote>
<h2 id="前景"><a class="header-anchor" href="#前景">¶</a>前景</h2>
<p>SVN估计是家喻户晓了，一直被用作<code>'版本管理'</code>和<code>代码仓库</code>。（ps:不算是完整的<code>版本管理</code>.）<br>
Git的出现，是linus之父休假时产出的“作品”,<code>版本管理</code> &amp; <code>代码仓库</code>的作用。总而言之，用熟练Git了，就再也回不去了。</p>
<a id="more"></a>
<h2 id="目标："><a class="header-anchor" href="#目标：">¶</a>目标：</h2>
<blockquote>
<p>最终可以顺利的提交代码即可。</p>
</blockquote>
<h2 id="此篇只分享两个知识点："><a class="header-anchor" href="#此篇只分享两个知识点：">¶</a>此篇只分享两个知识点：</h2>
<blockquote>
<p>安装Git和Git基本配置</p>
</blockquote>
<h3 id="Git安装"><a class="header-anchor" href="#Git安装">¶</a>Git安装</h3>
<p>说安装其实就是去官网下载软件，安装到你选定地方即可。</p>
<p>在此附上官网的下载链接： <a href="https://git-scm.com/download/">点击进入</a></p>
<p>选择对应平台windows?linux?macos?</p>
<p>ps:别选错了，那就very尴尬了。</p>
<h3 id="基本配置"><a class="header-anchor" href="#基本配置">¶</a>基本配置</h3>
<p>说到基本配置，大多数都会有，更何况是如此强大的版本控制软件。</p>
<h4 id="前期基本配置"><a class="header-anchor" href="#前期基本配置">¶</a>前期基本配置</h4>
<p>主要分三个地方：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、&#x2F;etc&#x2F;gitconfig 文件: 系统上每一个用户及其他们的仓库配置文件。</span><br><span class="line">2、~&#x2F;.gitconfig 或 ~&#x2F;.config&#x2F;git&#x2F;config 文件： 只针对当前用户生效。 [global配置]</span><br><span class="line">3、当前使用仓库的Git配置： .git&#x2F;config文件，仅仅对当前仓库配置生效。    [local配置]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ps: 优先机制：3 &gt; 2 &gt; 1  [.git/config覆盖~/.gitconfig、  ~/.gitconfig覆盖/etc/gitconfig]</p>
</blockquote>
<h5 id="注意："><a class="header-anchor" href="#注意：">¶</a>注意：</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">windows下的~&#x2F;.gitconfig路径为：C:\Users\$USER下；$USER指当前电脑用户名称</span><br></pre></td></tr></table></figure>
<h5 id="查看所有配置命令"><a class="header-anchor" href="#查看所有配置命令">¶</a>查看所有配置命令</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --list --show-origin</span><br></pre></td></tr></table></figure>
<h4 id="生成密钥-关联Github-Gitlab"><a class="header-anchor" href="#生成密钥-关联Github-Gitlab">¶</a>生成密钥&amp;关联Github/Gitlab</h4>
<h5 id="生成密钥"><a class="header-anchor" href="#生成密钥">¶</a>生成密钥</h5>
<blockquote>
<p>根据邮箱，会要求输入密码，连续3个回车即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;这里换上你的邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>最后得到id_rsa和id_rsa.pub两个文件。</p>
<p>这里用到的是你的 公钥<code>id_rsa.pub</code>文件，复制文件里面的内容到github密钥的界面：</p>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/20200902075825.png" alt=""></p>
<p>添加SSH完了之后，就绑定了你本机器和github的关联关系，相当于授权成功。</p>
<h5 id="拓展"><a class="header-anchor" href="#拓展">¶</a>拓展</h5>
<blockquote>
<p>上述生成密钥时也可以自定义文件名称.此种情况针对你有多个github账号时，提交公钥文件时，找出自定义名称的文件即可。（下图自定义生成文件名称pywang112,则公钥为pywang112.pub，看好你生成的路径哦）</p>
</blockquote>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/20200902080130.png" alt=""></p>
<h4 id="global配置（全局配置）或-local配置（当前仓库配置）"><a class="header-anchor" href="#global配置（全局配置）或-local配置（当前仓库配置）">¶</a>global配置（全局配置）或 local配置（当前仓库配置）</h4>
<h5 id="global配置（针对你只有一个git账户的情况）"><a class="header-anchor" href="#global配置（针对你只有一个git账户的情况）">¶</a>global配置（针对你只有一个git账户的情况）</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看命令：</span><br><span class="line">git config --global --list</span><br><span class="line"></span><br><span class="line">全局配置：</span><br><span class="line"></span><br><span class="line">git config --global user.name &quot;crab&quot;</span><br><span class="line">git config --global user.email &quot;imrcrab@163.com&quot;</span><br><span class="line"></span><br><span class="line">代理配置（按需可选）</span><br><span class="line"># http</span><br><span class="line">git config --global https.proxy http:&#x2F;&#x2F;127.0.0.1:1080 </span><br><span class="line"># sock</span><br><span class="line">git config --global http.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39; </span><br><span class="line"></span><br><span class="line">取消代理：</span><br><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure>
<h5 id="local配置-建议本地仓库配置，这样比较灵活"><a class="header-anchor" href="#local配置-建议本地仓库配置，这样比较灵活">¶</a>local配置 (建议本地仓库配置，这样比较灵活)</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看命令：</span><br><span class="line">git config --local --list</span><br><span class="line"></span><br><span class="line">全局配置：</span><br><span class="line"></span><br><span class="line">git config --local user.name &quot;crab&quot;</span><br><span class="line">git config --local user.email &quot;imrcrab@163.com&quot;</span><br><span class="line"></span><br><span class="line">代理配置（按需可选）</span><br><span class="line"># http</span><br><span class="line">git config --local https.proxy http:&#x2F;&#x2F;127.0.0.1:1080 </span><br><span class="line"># sock</span><br><span class="line">git config --local http.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39; </span><br><span class="line"></span><br><span class="line">取消代理：</span><br><span class="line">git config --local --unset http.proxy</span><br></pre></td></tr></table></figure>
<h4 id="配置完成，clone-commit代码"><a class="header-anchor" href="#配置完成，clone-commit代码">¶</a>配置完成，clone/commit代码</h4>
<h5 id="clone仓库代码"><a class="header-anchor" href="#clone仓库代码">¶</a>clone仓库代码</h5>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/20200902081306.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;crab21&#x2F;blog.git</span><br></pre></td></tr></table></figure>
<h5 id="commit代码"><a class="header-anchor" href="#commit代码">¶</a>commit代码</h5>
<blockquote>
<p>按照如上配置完成后，就可以完成基本的push和pull仓库代码了。</p>
</blockquote>
<h3 id="END"><a class="header-anchor" href="#END">¶</a>END</h3>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>「5」Git GPG签署工作</title>
    <url>/archives/580377d0.html</url>
    <content><![CDATA[<h3 id="GPG场景"><a class="header-anchor" href="#GPG场景">¶</a>GPG场景</h3>
<p>Git 虽然是密码级安全的，但它不是万无一失的。 如果你从因特网上的其他人那里拿取工作，并且想要验证提交是不是真正地来自于可信来源， Git 提供了几种通过 GPG 来签署和验证工作的方式。</p>
<p>最终效果：如下图所示</p>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/20200902123343.png" alt=""></p>
<h3 id="安装过程"><a class="header-anchor" href="#安装过程">¶</a>安装过程</h3>
<p>windows安装地址： <a href="https://www.gnupg.org/">点击下载</a></p>
<p>mac os为例：</p>
<a id="more"></a>
<h4 id="安装GPG"><a class="header-anchor" href="#安装GPG">¶</a>安装GPG</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install gpg</span><br><span class="line"></span><br><span class="line">查看结果：</span><br><span class="line">± gpg --version                                                                                                                                                                                                                                     ⏎</span><br><span class="line"></span><br><span class="line">gpg (GnuPG) 2.2.22</span><br><span class="line">libgcrypt 1.8.6</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;https:&#x2F;&#x2F;gnu.org&#x2F;licenses&#x2F;gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line">Home: &#x2F;Users&#x2F;gogoowang&#x2F;.gnupg</span><br><span class="line">支持的算法：</span><br><span class="line">公钥： RSA, ELG, DSA, ECDH, ECDSA, EDDSA</span><br><span class="line">密文： IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH,</span><br><span class="line">    CAMELLIA128, CAMELLIA192, CAMELLIA256</span><br><span class="line">散列： SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224</span><br><span class="line">压缩：  不压缩, ZIP, ZLIB, BZIP2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="生成密钥"><a class="header-anchor" href="#生成密钥">¶</a>生成密钥</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gpg --full-generate-key</span><br></pre></td></tr></table></figure>
<p>需要填写的地方：<br>
<img src="https://crab-1251738482.cos.accelerate.myqcloud.com/20200902123803.png" alt=""></p>
<h4 id="查看密钥完整信息"><a class="header-anchor" href="#查看密钥完整信息">¶</a>查看密钥完整信息</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gpg --list-secret-keys --keyid-format LONG</span><br></pre></td></tr></table></figure>
<blockquote>
<p>secret keys（红圈地方后续用到，留意下）：</p>
</blockquote>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/20200902124016.png" alt=""></p>
<h4 id="根据secret-keys生成PGP"><a class="header-anchor" href="#根据secret-keys生成PGP">¶</a>根据secret keys生成PGP</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gpg --armor --export  7BB8CF3593CA174C</span><br></pre></td></tr></table></figure>
<p>生成的PGP结果，后续需要将此结果导入到Github账号的配置信息中<br>
<img src="https://crab-1251738482.cos.accelerate.myqcloud.com/20200902124305.png" alt=""></p>
<h4 id="Github账号中设置"><a class="header-anchor" href="#Github账号中设置">¶</a>Github账号中设置</h4>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/20200902124443.png" alt=""></p>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/20200902124527.png" alt=""></p>
<blockquote>
<p>将上述生成的PGP填入，点击[Add GPG Key]即可</p>
</blockquote>
<h4 id="配置本地GPG签名信息"><a class="header-anchor" href="#配置本地GPG签名信息">¶</a>配置本地GPG签名信息</h4>
<p>依次执行下面命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、git config --global user.signingkey 7BB8CF3593CA174C  #此处的7BB8CF3593CA174C为生成的secret keys</span><br><span class="line">2、git config commit.gpgsign true</span><br><span class="line">3、git config --global commit.gpgsign true</span><br></pre></td></tr></table></figure>
<h4 id="Git-PGP生效"><a class="header-anchor" href="#Git-PGP生效">¶</a>Git PGP生效</h4>
<blockquote>
<p>再次提交commit即可生效。产生如下图的签名效果：</p>
</blockquote>
<p><img src="https://crab-1251738482.cos.accelerate.myqcloud.com/20200902123343.png" alt=""></p>
<h4 id="End"><a class="header-anchor" href="#End">¶</a>End</h4>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>「4」Git常用技巧</title>
    <url>/archives/3c1dd822.html</url>
    <content><![CDATA[<h3 id="学习方式"><a class="header-anchor" href="#学习方式">¶</a>学习方式</h3>
<p>多练多得，直接学习<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6">官网</a>理解。</p>
<p>以下仅仅是部分用到的场景和部分场景记录，不代表全部情况，如有错误，请及时指正。</p>
<h3 id="Git版本："><a class="header-anchor" href="#Git版本：">¶</a>Git版本：</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1944 ± git version </span><br><span class="line">git version 2.28.0</span><br></pre></td></tr></table></figure>
<h3 id="先说说Git的常用命令：-可跳过"><a class="header-anchor" href="#先说说Git的常用命令：-可跳过">¶</a>先说说Git的常用命令：(可跳过)</h3>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2081 ◯  git </span><br><span class="line">用法：git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;&#x3D;&lt;value&gt;]</span><br><span class="line">           [--exec-path[&#x3D;&lt;path&gt;]] [--html-path] [--man-path] [--info-path]</span><br><span class="line">           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]</span><br><span class="line">           [--git-dir&#x3D;&lt;path&gt;] [--work-tree&#x3D;&lt;path&gt;] [--namespace&#x3D;&lt;name&gt;]</span><br><span class="line">           &lt;command&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">这些是各种场合常见的 Git 命令：</span><br><span class="line"></span><br><span class="line">开始一个工作区（参见：git help tutorial）</span><br><span class="line">   clone             克隆仓库到一个新目录</span><br><span class="line">   init              创建一个空的 Git 仓库或重新初始化一个已存在的仓库</span><br><span class="line"></span><br><span class="line">在当前变更上工作（参见：git help everyday）</span><br><span class="line">   add               添加文件内容至索引</span><br><span class="line">   mv                移动或重命名一个文件、目录或符号链接</span><br><span class="line">   restore           恢复工作区文件</span><br><span class="line">   rm                从工作区和索引中删除文件</span><br><span class="line">   sparse-checkout   初始化及修改稀疏检出</span><br><span class="line"></span><br><span class="line">检查历史和状态（参见：git help revisions）</span><br><span class="line">   bisect            通过二分查找定位引入 bug 的提交</span><br><span class="line">   diff              显示提交之间、提交和工作区之间等的差异</span><br><span class="line">   grep              输出和模式匹配的行</span><br><span class="line">   log               显示提交日志</span><br><span class="line">   show              显示各种类型的对象</span><br><span class="line">   status            显示工作区状态</span><br><span class="line"></span><br><span class="line">扩展、标记和调校您的历史记录</span><br><span class="line">   branch            列出、创建或删除分支</span><br><span class="line">   commit            记录变更到仓库</span><br><span class="line">   merge             合并两个或更多开发历史</span><br><span class="line">   rebase            在另一个分支上重新应用提交</span><br><span class="line">   reset             重置当前 HEAD 到指定状态</span><br><span class="line">   switch            切换分支</span><br><span class="line">   tag               创建、列出、删除或校验一个 GPG 签名的标签对象</span><br><span class="line"></span><br><span class="line">协同（参见：git help workflows）</span><br><span class="line">   fetch             从另外一个仓库下载对象和引用</span><br><span class="line">   pull              获取并整合另外的仓库或一个本地分支</span><br><span class="line">   push              更新远程引用和相关的对象</span><br><span class="line"></span><br><span class="line">命令 &#39;git help -a&#39; 和 &#39;git help -g&#39; 显示可用的子命令和一些概念帮助。</span><br><span class="line">查看 &#39;git help &lt;命令&gt;&#39; 或 &#39;git help &lt;概念&gt;&#39; 以获取给定子命令或概念的</span><br><span class="line">帮助。</span><br><span class="line">有关系统的概述，查看 &#39;git help git&#39;</span><br></pre></td></tr></table></figure>
<h3 id="Git使用："><a class="header-anchor" href="#Git使用：">¶</a>Git使用：</h3>
<h4 id="生成密钥"><a class="header-anchor" href="#生成密钥">¶</a>生成密钥</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;这里换上你的邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>最后得到<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件。</p>
<h4 id="Git配置信息"><a class="header-anchor" href="#Git配置信息">¶</a>Git配置信息</h4>
<h5 id="查看配置信息"><a class="header-anchor" href="#查看配置信息">¶</a>查看配置信息</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看系统配置信息</span><br><span class="line">* git config --system --list</span><br><span class="line"></span><br><span class="line">当前用户配置</span><br><span class="line">* git config --global --list</span><br><span class="line"></span><br><span class="line">查看当前仓库配置</span><br><span class="line">* git config --local --list</span><br></pre></td></tr></table></figure>
<h5 id="设置用户信息"><a class="header-anchor" href="#设置用户信息">¶</a>设置用户信息</h5>
<p>全局设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;crab&quot;</span><br><span class="line">git config --global user.email &quot;imrcrab@163.com&quot;</span><br></pre></td></tr></table></figure>
<p>当前仓库生效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --local user.name &quot;crab&quot;</span><br><span class="line">git config --local user.email &quot;imrcrab@163.com&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Git-Remote"><a class="header-anchor" href="#Git-Remote">¶</a>Git Remote</h4>
<h5 id="新增remote地址"><a class="header-anchor" href="#新增remote地址">¶</a>新增remote地址</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add upstream http:&#x2F;&#x2F;github&#x2F;**remote**&#x2F;test.git</span><br><span class="line">git remote -v 可以查看具体路径</span><br></pre></td></tr></table></figure>
<h5 id="merge-fetch远程代码到XXX分支"><a class="header-anchor" href="#merge-fetch远程代码到XXX分支">¶</a>merge/fetch远程代码到XXX分支</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、git fetch upstream。</span><br><span class="line">2、切回到master分支。</span><br><span class="line">3、git merge upstream&#x2F;master 合并远程upstream分支到本地master。</span><br><span class="line">4、解决冲突或其他问题。</span><br></pre></td></tr></table></figure>
<h4 id="Git-误删除恢复"><a class="header-anchor" href="#Git-误删除恢复">¶</a>Git 误删除恢复</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、git  fsck --lost -found :查看最近移除的文件.</span><br><span class="line">2、git show  &#39;误删编号&#39;：查看删除文件内容.</span><br><span class="line">3、git merge ‘误删编号’： 本地合并误删的文件内容.</span><br></pre></td></tr></table></figure>
<h4 id="Git-reset撤回操作"><a class="header-anchor" href="#Git-reset撤回操作">¶</a>Git reset撤回操作</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、git reflog</span><br><span class="line">2、git reset COMMITID    就可以回到COMMITID那个分支和版本。</span><br></pre></td></tr></table></figure>
<h4 id="Git分支"><a class="header-anchor" href="#Git分支">¶</a>Git分支</h4>
<h5 id="用法"><a class="header-anchor" href="#用法">¶</a>用法</h5>
<blockquote>
<p>获取用法：Git branch -d --help</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法：git branch [&lt;选项&gt;] [-r | -a] [--merged | --no-merged]</span><br><span class="line">  或：git branch [&lt;选项&gt;] [-l] [-f] &lt;分支名&gt; [&lt;起始点&gt;]</span><br><span class="line">  或：git branch [&lt;选项&gt;] [-r] (-d | -D) &lt;分支名&gt;...</span><br><span class="line">  或：git branch [&lt;选项&gt;] (-m | -M) [&lt;旧分支&gt;] &lt;新分支&gt;</span><br><span class="line">  或：git branch [&lt;选项&gt;] (-c | -C) [&lt;老分支&gt;] &lt;新分支&gt;</span><br><span class="line">  或：git branch [&lt;选项&gt;] [-r | -a] [--points-at]</span><br><span class="line">  或：git branch [&lt;选项&gt;] [-r | -a] [--format]</span><br><span class="line"></span><br><span class="line">通用选项</span><br><span class="line">    -v, --verbose         显示哈希值和主题，若参数出现两次则显示上游分支</span><br><span class="line">    -q, --quiet           不显示信息</span><br><span class="line">    -t, --track           设置跟踪模式（参见 git-pull(1)）</span><br><span class="line">    -u, --set-upstream-to &lt;上游&gt;</span><br><span class="line">                          改变上游信息</span><br><span class="line">    --unset-upstream      取消上游信息的设置</span><br><span class="line">    --color[&#x3D;&lt;何时&gt;]      使用彩色输出</span><br><span class="line">    -r, --remotes         作用于远程跟踪分支</span><br><span class="line">    --contains &lt;提交&gt;     只打印包含该提交的分支</span><br><span class="line">    --no-contains &lt;提交&gt;  只打印不包含该提交的分支</span><br><span class="line">    --abbrev[&#x3D;&lt;n&gt;]        用 &lt;n&gt; 位数字显示 SHA-1 哈希值</span><br><span class="line"></span><br><span class="line">具体的 git-branch 动作：</span><br><span class="line">    -a, --all             列出远程跟踪及本地分支</span><br><span class="line">    -d, --delete          删除完全合并的分支</span><br><span class="line">    -D                    删除分支（即使没有合并）</span><br><span class="line">    -m, --move            移动&#x2F;重命名一个分支，以及它的引用日志</span><br><span class="line">    -M                    移动&#x2F;重命名一个分支，即使目标已存在</span><br><span class="line">    -c, --copy            拷贝一个分支和它的引用日志</span><br><span class="line">    -C                    拷贝一个分支，即使目标已存在</span><br><span class="line">    -l, --list            列出分支名</span><br><span class="line">    --show-current        显示当前分支名</span><br><span class="line">    --create-reflog       创建分支的引用日志</span><br><span class="line">    --edit-description    标记分支的描述</span><br><span class="line">    -f, --force           强制创建、移动&#x2F;重命名、删除</span><br><span class="line">    --merged &lt;提交&gt;       只打印已经合并的分支</span><br><span class="line">    --no-merged &lt;提交&gt;    只打印尚未合并的分支</span><br><span class="line">    --column[&#x3D;&lt;风格&gt;]     以列的方式显示分支</span><br><span class="line">    --sort &lt;key&gt;          排序的字段名</span><br><span class="line">    --points-at &lt;对象&gt;    只打印指向该对象的分支</span><br><span class="line">    -i, --ignore-case     排序和过滤属于大小写不敏感</span><br><span class="line">    --format &lt;格式&gt;       输出格式</span><br></pre></td></tr></table></figure>
<h5 id="获取所有分支"><a class="header-anchor" href="#获取所有分支">¶</a>获取所有分支</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -r | grep -v &#39;\-&gt;&#39; | while read remote; do git branch --track &quot;$&#123;remote#origin&#x2F;&#125;&quot; &quot;$remote&quot;; done</span><br><span class="line">git fetch --all</span><br><span class="line">git pull --all</span><br></pre></td></tr></table></figure>
<h5 id="add-remove分支"><a class="header-anchor" href="#add-remove分支">¶</a>add/remove分支</h5>
<p>新建&amp;切换:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b iss53</span><br><span class="line"></span><br><span class="line">是下面两条的简写：</span><br><span class="line">git branch iss53</span><br><span class="line">git checkout iss53</span><br></pre></td></tr></table></figure>
<p>删除分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d iss53</span><br></pre></td></tr></table></figure>
<h4 id="Git-stash"><a class="header-anchor" href="#Git-stash">¶</a>Git stash</h4>
<h5 id="常用："><a class="header-anchor" href="#常用：">¶</a>常用：</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）git stash save &quot;save message&quot;  : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</span><br><span class="line">（2）git stash list  ：查看stash了哪些存储</span><br><span class="line">（3）git stash show ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@&#123;$num&#125;，比如第二个 git stash show stash@&#123;1&#125;</span><br><span class="line">（4）git stash show -p : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show  stash@&#123;$num&#125;  -p ，比如第二个：git stash show  stash@&#123;1&#125;  -p</span><br><span class="line">（5）git stash apply :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@&#123;0&#125;，如果要使用其他个，git stash apply stash@&#123;$num&#125; ， 比如第二个：git stash apply stash@&#123;1&#125; </span><br><span class="line">（6）git stash pop ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@&#123;0&#125;，如果要应用并删除其他stash，命令：git stash pop stash@&#123;$num&#125; ，比如应用并删除第二个：git stash pop stash@&#123;1&#125;</span><br><span class="line">（7）git stash drop stash@&#123;$num&#125; ：丢弃stash@&#123;$num&#125;存储，从列表中删除这个存储</span><br><span class="line">（8）git stash clear ：删除所有缓存的stash</span><br></pre></td></tr></table></figure>
<h4 id="Git-Tag"><a class="header-anchor" href="#Git-Tag">¶</a>Git Tag</h4>
<h5 id="常用：-v2"><a class="header-anchor" href="#常用：-v2">¶</a>常用：</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2097 ± git tag -a --help</span><br><span class="line">用法：git tag [-a | -s | -u &lt;key-id&gt;] [-f] [-m &lt;消息&gt; | -F &lt;文件&gt;]</span><br><span class="line">		&lt;标签名&gt; [&lt;头&gt;]</span><br><span class="line">  或：git tag -d &lt;标签名&gt;...</span><br><span class="line">  或：git tag -l [-n[&lt;数字&gt;]] [--contains &lt;提交&gt;] [--no-contains &lt;提交&gt;] [--points-at &lt;对象&gt;]</span><br><span class="line">		[--format&#x3D;&lt;格式&gt;] [--[no-]merged [&lt;提交&gt;]] [&lt;模式&gt;...]</span><br><span class="line">  或：git tag -v [--format&#x3D;&lt;格式&gt;] &lt;标签名&gt;...</span><br><span class="line"></span><br><span class="line">    -l, --list            列出标签名称</span><br><span class="line">    -n[&lt;n&gt;]               每个标签信息打印 &lt;n&gt; 行</span><br><span class="line">    -d, --delete          删除标签</span><br><span class="line">    -v, --verify          验证标签</span><br><span class="line"></span><br><span class="line">标签创建选项</span><br><span class="line">    -a, --annotate        附注标签，需要一个说明</span><br><span class="line">    -m, --message &lt;说明&gt;  标签说明</span><br><span class="line">    -F, --file &lt;文件&gt;     从文件中读取提交说明</span><br><span class="line">    -e, --edit            强制编辑标签说明</span><br><span class="line">    -s, --sign            附注并附加 GPG 签名的标签</span><br><span class="line">    --cleanup &lt;模式&gt;      设置如何删除提交说明里的空格和#注释</span><br><span class="line">    -u, --local-user &lt;key-id&gt;</span><br><span class="line">                          使用另外的私钥签名该标签</span><br><span class="line">    -f, --force           如果存在，替换现有的标签</span><br><span class="line">    --create-reflog       创建引用日志</span><br><span class="line"></span><br><span class="line">标签列表选项</span><br><span class="line">    --column[&#x3D;&lt;风格&gt;]     以列的方式显示标签列表</span><br><span class="line">    --contains &lt;提交&gt;     只打印包含该提交的标签</span><br><span class="line">    --no-contains &lt;提交&gt;  只打印不包含该提交的标签</span><br><span class="line">    --merged &lt;提交&gt;       只打印已经合并的标签</span><br><span class="line">    --no-merged &lt;提交&gt;    只打印尚未合并的标签</span><br><span class="line">    --sort &lt;key&gt;          排序的字段名</span><br><span class="line">    --points-at &lt;对象&gt;    只打印指向该对象的标签</span><br><span class="line">    --format &lt;格式&gt;       输出格式</span><br><span class="line">    --color[&#x3D;&lt;何时&gt;]      遵照格式中的颜色输出</span><br><span class="line">    -i, --ignore-case     排序和过滤属于大小写不敏感</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag按照version排序：</span><br><span class="line">git tag -n</span><br><span class="line"></span><br><span class="line">git tag按照时间排序</span><br><span class="line">git tag -n --sort&#x3D;taggerdate</span><br></pre></td></tr></table></figure>
<h5 id="打Tag"><a class="header-anchor" href="#打Tag">¶</a>打Tag</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -a v0.0.1 -m &quot;V0.0.1&quot; </span><br></pre></td></tr></table></figure>
<h5 id="删除Tag"><a class="header-anchor" href="#删除Tag">¶</a>删除Tag</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -d v0.0.1</span><br></pre></td></tr></table></figure>
<h5 id="推送Tag"><a class="header-anchor" href="#推送Tag">¶</a>推送Tag</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master --tags</span><br></pre></td></tr></table></figure>
<h4 id="Git-push"><a class="header-anchor" href="#Git-push">¶</a>Git push</h4>
<h5 id="用法-v2"><a class="header-anchor" href="#用法-v2">¶</a>用法</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法：git push [&lt;选项&gt;] [&lt;仓库&gt; [&lt;引用规格&gt;...]]</span><br><span class="line"></span><br><span class="line">    -v, --verbose         更加详细</span><br><span class="line">    -q, --quiet           更加安静</span><br><span class="line">    --repo &lt;仓库&gt;         仓库</span><br><span class="line">    --all                 推送所有引用</span><br><span class="line">    --mirror              镜像所有引用</span><br><span class="line">    -d, --delete          删除引用</span><br><span class="line">    --tags                推送标签（不能使用 --all or --mirror）</span><br><span class="line">    -n, --dry-run         演习</span><br><span class="line">    --porcelain           机器可读的输出</span><br><span class="line">    -f, --force           强制更新</span><br><span class="line">    --force-with-lease[&#x3D;&lt;引用名&gt;:&lt;期望值&gt;]</span><br><span class="line">                          要求引用旧的取值为设定值</span><br><span class="line">    --recurse-submodules (check|on-demand|no)</span><br><span class="line">                          控制子模组的递归推送</span><br><span class="line">    --thin                使用精简打包</span><br><span class="line">    --receive-pack &lt;receive-pack&gt;</span><br><span class="line">                          接收包程序</span><br><span class="line">    --exec &lt;receive-pack&gt;</span><br><span class="line">                          接收包程序</span><br><span class="line">    -u, --set-upstream    设置 git pull&#x2F;status 的上游</span><br><span class="line">    --progress            强制显示进度报告</span><br><span class="line">    --prune               清除本地删除的引用</span><br><span class="line">    --no-verify           绕过 pre-push 钩子</span><br><span class="line">    --follow-tags         推送缺失但有关的标签</span><br><span class="line">    --signed[&#x3D;(yes|no|if-asked)]</span><br><span class="line">                          用 GPG 为推送签名</span><br><span class="line">    --atomic              需要远端支持原子事务</span><br><span class="line">    -o, --push-option &lt;server-specific&gt;</span><br><span class="line">                          传输选项</span><br><span class="line">    -4, --ipv4            只使用 IPv4 地址</span><br><span class="line">    -6, --ipv6            只使用 IPv6 地址</span><br></pre></td></tr></table></figure>
<h4 id="Git-rebase"><a class="header-anchor" href="#Git-rebase">¶</a>Git rebase</h4>
<h5 id="变基遵守的原则"><a class="header-anchor" href="#变基遵守的原则">¶</a>变基遵守的原则</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。---[官网变基](https:&#x2F;&#x2F;git-scm.com&#x2F;book&#x2F;zh&#x2F;v2&#x2F;Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA)</span><br><span class="line"></span><br><span class="line">TODO 后续更新此过程</span><br></pre></td></tr></table></figure>
<h5 id="经典用法："><a class="header-anchor" href="#经典用法：">¶</a>经典用法：</h5>
<blockquote>
<p>git rebase --help</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Assume the following history exists and the current branch is &quot;topic&quot;:</span><br><span class="line"></span><br><span class="line">              A---B---C topic</span><br><span class="line">             &#x2F;</span><br><span class="line">        D---E---F---G master</span><br><span class="line">From this point, the result of either of thefollowing </span><br><span class="line"></span><br><span class="line">commands:</span><br><span class="line">    git rebase master</span><br><span class="line">    git rebase master topic</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">would be:</span><br><span class="line">                      A&#39;--B&#39;--C&#39; topic</span><br><span class="line">                     &#x2F;</span><br><span class="line">        D---E---F---G master</span><br></pre></td></tr></table></figure>
<h5 id="rebase场景："><a class="header-anchor" href="#rebase场景：">¶</a>rebase场景：</h5>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA">官网例子</a></p>
<h3 id="Git-快速场景："><a class="header-anchor" href="#Git-快速场景：">¶</a>Git 快速场景：</h3>
<p>其实还是对上述命令的活学活用。</p>
<h4 id="Git-Reset场景"><a class="header-anchor" href="#Git-Reset场景">¶</a>Git Reset场景</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 本地修改了一堆文件(并没有使用git add到暂存区)，想放弃修改。</span><br><span class="line">单个文件&#x2F;文件夹：</span><br><span class="line"></span><br><span class="line">git checkout -- filename</span><br><span class="line"></span><br><span class="line">所有文件&#x2F;文件夹：</span><br><span class="line"></span><br><span class="line">git checkout .</span><br><span class="line"> </span><br><span class="line">2. 本地新增了一堆文件(并没有git add到暂存区)，想放弃修改。</span><br><span class="line">单个文件&#x2F;文件夹：</span><br><span class="line"></span><br><span class="line">$ rm filename &#x2F; rm dir -rf</span><br><span class="line"></span><br><span class="line">所有文件&#x2F;文件夹：</span><br><span class="line"></span><br><span class="line">$ git clean -xdf</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除新增的文件，如果文件已经已经git add到暂存区，并不会删除！</span><br><span class="line"></span><br><span class="line">3. 本地修改&#x2F;新增了一堆文件，已经git add到暂存区，想放弃修改。</span><br><span class="line">单个文件&#x2F;文件夹：</span><br><span class="line"></span><br><span class="line">git reset HEAD filename</span><br><span class="line"></span><br><span class="line">所有文件&#x2F;文件夹：</span><br><span class="line"></span><br><span class="line">git reset HEAD .</span><br><span class="line"> </span><br><span class="line">4. 本地通过git add &amp; git commit 之后，想要撤销此次commit和代码</span><br><span class="line"></span><br><span class="line">git reset commit_id</span><br><span class="line"></span><br><span class="line">这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位</span><br><span class="line">&#x2F;&#x2F; 撤销之后，你所做的已经commit的修改还在工作区！</span><br><span class="line"></span><br><span class="line">git reset --hard commit_id</span><br><span class="line"></span><br><span class="line">这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位</span><br><span class="line">&#x2F;&#x2F; 撤销之后，你所做的已经commit的修改将会清除，仍在工作区&#x2F;暂存区的代码不会清除！</span><br><span class="line"></span><br><span class="line">5. git add &amp; git commit 提交后，只想回滚commit：</span><br><span class="line">	git reset --soft HEAD^</span><br><span class="line">	注意这仅仅是回滚了你的commit，代码依旧在的。</span><br></pre></td></tr></table></figure>
<h3 id="持续更新…"><a class="header-anchor" href="#持续更新…">¶</a>持续更新…</h3>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>「3」git cz规范提交</title>
    <url>/archives/458b44c2.html</url>
    <content><![CDATA[<h3 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h3>
<p><a href="https://github.com/commitizen/cz-cli">官方 specification</a><br>
简单的说为了代码提交更加规范</p>
<h3 id="场景"><a class="header-anchor" href="#场景">¶</a>场景</h3>
<p>git commit使用<br>
<img src="https://github.com/commitizen/cz-cli/raw/master/meta/screenshots/add-commit.png" alt=""></p>
<h3 id="使用步骤"><a class="header-anchor" href="#使用步骤">¶</a>使用步骤</h3>
<ul>
<li>安装nodejs，版本建议最新.<a href="https://nodejs.org/zh-cn/">官网</a></li>
<li>打开你的命令行：</li>
</ul>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：npm install -g commitizen</span><br><span class="line">windows应该是cmd吧。</span><br><span class="line">mac用终端或者iterm2都可以。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示以下信息即成功。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt; % sudo npm install -g commitizen</span><br><span class="line">Password:</span><br><span class="line">npm WARN deprecated resolve-url@0.2.1: https:&#x2F;&#x2F;github.com&#x2F;lydell&#x2F;resolve-url#deprecated</span><br><span class="line">npm WARN deprecated urix@0.1.0: Please see https:&#x2F;&#x2F;github.com&#x2F;lydell&#x2F;urix#deprecated</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;cz -&gt; &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;commitizen&#x2F;bin&#x2F;git-cz</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;git-cz -&gt; &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;commitizen&#x2F;bin&#x2F;git-cz</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;commitizen -&gt; &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;commitizen&#x2F;bin&#x2F;commitizen</span><br><span class="line">+ commitizen@4.2.1</span><br><span class="line">updated 1 package in 8.132s</span><br></pre></td></tr></table></figure>
<p>3、进入git项目中，执行下面命令初始化环境。<br>
<code>commitizen init cz-conventional-changelog --save --save-exact</code></p>
<p>4、在提交代码时使用</p>
<blockquote>
<p>git cz 替换 git commit命令</p>
</blockquote>
<h3 id="注意事项"><a class="header-anchor" href="#注意事项">¶</a>注意事项</h3>
<ul>
<li>安装方式可选择全局安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g commitizen cz-conventional-changelog</span><br><span class="line">echo &#39;&#123; &quot;path&quot;: &quot;cz-conventional-changelog&quot; &#125;&#39; &gt; ~&#x2F;.czrc</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>「2」vscode 常见插件及其使用</title>
    <url>/archives/8cf3cbca.html</url>
    <content><![CDATA[<blockquote>
<p>vscode中一些常见的坑点…</p>
</blockquote>
<h3 id="插件"><a class="header-anchor" href="#插件">¶</a>插件</h3>
<h4 id="样式方面："><a class="header-anchor" href="#样式方面：">¶</a>样式方面：</h4>
<ul>
<li>Indent Rainbo</li>
<li>Bracket Pair Colorizer # 括号颜色</li>
<li>Chinese Language       # 汉化</li>
</ul>
<a id="more"></a>
<h4 id="功能方面"><a class="header-anchor" href="#功能方面">¶</a>功能方面</h4>
<ul>
<li>Git Blame              # Git提交查看</li>
<li>Code Spell Checker     # 拼写检查</li>
<li>Reload                 # 重新加载</li>
<li>Todo Tree              # 代办事项</li>
<li>Settings Sync          # 设置同步</li>
</ul>
]]></content>
      <tags>
        <tag>vscode</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>「1」重拾那份折腾之心，坚定脚步</title>
    <url>/archives/640b5696.html</url>
    <content><![CDATA[<pre><code>从前，现在，将来...</code></pre>
]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
</search>
